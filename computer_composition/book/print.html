<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Computer composition principles and assembly</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Computer composition principles and assembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<ul>
<li><a href="1.introduction.html#1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.计算机的基本概念</a></li>
<li><a href="1.introduction.html#12%E4%BF%A1%E6%81%AF%E7%9A%84%E6%95%B0%E5%AD%97%E5%8C%96%E8%A1%A8%E7%A4%BA">1.2.信息的数字化表示</a></li>
<li><a href="1.introduction.html#2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E8%BD%AF%E4%BB%B6%E7%BB%84%E6%88%90">2. 计算机系统的硬、软件组成</a>
<ul>
<li><a href="1.introduction.html#21-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%B3%BB%E7%BB%9F">2.1 计算机硬件系统</a></li>
<li><a href="1.introduction.html#22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E7%BB%84%E6%88%90">2.2 计算机软件组成</a>
<ul>
<li><a href="1.introduction.html#%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">系统软件</a></li>
<li><a href="1.introduction.html#%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">应用软件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="1.introduction.html#3-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B">3. 层次结构模型</a>
<ul>
<li><a href="1.introduction.html#31-%E4%BB%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E8%A7%92%E5%BA%A6%E5%88%92%E5%88%86%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">3.1 从计算机系统组成角度划分层次结构</a></li>
<li><a href="1.introduction.html#%E4%BB%8E%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E8%A7%92%E5%BA%A6%E5%88%92%E5%88%86%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">从语言功能角度划分层次结构</a></li>
<li><a href="1.introduction.html#%E8%BD%AF%E7%A1%AC%E4%BB%B6%E5%9C%A8%E9%80%BB%E8%BE%91%E4%B8%8A%E7%9A%84%E7%AD%89%E4%BB%B7">软、硬件在逻辑上的等价</a></li>
</ul>
</li>
<li><a href="1.introduction.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B">计算机的工作过程</a>
<ul>
<li><a href="1.introduction.html#%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%AD%A5%E9%AA%A4">处理问题的步骤</a></li>
<li><a href="1.introduction.html#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">指令执行过程</a></li>
</ul>
</li>
<li><a href="1.introduction.html#%E6%95%B0%E5%AD%97%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">数字计算机的特点与性能指标</a>
<ul>
<li><a href="1.introduction.html#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="1.introduction.html#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">性能指标</a></li>
</ul>
</li>
<li><a href="1.introduction.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8">计算机的发展与应用</a>
<ul>
<li><a href="1.introduction.html#%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B">发展历程</a></li>
<li><a href="1.introduction.html#%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%8A%80%E6%9C%AF">提高性能的若干技术</a></li>
<li><a href="1.introduction.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B">计算机应用举例</a></li>
</ul>
</li>
</ul>
<h1 id="1计算机的基本概念"><a class="header" href="#1计算机的基本概念">1.计算机的基本概念</a></h1>
<p>计算机的概念：计算机是一种能够存储程序，能够自动连续地执行程序，对各种数字化信息进行算术运算或逻辑运算的快速工具。</p>
<ul>
<li>冯诺依曼体制的核心要点
<ul>
<li>采用<code>二进制</code>代表数据和指令，及信息（护具和指令）的数字化</li>
<li>采用<code>存储程序</code>工作方式，即事先编制程序，事先存储程序，自动、连续地执行程序</li>
<li>由<code>存储器</code>、<code>运算器</code>、<code>控制器</code>、<code>输入设备</code>、<code>输出设备</code>等五大件组成计算机硬件结构</li>
</ul>
<blockquote>
<p>冯诺依曼机的工作方式称为<code>控制流驱动方式</code>：依照指令的执行序列依次读取指令，依据指令所含的控制信息调用数据，进行运算处理。
这一过程中逐步发出的控制信息成为一种控制信息流，简称<code>控制流</code>，一次处理的数据信息称为一种数据信息流，简称<code>数据流</code></p>
</blockquote>
</li>
</ul>
<h1 id="12信息的数字化表示"><a class="header" href="#12信息的数字化表示">1.2.信息的数字化表示</a></h1>
<ul>
<li>计算机中各种信息用数字代码表示</li>
<li>用数字型电信号表示数字代码</li>
</ul>
<h1 id="2-计算机系统的硬软件组成"><a class="header" href="#2-计算机系统的硬软件组成">2. 计算机系统的硬、软件组成</a></h1>
<h2 id="21-计算机硬件系统"><a class="header" href="#21-计算机硬件系统">2.1 计算机硬件系统</a></h2>
<p>随着计算机硬件系统的发展，当代计算机的组成：</p>
<ul>
<li>中央处理器(CPU)=运算器+控制器
<blockquote>
<p>随着大规模集成电路的发展，可将运算器和控制器集成到一块芯片上，合称CPU</p>
</blockquote>
</li>
<li>存储器
<blockquote>
<p>可分为高速缓存、主存储器、外存储器三部分。中高速缓存常集成在CPU内部，作为CPU的一个部分，也可以在CPU之外再设置一级高速缓存。通常将CPU与主存储器合在一起称为主机，主存储器（简称主存）就是因为位于主机之内而得名，有的书中又称它为内存储器（内存）。</p>
</blockquote>
</li>
<li>输入设备</li>
<li>输出设备</li>
</ul>
<p><img src="assets/computerStruct.png" alt="" /></p>
<p>各组成部件的功能和相应特性</p>
<ol>
<li>
<p>CPU(Central Processing Unit)<br />
CPU即中央处理器，是硬件系统的核心部件，负责读取并执行指令，也就是执行程序。</p>
<ul>
<li>程序计数器PC(Program Counter)：存放当前指令所在存储单元的地址
<blockquote>
<p>PC就像一个指针，指引着程序的执行顺序。</p>
</blockquote>
</li>
<li>算术逻辑部件ALU(Arithmetic Logic Unit)
<blockquote>
<p>CPU内有一个或多个ALU，按照指令要求将有关数据送入ALU，进行指定的算数或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器内</p>
</blockquote>
</li>
<li>控制器
<blockquote>
<p>控制整个系统的工作</p>
<blockquote>
<p>控制器产生的微命令可分为一下两种：</p>
<ul>
<li>组合逻辑控制器：组合逻辑控制器完全靠若干组合逻辑电路（即硬件）产生微命令序列，将指令代码、状态信息、时序信号等输入到这些组合逻辑电路，电路将分时产生相应的微操作命令。</li>
<li>微程序控制器：是将微命令序列以代码形式编制成微程序,以用于执行</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>
<p>主存储器</p>
</li>
</ol>
<p>主存储器存放着需要执行的程序及需要处理的数据，能由CPU直接读出或写入。</p>
<p>主存储器划分为许多单元，通常每个单元存放8位二进制数，称为1字节。每个单元都有一个唯一的编号，称为存储单元地址，简称地址。向主存储器送出某个地址编码，就能根据地址选中对应的一个单元。</p>
<blockquote>
<p>。程序的最终（可执行）形态是指令序列，通常它们按照执行顺序依次存放在连续的存储单元中，通过程序计数器PC提供的指令地址，就可以逐条地读取指令。一条指令按其长度不同可存放在一个或相邻的几个单元中。有的指令需要处理的数据（又称为操作数）存放在主存的一个或相邻的几个单元中，指
令执行时，就提供地址去寻找对应单元，从中读取操作数。</p>
</blockquote>
<p>可见主存储器的一项重要特性是：能按地址（单元编号）存放或读取内容，也就是允许CPU直接编址访问，通常以字节为编址单位。对主存储器来说，寻找存储单元（寻址）的依据是地址码，所存取的内容是指令或数据。</p>
<ol start="3">
<li>外存储器</li>
</ol>
<p>外存储器用来存放那些需要联机存放，但暂不执行的程序和数据，当需要运行它们时再由外存调入主存。</p>
<blockquote>
<p>由于外存储器不由CPU直接编址访问，也就是说不需要按字节地从外存储器读取或写入，因此外存储器中的内容一般都按文件的形式进行组织，一个文件常分解为若干数据块，可以包含许多字节的信息。用户按文件名进行调用，CPU找到该文件在外存中的存放位置，以数据块为单位进行读写</p>
</blockquote>
<ol start="4">
<li>
<p>输入输出设备</p>
</li>
<li>
<p>总线</p>
</li>
</ol>
<p>总线是指一组能为多个部件分时共享的信息传输线。</p>
<blockquote>
<p>某个时刻只能有一个部件或设备向总线发送数据，如果有两个或两个以上的部件同时向总线发送数据，就会产生冲突，使数据混乱，这就是分时共享的含义。</p>
</blockquote>
<ul>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ul>
<ol start="6">
<li>接口</li>
</ol>
<p>用于连接系统总线与I/O设备之间的一些逻辑部件</p>
<hr />
<p>概括的说，计算机硬件系统是由三大子系统组成：</p>
<ul>
<li>CPU</li>
<li>存储系统（包括高速缓存、主存和外存）</li>
<li>输入/输出系统（输入/输出设备和接口）</li>
</ul>
<h2 id="22-计算机软件组成"><a class="header" href="#22-计算机软件组成">2.2 计算机软件组成</a></h2>
<h3 id="系统软件"><a class="header" href="#系统软件">系统软件</a></h3>
<p>系统软件是负责计算机系统的调度管理，提供程序的运行环境和开发环境，向用户提供各种服务的一类软件。</p>
<ul>
<li>操作系统</li>
</ul>
<p>操作系统负责管理和控制计算机系统硬、软件资源及运行的程序，它合理地组织计算机的工作流程，是用户与计算机之间的接口，为用户提供软件的开发环境和运行环境。</p>
<ul>
<li>编译程序和解释程序</li>
</ul>
<p>大多数情况下，用户采用高级程序设计语言编写程序，个别情况采用汇编语言编写程序。言编写出的程序叫做源程序。将源程序输入计算机后，计算机先执行一种语言处理程序，将源程序转换为机器语言代码序列，即机器语言程序，然后由计算机硬件执行这些用机器语言代码表示的指令序列，从而完成用户程序的执行过程。</p>
<pre><code>- 解释方式：边解释边执行
- 编译方式：先将源程序全部翻译成目标程序（目标代码）的机器语言指令序列再执行
</code></pre>
<ul>
<li>各类软件平台</li>
</ul>
<p>将开发及运行过程中所需的各种软件集成为一个综合的软件系统，称为软件平台</p>
<h3 id="应用软件"><a class="header" href="#应用软件">应用软件</a></h3>
<p>应用软件是指用户在各自应用领域中为解决各类问题而编写的程序，也就是直接面向用户需要的一类软件。</p>
<blockquote>
<p>从功能角度看，系统软件是负责系统调度管理，提供开发环境和运行环境，向用户提供各种服务的一类软件；而应用软件是用户在各自应用领域中为解决各类问题所编写的程序。从配置角度看，系统软件是用户购置的系统资源之一；而应用软件是用户自身开发的，直接面向应用需要的程序。</p>
</blockquote>
<h1 id="3-层次结构模型"><a class="header" href="#3-层次结构模型">3. 层次结构模型</a></h1>
<h2 id="31-从计算机系统组成角度划分层次结构"><a class="header" href="#31-从计算机系统组成角度划分层次结构">3.1 从计算机系统组成角度划分层次结构</a></h2>
<p><img src="assets/layer_composition.png" alt="" /></p>
<ul>
<li>微体系结构</li>
</ul>
<p>微体系结构层主要从寄存器级观察CPU的结构，分析CPU执行指令的详细过程。</p>
<pre><code>- 微程序控制器：由微程序产生的控制信号控制的，相应的控制部件称为微程序控制器；
- 组合逻辑控制器：直接由硬件产生的控制信号来控制的，相应的控制部件称为组合逻辑控制器。
</code></pre>
<blockquote>
<p>从硬件组成的角度进一步分析微体系结构层中寄存器、ALU、控制电路等部件的构成就可以看到，几种数字逻辑单元（与、或、非门）组合成了这一层的部件。</p>
</blockquote>
<ul>
<li>指令系统层</li>
</ul>
<p>指令系统（又称指令集）是指一台计算机所能执行的全部指令的集合。其指令是由微体系结构层的微程序解释执行或硬件电路直接执行的。</p>
<ul>
<li>操作系统层</li>
</ul>
<p>操作系统是一个在指令系统层提供的指令和特性之上又增加了新指令（系统调用）和特性的程序。这一层有新的指令集，有不同的存储器结构，有同时运行两个或多个程序的能力，以及其他一些特性。</p>
<ul>
<li>
<p>汇编语言层</p>
</li>
<li>
<p>面向问题（高级）语言层</p>
</li>
</ul>
<h2 id="从语言功能角度划分层次结构"><a class="header" href="#从语言功能角度划分层次结构">从语言功能角度划分层次结构</a></h2>
<p>计算机硬件的物理功能是执行机器语言，称为机器语言物理机，从这一级看到的是一台实际的机器。而用户看到的是能执行某种语言程序的虚拟机，即通过配置某种语言处理程序后所形成的一台计算机。</p>
<p><img src="assets/layer_languageFunction.png" alt="" /></p>
<h2 id="软硬件在逻辑上的等价"><a class="header" href="#软硬件在逻辑上的等价">软、硬件在逻辑上的等价</a></h2>
<p>有许多功能既可以直接由硬件实现，也可以在硬件支持下靠软件实现，对用户来说在功能上是等价的，我们称为软、硬件在功能上的逻辑等价。</p>
<h1 id="计算机的工作过程"><a class="header" href="#计算机的工作过程">计算机的工作过程</a></h1>
<h2 id="处理问题的步骤"><a class="header" href="#处理问题的步骤">处理问题的步骤</a></h2>
<ul>
<li>系统分析</li>
</ul>
<p>如果要构造一个比较复杂的应用系统，首先要进行需求分析；确定该系统应具备哪些功能并据此划分功能模块；了解需存储、处理哪些数据、数据量、调用数据时的流向等。然后根据需求分析结果选择硬件平台和软件平台。如果准备购置的平台不能完全满足需要，可能需要自己设计一些硬件部件和系统软件模块。总体设计中的这些分析工作常称为系统分析。</p>
<ul>
<li>建立数学模型和设计算法</li>
</ul>
<p>应用计算机求解、处理问题的方法，被泛称为算法。</p>
<ul>
<li>编写应用程序</li>
</ul>
<p>在建立数学模型与设计算法之后，关键的技术问题已基本解决，这时就可以选择合适的程序设计语言和开发工具，着手编写应用程序。</p>
<ul>
<li>
<p>编译为目标代码</p>
</li>
<li>
<p>由硬件执行目标程序</p>
</li>
</ul>
<p>通常先将目标程序存储在磁盘中，用户需执行时给出文件名，操作系统按文件名调出目标程序并送入主存，然后将它在主存中的首址送入程序计数器PC之中，从该地址开始依序执行目标程序。</p>
<h2 id="指令执行过程"><a class="header" href="#指令执行过程">指令执行过程</a></h2>
<ul>
<li>取指令与指令分析</li>
</ul>
<p>CPU中有一个程序计数器PC，它存放着当前指令（取指时）所在主存单元的地址码。因此每当读取指令时，就先将PC的内容送入主存储器的地址寄存器中，据此访问主存单元，从中读出指令，送入指令寄存器IR。一条指令代码可能要分别存放在几个地址连续的主存单元中，每读出一个单元的指令代码，PC内容就相应地加1，如果这条指令占n 个主存单元，那么在该指令代码都读取后，PC内容就加了n ，这时PC指示的就是下一条指令在主存的位置。</p>
<p>当指令代码读入到IR之后，相应的逻辑电路（可称为指令译码器）就自动地分析</p>
<ul>
<li>
<p>读取操作数</p>
<ul>
<li>源操作数：从主存中读出的信息具有复制性质，不影响原来的内容。这种操作数称为源操作数。</li>
<li>目的操作数：既是一个操作数的来源地，又是存放运算结果的目的地，所以它提供的操作数叫做目的操作数</li>
</ul>
</li>
<li>
<p>运算</p>
</li>
</ul>
<p>对操作数进行指定的操作</p>
<ul>
<li>后继指令地址</li>
</ul>
<p>在读取指令时PC的内容已自动修改，本例不需要转移指令地址，所以PC修改后的内容就是后继指令地址，即下一条待执行指令所在存储单元的地址。</p>
<h1 id="数字计算机的特点与性能指标"><a class="header" href="#数字计算机的特点与性能指标">数字计算机的特点与性能指标</a></h1>
<h2 id="特点"><a class="header" href="#特点">特点</a></h2>
<ul>
<li>能在程序控制下自动连续的工作：储存程序工作方式</li>
<li>运算速度快：采用高速电子线路组成硬件</li>
<li>运算精度高：采用数字代码表示信息</li>
<li>具有很强的信息存储能力：二进制易保存</li>
<li>通用性强，应用领域广：基于信息表示的数字化</li>
</ul>
<h2 id="性能指标"><a class="header" href="#性能指标">性能指标</a></h2>
<ul>
<li>基本字长：指参与一次运算的二进制数的位数。</li>
<li>数据通路宽度：数据总线一次所能并行传送的二进制数的位数</li>
<li>运算速度
<ul>
<li>CPU时钟频率与主频
计算机的操作需要分步执行，一个时钟周期完成一步操作
<blockquote>
<p>计算机中有一个振荡器，它的输出经整形后形成全机最基本的脉冲序列，其频率称为主频。主频脉冲经分频后形成时钟脉冲序列，一个时钟脉冲前沿到下一个时钟脉冲前沿就形成一个时钟周期。所以主频是时钟频率的整数倍。</p>
</blockquote>
</li>
<li>每秒平均执行指令的条数(/MIPS)</li>
<li>分别标明几种典型四则运算所需的时间</li>
</ul>
</li>
<li>主存储器容量
<blockquote>
<p>两种表示方法</p>
<ul>
<li>字节数</li>
<li>单元数（字数）X 位数</li>
</ul>
</blockquote>
</li>
<li>外存容量</li>
<li>配置的外围设备机器性能</li>
<li>系统软件配置</li>
</ul>
<h1 id="计算机的发展与应用"><a class="header" href="#计算机的发展与应用">计算机的发展与应用</a></h1>
<h2 id="发展历程"><a class="header" href="#发展历程">发展历程</a></h2>
<h2 id="提高性能的若干技术"><a class="header" href="#提高性能的若干技术">提高性能的若干技术</a></h2>
<h2 id="计算机应用举例"><a class="header" href="#计算机应用举例">计算机应用举例</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<p>第二章、计算机中的信息表示</p>
<ul>
<li><a href="2.message_display.html#%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA">数值型数据的表示</a>
<ul>
<li><a href="2.message_display.html#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA">带符号数的表示</a></li>
<li><a href="2.message_display.html#%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0">定点数与浮点数</a></li>
</ul>
</li>
<li><a href="2.message_display.html#%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A1%A8%E7%A4%BA">字符的表示</a>
<ul>
<li><a href="2.message_display.html#ascii%E7%A0%81">ASCII码</a></li>
<li><a href="2.message_display.html#unicode%E7%BC%96%E7%A0%81">Unicode编码</a></li>
<li><a href="2.message_display.html#%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E7%AE%80%E4%BB%8B">汉字编码简介</a></li>
</ul>
</li>
<li><a href="2.message_display.html#%E6%8C%87%E4%BB%A4%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA">指令信息的表示</a>
<ul>
<li><a href="2.message_display.html#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F">指令格式</a></li>
<li><a href="2.message_display.html#%E5%B8%B8%E7%94%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">常用寻址方式</a></li>
<li><a href="2.message_display.html#%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B">指令类型</a></li>
<li><a href="2.message_display.html#pentium2%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F">Pentium2指令格式</a></li>
<li><a href="2.message_display.html#spaerc%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F">SPAERC指令格式</a></li>
</ul>
</li>
</ul>
<p>计算机内部所处理的信息必须是数字化信息，可分为两大类：</p>
<ul>
<li>数据：
<ul>
<li>数值型数据：数值型数据有确定的值并在数轴上有对应的点</li>
<li>非数值型数据：非数值型数据没有确定的值，如字符、图像等。</li>
</ul>
</li>
<li>指令：计算机产生各种控制命令的基本依据。</li>
</ul>
<h1 id="数值型数据的表示"><a class="header" href="#数值型数据的表示">数值型数据的表示</a></h1>
<h2 id="带符号数的表示"><a class="header" href="#带符号数的表示">带符号数的表示</a></h2>
<p><strong>真值与机器数</strong></p>
<p>真值：用‘+/-’号加上绝对值的表示方法<br />
机器数：数字实际存储到机器里的形式，正负号需要被“数字化”</p>
<blockquote>
<p>机器数有原码、补码、反码和移码四种表示方法</p>
</blockquote>
<p><strong>BCD码</strong></p>
<p>用四位二进制来表示一位十进制数，可表示0-16，挑出9位来表示十进制数。</p>
<ul>
<li>8421码</li>
</ul>
<p>两位8421码相加若结果大于9，则再加一个6，进行四位二进制数的进位。</p>
<ul>
<li>余3码：8421码+<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0011</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p><strong>原码</strong></p>
<p>用最高位表示符号，符号位为0表示该数为正，为1表示该数为负；有效数值部分则用二进制绝对值表示。</p>
<blockquote>
<p>小数在个位表示符号位</p>
</blockquote>
<blockquote>
<p>若采用原码作乘除运算，可取其绝对值（即尾数）直接运算，并按同号相乘除取正、异号相乘除取负的原则，单独处理符号位，因此较方便</p>
</blockquote>
<p><strong>补码</strong></p>
<ul>
<li>引入</li>
</ul>
<p>56-24=32，56+76=132=32，该加法中，100超出了表示范围，所以这两的运算结果相同，-24的补码（相对模100）是76。在有模运算中，一个负数可以用其补码代替，得到的是相同的结果</p>
<blockquote>
<p>可以把相减变成相加</p>
</blockquote>
<ul>
<li>定义</li>
</ul>
<p>计算机中数的表示及运算受字长限制，其运算都是有模运算。模在机器中是表示不出来的，若运算结果超出能表示的数值范围，则会自动舍去溢出量，只保留小于模的部分。</p>
<p><img src="assets/buma.png" alt="" /></p>
<p><strong>反码</strong></p>
<p>正数不变，负数符号位不变，其余位取反</p>
<p><strong>移码</strong></p>
<p>补码的基础上将符号位取反。只能用于表示整数</p>
<blockquote>
<p>移码相当于把真值映射到正数域(+<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)。若将移码视作无符号数，则移码的大小就反映了真值的大小，这将便于两个浮点数的阶码比较。</p>
</blockquote>
<p><strong>比较与总结</strong></p>
<p><img src="assets/all.png" alt="" /></p>
<hr />
<p><img src="./assets/compare.png" alt="" /></p>
<hr />
<p>原码和补码的关系：将负数用补码表示，实际上是实现了一种从<code>[-128,127]</code>到<code>[0,255]</code>的映射</p>
<p><img src="assets/project.png" alt="" /></p>
<blockquote>
<p>为什么10000000表示-128?
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">128</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">127</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">10000001</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">11111111</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">11111111</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">10000001</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">10000000</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<h2 id="定点数与浮点数"><a class="header" href="#定点数与浮点数">定点数与浮点数</a></h2>
<p><strong>定点数</strong></p>
<p>小数点固定的机器数称为定点数，计算机中只采用纯小数或纯整数形式</p>
<blockquote>
<p>小数点只是一个约定，机器硬件中并不存在</p>
</blockquote>
<ul>
<li>定点整数</li>
</ul>
<p>定点整数的小数点位置固定在最低位之后</p>
<ul>
<li>定点小数</li>
</ul>
<p>定点小数的小数点位置固定在符号位（最高位）之后</p>
<blockquote>
<p>对于绝对值小于定点小数分辨率<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>的数，当机器数0处理</p>
</blockquote>
<p><em>溢出</em></p>
<p>参加运算的数以及运算的结果必须在该定点数所能表示的数值范围之内。</p>
<ul>
<li>负溢出：机器数小于定点数的最小值（即绝对值最大负数）</li>
<li>正溢出：当超出最大值时，称为“正溢出”；</li>
</ul>
<p>当机器中发生溢出时，将迫使机器转入溢出处理程序或暂停，并将CPU中的状态寄存器的溢出标志位置位。</p>
<blockquote>
<p>定点数的小数点位置约定在固定位置上，因此不需设置专门的硬设备来表示它，显然小数点在机器中并不实际存在。对计算机来说，处理定点整数与处理定点小数在硬件上并无区别，至于选择哪一种定点数格式是在程序中约定的。</p>
</blockquote>
<p><em>比较</em>
<img src="assets/xiaoshu.png" alt="" /></p>
<hr />
<p><strong>浮点数</strong></p>
<p>计算机中也引入了类似于 <em>科学计数法</em> 的方法来表示实数，称为浮点数表示法，即小数点的位置可以根据需要而浮动。</p>
<p>浮点数的代码由两部分组成：阶码E和尾数M。浮点数的真值表示为：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></span></p>
<ul>
<li>R是阶码的底，机器中一般规定为2，8或16（进制），与尾数的基数（进制）相同</li>
<li>E是阶码，即指数，为带符号整数，常用移码或补码表示</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是阶符，表示指数的符号</li>
<li>M是尾数，通常是纯小数，常用原码或补码表示</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是尾数的符号位，安排在最高位，也是整个浮点数的符号位
<img src="assets/float.png" alt="" /></li>
</ul>
<blockquote>
<p>非IEEE浮点数格式化形式：规格化尾数应满足1/2&lt;=|M|&lt;1</p>
</blockquote>
<blockquote>
<p>当阶码小于机器能表示的最小阶码（即
该浮点数的值小于最小绝对值）时，称为下溢，此时一般当作机器零
处理，机器可继续运行。当阶码大于机器所能表示的最大阶码时，称
为上溢，即溢出，这时机器必须转入溢出出错中断处理。</p>
</blockquote>
<p><img src="assets/IEEE.png" alt="" /></p>
<blockquote>
<p>IEEE标准：
尾数用原码表示，隐含最高位1，实际尾数为尾数+1(即1.M)
阶码用移码表示，实际阶码需要减去偏移量<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mord mtight">∣</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
<blockquote>
<p>其中|E|为阶码的长度</p>
</blockquote>
</blockquote>
<h1 id="字符的表示"><a class="header" href="#字符的表示">字符的表示</a></h1>
<h2 id="ascii码"><a class="header" href="#ascii码">ASCII码</a></h2>
<p>一个ASCII码占一个字节，只使用底七位，最高位置0，可表示128个字符</p>
<h2 id="unicode编码"><a class="header" href="#unicode编码">Unicode编码</a></h2>
<p>Unicode最基本的思路是将每个字符和符号赋予一个永久、唯一的16位值，即码点</p>
<h2 id="汉字编码简介"><a class="header" href="#汉字编码简介">汉字编码简介</a></h2>
<ul>
<li>输入码</li>
</ul>
<p>拼音码，字形码等，所产生的输入码需要借助输入码与内部码的对照表（称为输入字典）转换成便于加工处理的内码。</p>
<ul>
<li>汉子交换码</li>
</ul>
<p>纳入整理的汉字排成一个94×94的行列矩阵，矩阵的行称为区，列称为位。用双字节编码表示。前一个字节表示区，后一个字节表示位</p>
<ul>
<li>内部码</li>
</ul>
<p>汉字内部码（简称内码）是计算机内部供存储、处理、传输用的代码。</p>
<p>todo:P107</p>
<h1 id="指令信息的表示"><a class="header" href="#指令信息的表示">指令信息的表示</a></h1>
<p>一台计算机能够直接识别并执行的程序只能是机器语言程序。</p>
<blockquote>
<p>因此，任何问题无论使用哪一种计算机语言（汇编语言或某种高级语言）来编程实现，都必须通过翻译程序转换成对应的机器语言程序后才能执行。</p>
</blockquote>
<p>机器语言程序是由机器指令序列组成的，它们是产生各种控制信息的基础。</p>
<blockquote>
<p>一条机器指令是一组有意义的二进制代码，它指示机器硬件应完成哪种基本操作。</p>
</blockquote>
<p>一台计算机的所有指令的集合构成该机的指令系统。</p>
<blockquote>
<p>指令系统既是为软件设计者提供的最低层次的程序设计语言，也是硬件设计者的最基本的设计依据。因此，指令系统是软件和硬件的接口</p>
</blockquote>
<h2 id="指令格式"><a class="header" href="#指令格式">指令格式</a></h2>
<ol>
<li>指令中的基本信息</li>
</ol>
<p>计算机是通过执行指令来处理各种数据的。为了指出所执行的操作、操作数的来源和操作结果的去向，以及下一条指令从哪里取<br />
一条指令一般应包含以下信息：</p>
<ul>
<li>操作码：表示该指令所要完成的操作</li>
<li>操作数的地址：给出操作数存放处的地址</li>
</ul>
<blockquote>
<p>如主存单元地址或寄存器地址。CPU通过该地址可以获得所需的操作数。</p>
</blockquote>
<ul>
<li>操作结果的地址：对操作数进行处理所产生的结果存放在该地址中，以便再次使用。</li>
<li>下一条指令地址</li>
</ul>
<blockquote>
<p>由于存储在主存储器中的程序（机器指令序列）是按指令执行顺序连续存放的，并且在大多数情况下程序是顺序执行的，因此可以设计一个程序计数器PC专门存放指令地址，每取出一条指令后，PC自动增值指出下一条指令地址，这样就不需在指令中直接给出下一条指令的地址。当需要改变程序执行顺序时，可由转移类指令实现。</p>
</blockquote>
<p>从上述分析可知，一条指令实际上包括两种信息，即操作码和地址码，因此指令的基本格式为：</p>
<p><img src="assets/instr.png" alt="" /></p>
<ul>
<li>操作码(Operation Code): 具体说明该指令操作的性质及功能。</li>
<li>地址码(Address Code): 描述该指令的操作对象，由它给出操作地址或直接给出操作数，并给出操作结果的存放地址。</li>
</ul>
<ol start="2">
<li>地址码结构</li>
</ol>
<p><em><strong>三地址码</strong></em></p>
<p>OP A1 A2 A3</p>
<ul>
<li>
<p>功能：(A1)OP(A2)-&gt;A3</p>
</li>
<li>
<p>说明：</p>
<ul>
<li>OP表示操作码</li>
<li>A1: 表示操作数1的地址</li>
<li>A2: 表示操作数2的地址</li>
<li>A3: 结果存放地址</li>
</ul>
</li>
</ul>
<blockquote>
<p>A1 、A2 和A3 可以是主存单元地址或寄存器地址。</p>
</blockquote>
<p><em><strong>二地址码</strong></em></p>
<p>OP A1 A2</p>
<ul>
<li>功能：(A1)OP(A2)-&gt;A1</li>
<li>说明：
<ul>
<li>A2: 提供的操作数，在运算后仍保存在原处，称它为源操作数，A2 称为源地址</li>
<li>A1: 提供的操作数，在运算后不再保留，该地址改为存放运算结果</li>
</ul>
<blockquote>
<p>因为A1 最终是存放结果的目的地，所以一开始由A1 提供的操作数称为目的操作数</p>
</blockquote>
</li>
</ul>
<p><em><strong>一地址码</strong></em></p>
<p>只有目的操作数的单操作数指令</p>
<p>OP A</p>
<ul>
<li>功能：(OP)A-&gt;A</li>
<li>说明：指令中只给出一个目的地址A，A既是操作数的地址，又是操作结果的存放地址。</li>
</ul>
<p>隐含约定目的地址的双操作数指令</p>
<p>OP A</p>
<ul>
<li>功能：(AC)OP(A)-&gt;AC</li>
<li>说明：
<ul>
<li>源操作数按指令给出的源地址A读取，</li>
<li>另一个操作数（目的操作数）隐含在CPU的累加器AC中，运算结果也将存放在AC中。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在某些微机中，双操作数指令也可采用一地址指令格式。</p>
</blockquote>
<p><em><strong>零地址码</strong></em></p>
<p>不需要操作数</p>
<p>OP</p>
<ul>
<li>说明：例如块操作指令、停机指令</li>
</ul>
<p>所需的操作数是隐含的</p>
<p>OP</p>
<ul>
<li>说明：如计算机中对堆栈操作的运算指令，所需的操作数事先约定在堆栈中，由堆栈指针SP隐含指出，操作结果仍送回堆栈中。</li>
</ul>
<blockquote>
<p>指令和操作数同样是以二进制代码形式存储的，从表面上看二者并无区别。但是，指令地址是由程序计数器PC指定的。而操作数地址则是由指令中的地址码规定的。因此二者绝不可能混淆。</p>
</blockquote>
<ol start="3">
<li>操作码结构</li>
</ol>
<p>指令中的操作码用来指示机器应执行什么性质的操作，每一条指令都有一个含义确定的操作码，不同指令的操作码用不同的二进制编码表示。</p>
<ul>
<li>固定长度地址码</li>
</ul>
<p>操作码的长度固定，且集中放在指令字的一个字段中，指令的其余部分全部用于地址码。</p>
<blockquote>
<p>操作码固定长度有利于简化硬件设计和缩短指令译码时间。</p>
</blockquote>
<ul>
<li>可变长度地址码</li>
</ul>
<p>背景：如果指令长度一定，则地址码与操作码的长度是相互制约的
解决办法：可采用扩展操作码的办法，即操作码和地址码位数不固定，操作码位数允许有几种不同的选择，对地址数少的指令允许操作码长些，对地址数多的指令则操作码就短些。</p>
<ul>
<li>复合型地址码</li>
</ul>
<p>将操作码分为几个部分，它们的组合使操作含义更丰富。</p>
<ol start="4">
<li>指令长度</li>
</ol>
<ul>
<li>变字长地址</li>
</ul>
<p>不同的指令可以有不同的字长。</p>
<blockquote>
<p>但因为主存通常按字节编址，所以指令字长多为字节的整数倍</p>
</blockquote>
<p>功能实现：将操作码放在指令字的第一字节，当CPU读出操作码后可立即判定，这是一条单操作数指令，还是一条双操作数指令，或者是零地址指令，从而知道后面还应读取几字节的指令代码。</p>
<ul>
<li>固定字长地址</li>
</ul>
<p>指令长度固定，方便机器预取后续指令，有利于指令流水线执行。</p>
<blockquote>
<p>现在RISC的微处理器通常采用固定字长指令</p>
</blockquote>
<h2 id="常用寻址方式"><a class="header" href="#常用寻址方式">常用寻址方式</a></h2>
<p>一条指令包括操作码和地址码，指令的功能就是根据操作码对地，址码提供的操作数完成某种操作。指令中以什么方式提供操作数或操作数地址，称为寻址方式。</p>
<p>指令所需要的操作数可能存放在以下几种地方：</p>
<ul>
<li>就包含在该指令之中。</li>
<li>存放在CPU的某个寄存器中。</li>
<li>存放在主存单元中。
<ul>
<li>只需对某个操作数进行处理</li>
<li>需要对一个连续的数组或表进行处理。</li>
</ul>
</li>
<li>存放在堆栈区中。</li>
<li>存放在某个I/O接口的寄存器中。</li>
</ul>
<p>两种地址：
形式地址：指令中的地址码不能直接用来访问主存
有效地址：对形式地址进行一定的计算而得到的存放操作数的主存单元地址</p>
<p>寻址方式的类型</p>
<ul>
<li>立即寻址类: 在读取指令时也立即读出操作数。</li>
</ul>
<blockquote>
<p>通常用于为程序提供常数或某种初始值，提供的是不可变的数据</p>
</blockquote>
<ul>
<li>直接寻址类: 直接给出主存的有效地址或寄存器号，以读取操作数。
<ul>
<li>堆栈寻址: 操作数存放在堆栈中，指令隐含约定由堆栈指针SP寄存器提供堆栈栈顶单元地址，进行读出或写入。</li>
</ul>
</li>
</ul>
<blockquote>
<p>有效地址是指令的一部分，不能随程序需要动态改变，因而该指令只能访问某个固定的主存单元。</p>
</blockquote>
<ul>
<li>间接寻址类: 先从某寄存器或主存单元中读取有效地址，再按这一地址访问主存以读取操作数。</li>
</ul>
<blockquote>
<p>即指向指针的指针
可将间址单元当成一个读取操作数的地址指针，它指示操作数在主存中的位置，只要修改指针（即间址单元的内容），则同一条指令就可以用来在不同时间访问不同的存储单元。</p>
</blockquote>
<ul>
<li>变址类: 指令给出的是形式地址，经过某种计算才获得有效地址，据此访问主存，读取操作数。
<ul>
<li>变址寻址: 指令的地址部分给出一个形式地址（位移量），并指定一个寄存器作为变址寄存器(Rx)；变址寄存器内容（称为变址量）与形式地址相加，得到操作数有效地址；</li>
<li>相对寻址: 以当前指令位置为基准，相对它进行位移（往前或往后）定位</li>
</ul>
<blockquote>
<p>用程序计数器PC的内容作为基准地址，指令中给出的形式地址作为位移量（可正可负），二者相加后形成操作数的有效地址。</p>
</blockquote>
</li>
</ul>
<h2 id="指令类型"><a class="header" href="#指令类型">指令类型</a></h2>
<p><img src="assets/typeInstru.png" alt="" /></p>
<blockquote>
<p>一般所有的计算机都提供表2-4中的前三类指令。指令系统对后四类指令的支持取决于具体机器</p>
</blockquote>
<ol>
<li>算数和逻辑运算类指令</li>
</ol>
<ul>
<li>运算指令: 设置加、减、比较、移位等最基本的定点。</li>
</ul>
<blockquote>
<p>性能稍强一点的机器，还设置定点乘、除运算指令。</p>
</blockquote>
<ul>
<li>逻辑运算: 逻辑与、逻辑或、逻辑非（求反）和异或4种。</li>
</ul>
<blockquote>
<p>有些机器设置有专门的位操作指令，如位测试、位清除、位设置等；而有些机器则通过逻辑运算指令实现位操作。</p>
</blockquote>
<ul>
<li>移位操作: 算术移位、逻辑移位和循环移位</li>
</ul>
<blockquote>
<p>对于未设置某种运算指令的机器，如果要实现这种运算，则可以通过程序方法来实现。也可以增设扩展运算部件。</p>
</blockquote>
<ol start="2">
<li>数据传送类指令</li>
</ol>
<p>这类指令将数据从一个地方传送到另一个地方，可用来实现寄存器与寄存器、寄存器与主存单元，以及主存单元与主存单元之间的数据传送</p>
<blockquote>
<p>而且纯数据传送具有“复制”性质，即数据从源地址传送到目的地址时，源地址中的数据保持不变。</p>
</blockquote>
<p>输入/输出（I/O）类指令完成主机与外围设备之间的信息传送有三种设置方式</p>
<ul>
<li>专用的I/O指令</li>
</ul>
<p>OP R A<br />
OP是操作码，表示它是I/O指令；<br />
R是CPU中寄存器的地址，指定与外设交换数据的寄存器；<br />
A是I/O端口的地址，其长度一般为8～16位，可以表示256～64 K个地址。</p>
<ul>
<li>用通用的数据传送指令实现I/O操作</li>
</ul>
<p>在I/O接口的端口与主存单元<em><strong>统一编址</strong></em>的机器中，因为将I/O端口与存储器单元同等对待，所以任何访问主存单元的指令均可访问I/O接口中的端口，这样就可以用传送类指令实现主机与I/O接口之间的信息传送</p>
<ul>
<li>通过I/O处理执行I/O操作</li>
</ul>
<ol start="3">
<li>程序控制类指令</li>
</ol>
<p>这类指令可以控制程序执行的顺序和选择程序的执行方向</p>
<ul>
<li>
<p>转移指令</p>
<ul>
<li>无条件转移指令: 改变指令的常规执行顺序，不受任何条件约束，直接把程序转移到该指令指向的任何地址（指令地址）开始执行。</li>
</ul>
<blockquote>
<p>这种操作使程序计数器PC的内容改变为转移地址。</p>
</blockquote>
<ul>
<li>条件转移指令; 需先测试某些条件，仅当条件满足时，才执行转移，否则只相当于一条空操作指令，不改变程序执行顺序。</li>
</ul>
<blockquote>
<p>决定转移的条件一般是指上次运算结果的某些待征。<br />
在CPU的状态寄存器中，有一组用来保存最近执行的算术逻辑运算指令、移位指令等的结果标志，它们主要包括</p>
<ul>
<li>进位标志C</li>
<li>结果为零标志Z</li>
<li>结果为负标志N</li>
<li>溢出标志V</li>
<li>奇偶标志P。</li>
</ul>
</blockquote>
</li>
<li>
<p>循环控制指令: 有了条件转移指令就可以实现循环程序设计。但有的机器为了提高指令系统的有效性，还专门设置了循环控制指令，它包括对循环控制变量的操作和脱离循环条件的控制，是一种具有复合功能的指令。</p>
</li>
<li>
<p>子程序调用和返回指令</p>
<ul>
<li>执行子程序调用指令时，首先将下一条指令地址（即断点）压入堆栈保存，然后转入所调用的子程序执行。</li>
<li>子程序执行完毕，由返回指令把调用子程序时压入的返回地址从堆栈中弹出，以返回调用程序。</li>
</ul>
</li>
<li>
<p>程序自中断指令</p>
<ul>
<li>按中断方式将处理机断点与现场保存在堆栈中（这点与一般的转子程序不同），然后转向对应的中断处理子程序入口开始执行</li>
<li>执行完毕后，通过中断返回指令返回到原程序断点继续执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于自中断指令是由软件驱动的，所以又称为软中断。</p>
</blockquote>
<ol start="4">
<li>系统类指令（特权指令）</li>
</ol>
<p>特权指令是指具有特殊权限的指令，它们只能用于操作系统或其他系统软件，一般不直接提供给用户使用。</p>
<ul>
<li>通常在单用户、单任务的计算机系统中不需要设置特权指令</li>
<li>在多用户、多任务计算机系统中，则必须设置特权指令，它主要用于系统资源的分配和管理。如检测用户的访问权限、修改虚拟存储器管理的段表、页表等。</li>
</ul>
<p>在有些多用户计算机系统中，为了统一管理各种外设，输入/输出指令也作为特权指令使用，故用户不能直接访问它们。需输入/输出时，可通过系统调用来实现。</p>
<h2 id="pentium2指令格式"><a class="header" href="#pentium2指令格式">Pentium2指令格式</a></h2>
<h2 id="spaerc指令格式"><a class="header" href="#spaerc指令格式">SPAERC指令格式</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<!-- ~/study_md/computer_composition/basic/4.CPU.md -->
<p>第三章 微体系结构层--CPU组成</p>
<ul>
<li><a href="3.CPU.html#1-cpu%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E5%8A%9F%E8%83%BD">1. CPU的组成和功能</a>
<ul>
<li><a href="3.CPU.html#11-cpu%E7%9A%84%E7%BB%84%E6%88%90">1.1 CPU的组成</a>
<ul>
<li><a href="3.CPU.html#111-alu%E9%83%A8%E4%BB%B6%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8">1.1.1 ALU部件与寄存器</a></li>
<li><a href="3.CPU.html#112-%E6%80%BB%E7%BA%BF">1.1.2 总线</a></li>
<li><a href="3.CPU.html#113-cpu%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF">1.1.3 CPU内部数据通路</a></li>
</ul>
</li>
<li><a href="3.CPU.html#12-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">1.2 指令执行过程</a></li>
<li><a href="3.CPU.html#13-%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">1.3 时序控制方式</a>
<ul>
<li><a href="3.CPU.html#131-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">1.3.1 同步控制方式</a></li>
<li><a href="3.CPU.html#132-%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%A4%9A%E7%BA%A7%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F">1.3.2 同步时序控制的多级时序系统</a></li>
</ul>
</li>
<li><a href="3.CPU.html#14-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF">1.4 指令流水线</a></li>
</ul>
</li>
<li><a href="3.CPU.html#2-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83alu%E5%92%8C%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95">2. 算数逻辑单元ALU和运算方法</a>
<ul>
<li><a href="3.CPU.html#21-%E7%A7%BB%E4%BD%8D">2.1 移位</a></li>
<li><a href="3.CPU.html#22-%E5%AE%9A%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97">2.2 定点数加减运算</a>
<ul>
<li><a href="3.CPU.html#221-%E5%8E%9F%E7%A0%81%E5%8A%A0%E5%87%8F%E6%B3%95">2.2.1 原码加减法</a></li>
<li><a href="3.CPU.html#222-%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E6%B3%95">2.2.2 补码加减法</a></li>
<li><a href="3.CPU.html#223-%E6%BA%A2%E5%87%BA">2.2.3 溢出</a></li>
</ul>
</li>
<li><a href="3.CPU.html#23-%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97">2.3 定点数乘除运算</a>
<ul>
<li><a href="3.CPU.html#231-%E4%B9%98%E6%B3%95">2.3.1 乘法</a></li>
<li><a href="3.CPU.html#232-%E9%99%A4%E6%B3%95">2.3.2 除法</a></li>
</ul>
</li>
<li><a href="3.CPU.html#24-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97">2.4 浮点数运算</a>
<ul>
<li><a href="3.CPU.html#241-%E5%8A%A0%E5%87%8F%E6%B3%95">2.4.1 加减法</a></li>
<li><a href="3.CPU.html#242-%E4%B9%98%E9%99%A4%E6%B3%95">2.4.2 乘除法</a></li>
</ul>
</li>
<li><a href="3.CPU.html#25-alu">2.5 ALU</a></li>
</ul>
</li>
<li><a href="3.CPU.html#3-cpu%E6%A8%A1%E5%9E%8B%E6%9C%BA%E7%9A%84%E7%BB%84%E6%88%90%E5%8F%8A%E5%85%B6%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF">3. CPU模型机的组成及其数据通路</a>
<ul>
<li><a href="3.CPU.html#31-%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">3.1 基本组成</a>
<ul>
<li><a href="3.CPU.html#311-%E5%AF%84%E5%AD%98%E5%99%A8">3.1.1 寄存器</a></li>
<li><a href="3.CPU.html#312-%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6">3.1.2 运算部件</a></li>
<li><a href="3.CPU.html#313-%E6%80%BB%E7%BA%BF%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%BB%93%E6%9E%84">3.1.3 总线与数据通路结构</a></li>
<li><a href="3.CPU.html#314-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8F%8A%E5%BE%AE%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F">3.1.4 控制器及微命令的基本形式</a></li>
</ul>
</li>
<li><a href="3.CPU.html#32-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81">3.2 数据传送</a></li>
</ul>
</li>
<li><a href="3.CPU.html#4%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8E%9F%E7%90%86">4、组合逻辑控制器原理</a>
<ul>
<li><a href="3.CPU.html#41-%E6%A8%A1%E5%9E%8B%E6%9C%BA%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F">4.1 模型机的指令系统</a>
<ul>
<li><a href="3.CPU.html#411-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F">4.1.1 指令格式</a></li>
<li><a href="3.CPU.html#412-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">4.1.2 寻址方式</a></li>
<li><a href="3.CPU.html#413-%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B">4.1.3 操作类型</a></li>
</ul>
</li>
<li><a href="3.CPU.html#42-%E6%A8%A1%E5%9E%8B%E6%9C%BA%E7%9A%84%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F">4.2 模型机的时序系统</a>
<ul>
<li><a href="3.CPU.html#421-%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%9C%9F%E5%88%92%E5%88%86">4.2.1 工作周期划分</a></li>
<li><a href="3.CPU.html#422-%E8%8A%82%E6%8B%8D%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F">4.2.2 节拍（时钟周期）</a></li>
<li><a href="3.CPU.html#423-%E5%B7%A5%E4%BD%9C%E8%84%89%E5%86%B2">4.2.3 工作脉冲</a></li>
</ul>
</li>
<li><a href="3.CPU.html#43-%E6%8C%87%E4%BB%A4%E6%B5%81%E7%A8%8B">4.3 指令流程</a>
<ul>
<li><a href="3.CPU.html#431-%E5%8F%96%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9Fft">4.3.1 取指令周期FT</a>
<ul>
<li><a href="3.CPU.html#%E8%BF%9B%E5%85%A5ft%E7%9A%84%E6%9D%A1%E4%BB%B6">进入FT的条件</a></li>
<li><a href="3.CPU.html#%E5%8F%96%E6%8C%87%E6%B5%81%E7%A8%8B">取指流程</a></li>
<li><a href="3.CPU.html#%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4%E8%A1%A8">微操作时间表</a></li>
</ul>
</li>
<li><a href="3.CPU.html#432-move%E6%8C%87%E4%BB%A4">4.3.2 MOVE指令</a></li>
<li><a href="3.CPU.html#433-%E5%8F%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E4%BB%A4">4.3.3 双操作数指令</a></li>
<li><a href="3.CPU.html#434-%E5%8D%95%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E4%BB%A4">4.3.4 单操作数指令</a></li>
<li><a href="3.CPU.html#435-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4jmp%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4rst">4.3.5 转移指令JMP/返回指令RST</a></li>
<li><a href="3.CPU.html#434-%E8%BD%AC%E5%AD%90%E6%8C%87%E4%BB%A4jsr">4.3.4 转子指令JSR</a></li>
<li><a href="3.CPU.html#435-%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E5%91%A8%E6%9C%9Fit">4.3.5 中断响应周期IT</a></li>
<li><a href="3.CPU.html#436-dma%E5%91%A8%E6%9C%9F">4.3.6 DMA周期</a></li>
<li><a href="3.CPU.html#437-%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C">4.3.7 键盘操作</a></li>
</ul>
</li>
<li><a href="3.CPU.html#44-%E5%BE%AE%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BB%BC%E5%90%88%E4%B8%8E%E4%BA%A7%E7%94%9F">4.4 微命令的综合与产生</a></li>
<li><a href="3.CPU.html#45-%E5%B0%8F%E7%BB%93">4.5 小结</a></li>
</ul>
</li>
<li><a href="3.CPU.html#5-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8E%9F%E7%90%86">5. 微程序控制器原理</a>
<ul>
<li><a href="3.CPU.html#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%A6%82%E5%BF%B5">微程序控制概念</a>
<ul>
<li><a href="3.CPU.html#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9C%AF%E8%AF%AD">基本概念与术语</a></li>
<li><a href="3.CPU.html#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">微程序控制方式的基本思想</a></li>
<li><a href="3.CPU.html#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0">微程序执行过程的描述</a></li>
</ul>
</li>
<li><a href="3.CPU.html#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F">微指令编码方式</a></li>
<li><a href="3.CPU.html#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">微程序的顺序控制方式</a>
<ul>
<li><a href="3.CPU.html#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90">微程序入口地址的形成</a></li>
<li><a href="3.CPU.html#%E5%90%8E%E7%BB%A7%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90">后继地址的形成</a></li>
</ul>
</li>
<li><a href="3.CPU.html#%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F">微指令格式</a>
<ul>
<li><a href="3.CPU.html#%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4">水平型微指令</a></li>
<li><a href="3.CPU.html#%E5%9E%82%E7%9B%B4%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4">垂直型微指令</a></li>
</ul>
</li>
<li><a href="3.CPU.html#5-%E6%A8%A1%E5%9E%8B%E6%9C%BA%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F">5. 模型机微程序指令格式</a></li>
</ul>
</li>
<li><a href="3.CPU.html#%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E8%AE%A1%E7%AE%97%E6%9C%BArisc">精简指令计算机(RISC)</a></li>
</ul>
<p>从计算机系统的功能组成角度看，中央处理器CPU（Central Process Unit）是计算机系统的核心部件，它主要由寄存器、算术逻 辑部件ALU、控制器及互连它们的机构组成。</p>
<p>CPU执行一条指令是由控制器产生的一组微命令（即控制信号：控制门电路的开关）序列实现的。按微命令的形成方式不同，控制器有两种组成方式</p>
<ul>
<li>组合逻辑控制方式</li>
<li>微程序控制方式</li>
</ul>
<p>在微体系结构层，我们看到的是一些寄存器和算术逻辑部件ALU 相连构成的数据通路，即中央处理器CPU的数据通路。<br />
数据通路的基本功能是传送和运算数据，如选择一个或两个寄存器的内容作为ALU的操 作数，将它们进行运算（如相加），然后将结果存回某个寄存器中。<br />
在一些机器上，这些功能</p>
<ul>
<li>是由微程序产生的控制信号控制的，相应的控制部件称为微程序控制器；</li>
<li>而有些机器是直接由硬件产生的控制信号来控制的，相应的控制部件称为组合逻辑控制器。</li>
</ul>
<h1 id="1-cpu的组成和功能"><a class="header" href="#1-cpu的组成和功能">1. CPU的组成和功能</a></h1>
<p>中央处理器CPU的主要功能是</p>
<ul>
<li>从主存储器中取出指令</li>
<li>解释指令和执行指令</li>
</ul>
<blockquote>
<p>即按指令控制计算机各部件操作，并对数据进行处理。</p>
</blockquote>
<h2 id="11-cpu的组成"><a class="header" href="#11-cpu的组成">1.1 CPU的组成</a></h2>
<p><img src="assets/cpucom.png" alt="" /></p>
<ul>
<li>控制器：产生一系列控制信号，1️⃣控制计算机中各部件完成操作</li>
<li>算数逻辑单元ALU：实现所指定的各种算数运算和逻辑运算</li>
<li>各种寄存器：存放指令、指令地址、操作数及运算结果</li>
<li>CPU内部总线：连接CPU内部各部件，为信息传送提供通路</li>
</ul>
<h3 id="111-alu部件与寄存器"><a class="header" href="#111-alu部件与寄存器">1.1.1 ALU部件与寄存器</a></h3>
<ol>
<li>ALU部件</li>
</ol>
<p><img src="assets/alucom.png" alt="" /></p>
<p>ALU的功能是实现数据的算术与逻辑运算。常用图3-2中所示的框图表示ALU。可以看出，</p>
<ul>
<li>ALU的输入有两个端口
<ul>
<li>分别接收参加运算的两个操作数</li>
<li>通常它们来自CPU的通用寄存器或ALU总线。</li>
</ul>
</li>
<li>ALU的输出取决于对其功能的控制
<ul>
<li>当控制功能选择加、减、与、或等运算功能之一时</li>
<li>其输出结果将为对应的和、差、与值、或 值等。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>寄存器</li>
</ol>
<p>CPU中的寄存器包括</p>
<ul>
<li>
<p>存放控制信息的寄存器</p>
<ul>
<li>
<p>指令寄存器IR(Instruction Register)</p>
<ul>
<li>存放当前正在执行的一条指令。</li>
<li>执行一条指令时，通常是先将其从主存储器(Memory)读出到主存数据寄存器MDR（Memory Data Register）中，然后再送往指令寄存器IR中。</li>
</ul>
</li>
<li>
<p>程序计数器PC(Program Counter)</p>
<ul>
<li>存放当前或下一条指令在主存中的地址</li>
</ul>
<blockquote>
<p>因此又称为指令计数器或指令指针IP（Instruction Pointer）。</p>
</blockquote>
</li>
<li>
<p>状态字寄存器</p>
<ul>
<li>存放当前程序的运行状态和工作方式，其内容称为程序状态字PSW（Program State Word），PSW是参与控制程序执行的重要依据。</li>
<li>PSW中一部分内容是记录上一条指令执行后的结果标志
<ul>
<li>进位标志C、溢出标志V、结果为零标志Z、结果正负标志N、奇偶标志P等。</li>
</ul>
<blockquote>
<p>每当一条指令执行完，CPU将根据运行结果自动修改这些标志。</p>
</blockquote>
</li>
<li>PSW中另一部分内容由编程设定（也称为控制标志）
<ul>
<li>跟踪标志T，用以编程设定断点；中断允许标志I，指示CPU是否允许响应 外部中断请求。</li>
<li>有的机器还设有工作方式字段，若设定为用户方式， 则禁止用户使用某些特权指令。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>及存放所处理数据的寄存器</p>
<ul>
<li>
<p>通用寄存器</p>
<ul>
<li>每个寄存器都可以提供多种用途</li>
<li>每个通用寄存器都有唯一的编号，称为寄存器地址。</li>
<li>通用寄存器可用D触发器构成。</li>
</ul>
</li>
<li>
<p>暂存器</p>
<ul>
<li>暂存从主存储器读出的数据</li>
</ul>
<blockquote>
<p>这些数据不能存放在通用寄存器中，否则会破坏其原有内容。</p>
</blockquote>
<ul>
<li>暂存器还可用于暂存来自通用寄存器组的数据。</li>
<li>暂存器没有寄存器号，因此不能直接编程访问它们。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="112-总线"><a class="header" href="#112-总线">1.1.2 总线</a></h3>
<p>总线是一组能为多个部件分时共享的公共信息传送线路，它分时接收各部件送来的信息，并发送信息到有关部件。</p>
<blockquote>
<p>会出现多个部件争用总线</p>
</blockquote>
<p>CPU内部总线用来连接CPU内的各寄存器与ALU，主要用于传送数据信息。</p>
<p>系统总线用来连接CPU、主存储器与I/O接口，它通常包括三组：</p>
<ul>
<li>数据总线: 主要传送各大部件间的数据信息，如指令代码、操作数、命令字或状态字等。</li>
<li>地址总线: 传送主存单元地址码或I/O端口地址。</li>
<li>控制总线: 传送控制、状态信息，其中有CPU发出的控制信号，也有送入CPU的状态信号。如CPU输出的对主存的读/写控制信号、外设输入到CPU的中断请求信号。</li>
</ul>
<h3 id="113-cpu内部数据通路"><a class="header" href="#113-cpu内部数据通路">1.1.3 CPU内部数据通路</a></h3>
<ol>
<li>单总线数据通路结构</li>
</ol>
<p><img src="assets/cpuoneline.png" alt="" /></p>
<ul>
<li>CPU数据通路结构只采用一组内总线，它是双向总线。</li>
<li>通用寄存器组、其他寄存器和ALU均连在这组内总线上。</li>
<li>CPU外部的系统总线通过主存数据寄存器MDR和主存地址寄存器MAR（Memory Address Register）与CPU内总线相连。</li>
<li>CPU内各寄存器间的数 据传送必须通过内总线进行，ALU通过内总线得到操作数，其运算结果 也经内总线输出。</li>
</ul>
<blockquote>
<ul>
<li>这种结构要求在ALU输入端设置两个暂存器。主要用于暂存提供给ALU的两个操作数。</li>
<li>暂存器还可作为通用寄存器之间传送的转存部件。</li>
</ul>
</blockquote>
<ol start="2">
<li>多组总线结构</li>
</ol>
<p><img src="assets/cpumutiline.png" alt="" /></p>
<ul>
<li>使几个数据传送操作能够同时进行，即实现部分并行操作。</li>
<li>每组总线连接几个部件的输入端，但只连接一个输出端</li>
</ul>
<blockquote>
<p>通用寄存器之间的数据传送必须经ALU才能完成。</p>
</blockquote>
<h2 id="12-指令执行过程"><a class="header" href="#12-指令执行过程">1.2 指令执行过程</a></h2>
<ol>
<li>指令的分段执行过程</li>
</ol>
<p>任何一条指令的执行都要经过读取指令、分析指令和执行指令三 个阶段。读取与分析指令的操作，对所有指令几乎都一样，而每条指 令的执行阶段的具体操作则有较大差别。</p>
<blockquote>
<p>如有的指令需要从存储器中 取操作数，再进行运算，运算结果还要写回存储器，因此执行阶段还 可细分。</p>
</blockquote>
<ul>
<li>
<p>取指令:</p>
<ul>
<li>根据指令计数器PC提供的地址从主存储器中读取当前指令，送到主存数据缓冲器MDR中，然后再送往CPU内的指令寄存器IR中。</li>
<li>同时改变指令计数器PC的内容，使之指向下一条指令地址或紧跟当前指令的立即数或地址码。</li>
</ul>
</li>
<li>
<p>分析指令</p>
<ul>
<li>如果采用组合逻辑控制器，则通过译码电路译出IR中指令各字段表示什么操作，并在时序系统的配合下产生该指令对应的微操作命令序列。</li>
<li>若采用微程序控制器，则可根据指令的操作码与标志位转向控制存储器取出对应的微程序，由微指令提供微操作命令序列。</li>
</ul>
</li>
<li>
<p>执行过程</p>
<ul>
<li>
<p>取操作数</p>
<ul>
<li>如果当前指令需要从主存取操作数，就需安排时间再次访问存储器。</li>
<li>如果是间址方式或是取双操作数，则访存次数更多。</li>
<li>若是变址方式，在取数之前还需安排时间进行变址计算。</li>
</ul>
</li>
<li>
<p>执行操作</p>
<ul>
<li>如果当前指令需要运算，则需考虑形成稳定运算结果的时间，为此安排专门的节拍。</li>
</ul>
<blockquote>
<p>对乘除、浮点运算则需占用更多的节拍。</p>
</blockquote>
<ul>
<li>若运算结果需送回主存单元，则应安排时间以完成对主存的写操作。</li>
</ul>
</li>
<li>
<p>形成下一条指令地址</p>
<ul>
<li>对于顺序执行的指令，下一条指令地址在取指令、取立即数、取地址码时，就已形成在PC中；</li>
<li>如果是转移类指令，则将形成的转移地址送到PC中。以后再取下一条指令、分析、 执行……，如此循环直至程序执行完毕或外来干预为止。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CPU还应该对运行过程中出现的某些异常情况或输入/输出请求进行如下处理：</p>
<ul>
<li>当机器出现某些异常情况</li>
</ul>
<blockquote>
<p>如算术运算的溢出和数据传送的奇偶错等</p>
</blockquote>
<ul>
<li>或者某些输入/输出请求</li>
</ul>
<blockquote>
<p>如磁盘上的批量数据需送存储器或程序员从键盘送入命令等</p>
</blockquote>
<p>此时由相应的部件或设备发出“中断请求信号”或“DMA请求信号”。 若CPU收到中断请求信号</p>
<ul>
<li>在执行完当前指令后，响应该中断请求，暂停当前执行的程序，转去执行中断处理程序。</li>
<li>当处理完毕后，再返回原程序断点继续执行下去。</li>
</ul>
<p>若CPU收到DMA请求信号</p>
<ul>
<li>在完成当前机器周期操作后，响应该DMA请求，暂停工作，让出总线给DMA控制器</li>
<li>由它控制完成输入/输出设备与存储器之间的数据传送操作后，CPU从暂停的机器周期开始继续执行指令。</li>
</ul>
<blockquote>
<p>注意，DMA操作不会改变CPU中任一寄存器（除DMA专用部件外）的状态，因此CPU可以从暂停处快速恢复程序的正确执行。</p>
</blockquote>
<ol start="2">
<li>指令之间的衔接过程</li>
</ol>
<ul>
<li>串行的顺序安排方式: 在一条指令执行完毕后才开始取下一条指令</li>
<li>并行的重叠处理方式: 在对当前指令执行运算操作时提前从主存取出下一条指令，而不必等当前 指令全部执行完。</li>
</ul>
<blockquote>
<p>但如果程序需要转移，预取下一条指令就要失败。 不过由于大多数情况下程序流程是顺序执行，下一条指令地址并不依赖本次执行结果，所以预取指令还是能有效地提高执行速度。</p>
</blockquote>
<h2 id="13-时序控制方式"><a class="header" href="#13-时序控制方式">1.3 时序控制方式</a></h2>
<h3 id="131-同步控制方式"><a class="header" href="#131-同步控制方式">1.3.1 同步控制方式</a></h3>
<p>指各项操作由统一的时序信号进行同步控制。这就意味着各个微操作必须在规定时间内完成，到达规定时间就自动执行后继的微操作。</p>
<p>基本特征: 将操作时间分为若干长度相同的时钟周期 （也称为节拍），要求在一个或几个时钟周期内完成各个微操作。机器的时钟频率（主频）的选择主要取决于CPU内部的操作。</p>
<blockquote>
<p>通常时钟周期应能完成CPU内部花费时间最长的微操作。显然，对于花费时间少的微操作，就会有时间上的浪费，这是同步控制方式的一个缺点。</p>
</blockquote>
<h3 id="132-同步时序控制的多级时序系统"><a class="header" href="#132-同步时序控制的多级时序系统">1.3.2 同步时序控制的多级时序系统</a></h3>
<ol>
<li>多级时序的概念</li>
</ol>
<p>在同步控制方式中，通常将时序信号划分为几级（其中包括指令 周期），称为多级时序。</p>
<p>指令周期是指从取指令、分析指令到执行完该指令所需的时间。</p>
<blockquote>
<p>在时序系统中，因其执行时间的长短可能不同，通常不为指令周期设置时间标志信号，因而也不将其作为时序的一级。</p>
</blockquote>
<p>在组合逻辑控制器中: 依靠不同的时间标志使CPU分步执行指令，其时序信号常划分为三级：</p>
<ul>
<li>机器周期</li>
<li>节拍</li>
<li>时钟脉冲
而在微程序控制器中， 一条指令对应一段微程序（微指令序列），指令的分 步执行是由执行不同的微指令来实现的，每条微指令的执行时间为一个节拍，故其时序信号划分为两级：</li>
<li>节拍</li>
<li>时钟脉冲。</li>
</ul>
<p>机器周期：</p>
<p>组合逻辑控制器中，通常将指令周期划分为几个不同的阶段，每个阶段所需的时间称为机器周期，又称为CPU工作周期或基本周期。</p>
<blockquote>
<p>例如，取指令周期、存储器读周期、存储器写周期等。在不同的机器周期中完成不同的操作。</p>
</blockquote>
<p>在时序系统中需设置一组周期状态触发器，以标志不同的机器周期，任一时刻只允许有其中的一个触发器为1，表明CPU当前处在哪个机器周期。不同的机器周期的长短可以不同。</p>
<p>节拍（时钟周期）</p>
<p>一个机器周期的操作一般需分几步完成。为此，将一个机器周期划分为若干相等的时间段，每个时间段内完成一步基本操作。这个时间段用一个电平信号宽度对应，称为节拍或时钟周期。</p>
<ul>
<li>节拍长度的确定，一般取决于CPU内部的操作需要。</li>
<li>在时序系统中设置有节拍发生器，用以产生节拍信号。</li>
</ul>
<p>时钟脉冲信号CLK</p>
<p>节拍的宽度确定后，时钟脉冲信号的频率也就随之确定了。<br />
在时序系统中，是将由时钟发生器产生时钟脉冲信号作为时序系统的基本定时信号。</p>
<p>此外，在节拍信号的配合下</p>
<ul>
<li>时钟脉冲CLK信号前沿将运算结果打入寄存器</li>
<li>其后沿实现周期切换等功能。</li>
</ul>
<ol start="2">
<li>多级时序信号之间的关系</li>
</ol>
<p><img src="assets/muticontrol.png" alt="" /></p>
<ol start="3">
<li>时序系统的组成</li>
</ol>
<p><img src="assets/timesys.png" alt="" /></p>
<ul>
<li>主振: 就是一个晶体振荡器，当机器一上电就产生频率稳定的主振信号</li>
<li>主振信号由时钟发生器经过整形分频后得到时钟脉冲信号。</li>
<li>启停控制线路控制时钟脉冲CLK的发与不发。</li>
<li>节拍发生器按先后顺序，循环地发出若干节拍信号，它通常用计数译码电路构成。</li>
</ul>
<h2 id="14-指令流水线"><a class="header" href="#14-指令流水线">1.4 指令流水线</a></h2>
<p>一条指令的执行过程也是分成几个步骤实现的。作为一个简化的方法，考虑将指令处理分成两个阶段：取指令和执行指令。在一条指令执行期间，有主存空闲的时间，这个时间能用于取下一条指令，从而使取下一条指令与当前指令的执行并行工作。</p>
<p><img src="assets/2liushui.png" alt="" /></p>
<p>重叠执行存在的问题</p>
<ul>
<li>执行时间一般要长于取时间。</li>
</ul>
<blockquote>
<p>取指阶段可能必须等待一定的时间才能更新它的缓冲器。</p>
</blockquote>
<ul>
<li>条件转移指令使得待取的下一条指令的地址是未知的。</li>
</ul>
<blockquote>
<p>简单解决：当一条件转移指令通过取指阶段到执行阶段时，新的取指阶段取存储器中此转移指令之后的指令。若转移发生，则要作废已取的指令并再取新的指令。</p>
</blockquote>
<p>为获得进一步的加速，流水线可以分成更多的阶段。</p>
<ul>
<li>取指令(FI): 读取下一个预期的指令到寄存器</li>
<li>译码指令(DI): 分析操作码和操作数寻址方式</li>
<li>计算操作数地址(CO): 计算每个源操作数的有效渎职</li>
<li>取操作数(FO): 根据操作数地址从存储器取操作数，寄存器中的数不用取</li>
<li>执行指令(EI): 完成操作码指定的操作。若有指定的目标操作数为位置，则将结果写入此位置</li>
<li>写操作数(WO): 将结果存入存储器</li>
</ul>
<p>以上分解，使各个阶段几乎用相等的时间。</p>
<p><img src="assets/mutiliushui.png" alt="" /></p>
<blockquote>
<p>此过程不适用与所有计算机</p>
</blockquote>
<p>影响流水线性能的主要因素：</p>
<ul>
<li>
<p>若各个阶段不全是相等的时间，会在各个流水阶段涉及到某种等待。</p>
</li>
<li>
<p>流水线中的相关问题</p>
<ul>
<li>数据相关：第二条指令需要第一条指令的结果
<ul>
<li>发生数据相关时，第2条指令的操作数直接从数据处理部件得到，而不是存入后再读取。</li>
<li>数据流分析技术：分析哪一条指令依赖于其他的结果或数据，依此来优化指令调度。</li>
</ul>
<blockquote>
<p>PentiumⅡ就采用该技术，根据分析结果重排指令，使指令以优化的顺序执行，与原始程序的顺序无关。</p>
</blockquote>
</li>
<li>...</li>
</ul>
</li>
<li>
<p>遇到条件转移指令时，确定转移与否的条件码往往由条件转移指令本身或由它前一条指令形成，只有当它流出流水线时，才能建立转移条件并决定下一条指令地址。</p>
<ul>
<li>猜测法：机器先选定转移分支中的一个，按它继续取指并处理
<ul>
<li>假如条件码生成后，说明猜测是正确的，那么流水线可继续进行下去，时间得到充分利用；</li>
<li>假如猜错了，那么要返回分支点，并要保证在分支点后已进行的工作不能破坏原有现场，否则将产生错误。</li>
</ul>
</li>
</ul>
<blockquote>
<p>更复杂的例子是，不只预测下面一个分支，还要提前预测多条分支，如PentiumⅡ就可以进行多重跳转分支预测。</p>
</blockquote>
</li>
<li>
<p>I/O设备有中断请求或机器有故障，要求中止当前程序的执行而转入中断处理。</p>
</li>
</ul>
<h1 id="2-算数逻辑单元alu和运算方法"><a class="header" href="#2-算数逻辑单元alu和运算方法">2. 算数逻辑单元ALU和运算方法</a></h1>
<h2 id="21-移位"><a class="header" href="#21-移位">2.1 移位</a></h2>
<ul>
<li>
<p>逻辑移位：位置变化，空出位补0</p>
<blockquote>
<p>适用于无数值大小的二进制代码</p>
</blockquote>
</li>
<li>
<p>循环移位</p>
<ul>
<li>最高位左移入最低位</li>
<li>最低位右移入最高位</li>
</ul>
<blockquote>
<p>形成闭合环路</p>
</blockquote>
</li>
<li>
<p>算数移位：带符号数的移位，移位后数的符号不变而数值发生变化。</p>
<blockquote>
<p>左移实现乘2，右移实现除2，各个数字所对应位置的权发生了变化</p>
</blockquote>
<ul>
<li>原码
<ul>
<li>左移：符号位不动，其余各位依次左移，末尾补0</li>
<li>右移：符号位不动，其他位依次右移，最高有效位补0</li>
</ul>
</li>
<li>补码
<ul>
<li>左移：各位依次左移，末尾补0
<blockquote>
<p>若符号位变化，则发生溢出</p>
</blockquote>
</li>
<li>右移：符号位不变，其余位右移，最高有效位复制符号位</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="assets/yiwei.png" alt="" /></p>
<h2 id="22-定点数加减运算"><a class="header" href="#22-定点数加减运算">2.2 定点数加减运算</a></h2>
<h3 id="221-原码加减法"><a class="header" href="#221-原码加减法">2.2.1 原码加减法</a></h3>
<p>和操作码和符号都有关</p>
<ul>
<li>+A+(-B) -&gt; +A-(+B), 结果符号与绝对值大的符号相同</li>
<li>+A-(-B) -&gt; +A+(+B), 结果与被减数符号相同␍</li>
</ul>
<h3 id="222-补码加减法"><a class="header" href="#222-补码加减法">2.2.2 补码加减法</a></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)]</span><span class="mord cjk_fallback">补</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<blockquote>
<p>已知<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>求<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
将<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的每一位（包括符号位）取反，最低位+1</p>
</blockquote>
<p><em><strong>补码运算规则</strong></em></p>
<ul>
<li>参与运算的操作数用补码表示</li>
<li>符号位页参与运算，所得结果也是补码表示</li>
</ul>
<h3 id="223-溢出"><a class="header" href="#223-溢出">2.2.3 溢出</a></h3>
<p>如果两个操作数都是同符号数</p>
<ul>
<li>相加 可能溢出</li>
<li>相减 不会溢出</li>
</ul>
<ol>
<li>采用单符号判断法</li>
</ol>
<ul>
<li>正+正=负 溢出（正溢）</li>
<li>负+负=正 溢出（负溢）</li>
</ul>
<ol start="2">
<li>双符号位(变形补码)判断法</li>
</ol>
<p>最高位表示正确的符号，存储时一位，计算时两位</p>
<p>变形补码表示的数：</p>
<ul>
<li>不溢出
<ul>
<li>00：结果为正数</li>
<li>11：结果为负数</li>
</ul>
</li>
<li>溢出
<ul>
<li>01：结果正溢</li>
<li>10：结果负溢</li>
</ul>
</li>
</ul>
<ol start="3">
<li>查看进位</li>
</ol>
<h2 id="23-定点数乘除运算"><a class="header" href="#23-定点数乘除运算">2.3 定点数乘除运算</a></h2>
<h3 id="231-乘法"><a class="header" href="#231-乘法">2.3.1 乘法</a></h3>
<ol>
<li>无符号整数一位乘法</li>
</ol>
<p>计算机中，n位乘法 转换为 n次“累加与移位”</p>
<blockquote>
<p>每一步只求一位乘数所对应的新部分积，并与原部分积作一次累加，然后右移一位。</p>
</blockquote>
<p>流程图</p>
<ul>
<li>3个寄存器A、B、C
<ul>
<li>B：被乘数</li>
<li>C：乘数</li>
<li>A：初值为0，然后存放部分积，最后存放乘积高位,C存乘积低位</li>
</ul>
</li>
<li>乘数每乘一位该位代码就不再使用，A和C寄存器联合右移，将<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>替换</li>
<li>存放逐次增加的部分积，并且使每次乘数位始终在C的最低位<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
<li>乘法完成时，A与C存放的是最后乘积。</li>
</ul>
<p><img src="assets/cheng.png" alt="" /></p>
<hr />
<p>硬件原理图</p>
<ul>
<li>初始化：被乘数送入B、乘数送入C，A和Ca置0（进位触发器<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>保存每次累加的进位）</li>
<li>由乘数位C0产生“加B/不加”（加0）信号，用以控制被乘数B是否与上次部分积相加产生本次部分积</li>
<li>然后<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、A、C一起右移一位；</li>
<li>重复n个节拍的操作后所得到的乘积存放在A和C中。</li>
<li>终止条件：乘数中的每一位都被替换(寄存器C)</li>
</ul>
<p><img src="assets/chengbasic.png" alt="" /></p>
<hr />
<p>举例</p>
<p><img src="assets/chengexample.png" alt="" /></p>
<ol start="2">
<li>有符号整数一位乘法</li>
</ol>
<ul>
<li>有符号 原码 一位乘法
<ul>
<li>符号位单独处理，做异或操作</li>
<li>乘积为|X|·|Y|</li>
</ul>
</li>
<li>有符号 补码 一位乘法
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></li>
</ul>
</li>
</ul>
<h3 id="232-除法"><a class="header" href="#232-除法">2.3.2 除法</a></h3>
<p>关键在于判断够减与否的问题</p>
<ul>
<li>用逻辑线路进行比较判别。硬件代价大。</li>
<li>直接做减法试探。操作不规则，控制时序复杂。
<ul>
<li>判断结果符号
<ul>
<li>为0（即正）表明够减，上商1；</li>
<li>为1（即负）表明不够减，上商0并加上之前减去的除数（即恢复余数）</li>
</ul>
</li>
<li>然后余数左移一位再做下一步。这就是恢复余数法。</li>
</ul>
</li>
</ul>
<p><em><strong>加减交替法(不恢复余数法)</strong></em></p>
<ul>
<li>余数为正，商“1”，余数左移一位，余数减除数</li>
<li>余数为负，商“0”，余数左移一位，余数加除数</li>
</ul>
<p>流程图</p>
<ul>
<li>n位除数存放在B中，2n位被除数存放在A和C中。</li>
<li>除法完成后商放在C中，余数放在A中。</li>
<li>终止条件：被除数的低n位中的值全被商替换后(寄存器C)</li>
</ul>
<p><img src="assets/chufa.png" alt="" /></p>
<blockquote>
<p>在重复n-1次操作后，如果A中的余数为负，需要恢复余数做A+B。最后的寄存器A中应获得正确的正余数。</p>
</blockquote>
<p>举例</p>
<p><img src="assets/chuexample.png" alt="" /></p>
<h2 id="24-浮点数运算"><a class="header" href="#24-浮点数运算">2.4 浮点数运算</a></h2>
<h3 id="241-加减法"><a class="header" href="#241-加减法">2.4.1 加减法</a></h3>
<p>运算规则</p>
<ul>
<li>
<p>对阶：向大阶看齐（为确保精度）</p>
<ul>
<li>求两数阶码之差E</li>
<li>阶码小的数尾数右移E位，结果阶码为大阶数阶码值
<ul>
<li>原码右移，最高位补0</li>
<li>补码右移，复制最高位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>尾数相加减</p>
</li>
<li>
<p>结果规格化</p>
<ul>
<li>原码：最高有效位为1</li>
<li>补码最高位与符号位相反（-0.5除外）</li>
</ul>
<blockquote>
<p>若结果位双符号补码</p>
<ul>
<li>规格化：00.1XXXX或11.0XXXX</li>
<li>左规：00.0XXXX或11.1XXXX(11.10..0除外)
<ul>
<li>左移，同时阶码减小，直至规格化</li>
</ul>
</li>
<li>右规：01.XXXX或10.XXXX
<ul>
<li>右移，复制符号位，同时阶码增大，直至规格化</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>舍入</p>
<ul>
<li>下舍上入法：0舍去，1则在新的尾数末尾加1</li>
<li>恒舍/恒置1，误差大</li>
</ul>
</li>
<li>
<p>判溢：根据阶码判断</p>
<ul>
<li>左规后，阶码减小 -&gt; 判断是否下溢 -&gt; "0"处理</li>
<li>右规后，阶码增大 -&gt; 判断是否上溢 -&gt; 中断处理</li>
</ul>
</li>
</ul>
<h3 id="242-乘除法"><a class="header" href="#242-乘除法">2.4.2 乘除法</a></h3>
<p><em><strong>乘法</strong></em></p>
<ul>
<li>阶码相加并判溢
<ul>
<li>补码相加：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>移码相加：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">([</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1002em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>尾数相乘</li>
<li>规格化处理
<ul>
<li>顶多左规一次（原来两数已是规格化），阶码减小，可能下溢</li>
</ul>
</li>
<li>判溢</li>
</ul>
<!-- NOTE: 乘除不是重点，加减是 -->
<h2 id="25-alu"><a class="header" href="#25-alu">2.5 ALU</a></h2>
<p>ALU主要完成对二进制代码的定点算术运算和逻辑运算</p>
<ul>
<li>算数：定点加减</li>
<li>逻辑：逻辑与、或、异或、非</li>
</ul>
<blockquote>
<p>组合逻辑电路—多功能函数发生器；核心—加法器</p>
</blockquote>
<p>硬件实现</p>
<ul>
<li>如何构成一个二进制加法单元，即全加器
<blockquote>
<p>使用半加器构成</p>
</blockquote>
</li>
<li>如何构成一个n位并行加法器</li>
<li>以加法器为核心，通过输入选择逻辑扩展为具有多种算数和逻辑运算的ALU</li>
</ul>
<p>多位加法器</p>
<ul>
<li>串型加法器：由一个一位全加器组成，数据逐位串行进入加法器</li>
<li>并行加法器：由多个全加器组成，数据各位同时进入加法器进行运算
<ul>
<li>串行进位：将n个全加器串接起来，就可进行两个n位数相加，进位依赖于上一个全加器的值，延迟大</li>
<li>并行进位：复杂电路结构，让各级进位信号同时形成</li>
<li>分组的串并结合
<ul>
<li>组内并行、组间串行的进位链。</li>
</ul>
<blockquote>
<p>芯片SN74181
<img src="assets/SN74181.png" alt="" /></p>
</blockquote>
<ul>
<li>组内并行、组间并行的进位链。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-cpu模型机的组成及其数据通路"><a class="header" href="#3-cpu模型机的组成及其数据通路">3. CPU模型机的组成及其数据通路</a></h1>
<h2 id="31-基本组成"><a class="header" href="#31-基本组成">3.1 基本组成</a></h2>
<p><img src="assets/cpumodel.png" alt="" /></p>
<h3 id="311-寄存器"><a class="header" href="#311-寄存器">3.1.1 寄存器</a></h3>
<p>种类</p>
<ul>
<li>存放控制信息的寄存器</li>
<li>存放处理数据的寄存器</li>
</ul>
<p>为讨论简单，假设所有寄存器都是16位，内部结构是16个D触发 器，数据代码输入至D端，由CP端脉冲同步打入，其输出由输出门控 制。PSW的特征位则由R、S端置入，系统总线对MDR的输入也由R、S端 置入。</p>
<ol>
<li>
<p>可编程寄存器</p>
<ul>
<li>通用寄存器：R0,R1,R2,R3</li>
<li>堆栈指针: SP</li>
<li>程序状态字：PSW</li>
<li>程序计数器：PC</li>
</ul>
</li>
<li>
<p>暂存器: C,D,Z</p>
<ul>
<li>在ALU输出端设暂存器Z存放运算结果。</li>
<li>暂存器D还可暂存从主存储器读出的数据，并设有左移和右移功能。</li>
<li>暂存器C主要用于暂存从主存读出的源操作数。</li>
</ul>
</li>
<li>
<p>指令寄存器IR</p>
<ul>
<li>存放当前正在执行的一条指令。</li>
<li>当执行一条指令时，应先将指令从主存中读出到IR中。</li>
<li>IR的内容（指令）是控制器产生控制信号的主要逻辑依据。</li>
</ul>
</li>
<li>
<p>与主存接口的寄存器MAR、MDR</p>
<ul>
<li>地址寄存器MAR用于存放CPU访问主存或I/O接口的地址。MAR连接
地址总线的输出门是三态门
<ul>
<li>当微命令EMAR为高电平时，MAR输出地址送往地址总线；</li>
<li>当EMAR为低电平时，MAR输出呈高阻态，与地址总线断开。</li>
</ul>
</li>
<li>数据寄存器MDR用于存放CPU与主存或I/O接口之间传送的数据。
<ul>
<li>CPU的输出数据必须先打入MDR，再从MDR输出到数据总线上。</li>
<li>对于输入 CPU的数据，则从数据总线输入数据到MDR，然后由MDR送往CPU中的其他部件。</li>
<li>MDR与数据总线间为双向连接，其输出级也采用三态门，可与数据总线断开。</li>
<li>CPU对主存的控制信号有两个
<ul>
<li>读信号RD控制对主存的读操作；</li>
<li>写信号WR控制对主存的写操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="312-运算部件"><a class="header" href="#312-运算部件">3.1.2 运算部件</a></h3>
<p>ALU的输入A来自暂存器D，输入B来自ALU总线，运算结果输出到Z。<br />
控制ALU运算的控制信号有：ADD、SUB、AND、OR、XOR、COM、NEG、A+1、A−1、B+1、B−1，它们分别控制ALU完成加、减、与、或、异或、求负、求反等运算。</p>
<h3 id="313-总线与数据通路结构"><a class="header" href="#313-总线与数据通路结构">3.1.3 总线与数据通路结构</a></h3>
<ol>
<li>ALU总线</li>
</ol>
<p>CPU内部采用单总线结构</p>
<ul>
<li>即设置一组ALU总线（也称为CPU内总线），由16根双向数据传送线组成</li>
<li>ALU和所有寄存器通过这组公共总线连接起来。</li>
<li>在单总线结构中，CPU的任何两个部件间的数据传送都必须通过这组总线</li>
</ul>
<p>挂接在ALU总线上的寄存器几乎都设有三态输出门和打入脉冲。</p>
<ul>
<li>三态输出门打开，便将寄存器中的信息代码送到ALU总线上去，但每次只允许 一个部件向ALU总线发送信息代码；</li>
<li>接收信息的寄存器可以有多个，由打入脉冲将ALU总线上的信息代码打入其中。</li>
</ul>
<ol start="2">
<li>系统总线</li>
</ol>
<p>模型机的CPU、存储器及I/O设备分别挂接在一组系统总线上。</p>
<p>系统总线包括：16根地址总线、16根数据总线，以及控制总线。
为简单起见，模型机采用同步控制方式。</p>
<ul>
<li>CPU通过MAR向地址总线提供访问主存单元或I/O接口的地址，由控制信号EMAR决定是否发送地址。I/O接口（如DMA控制器）也可以向地址总线发送访存地址。</li>
<li>CPU通过MDR向数据总线发送或接收数据，以完成与主存单元或I/O接口之间的数据传送，由控制信号RD、WR决定传送方向。主存M和I/O设备之间也可以通过数据总线传送数据。</li>
<li>CPU通过控制总线向主存或I/O设备发出有关控制信号，或接收控制信号。有时，I/O设备也可以向控制总线发出控制信号。</li>
</ul>
<h3 id="314-控制器及微命令的基本形式"><a class="header" href="#314-控制器及微命令的基本形式">3.1.4 控制器及微命令的基本形式</a></h3>
<ol>
<li>微命令的基本形式</li>
</ol>
<p>微操作命令是最基本的控制信号，通常是指直接作用于部件或控制门电路的控制信号，简称微命令。</p>
<blockquote>
<p>例如，打开或关闭某个三态门的电位信号，或是对寄存器进行同步打入、置位、复位的脉冲。</p>
</blockquote>
<p>微命令的两种形式</p>
<p>电位型微命令：用信号电平的高与低分别表示不同的信息</p>
<blockquote>
<p>通常定义高电平（如+5V）表示1，低电平（如0V）表示0。</p>
</blockquote>
<ul>
<li>各寄存器输出到ALU总线的控制信号有：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>等。
• ALU运算控制信号有：ADD、SUB、AND、OR、XOR等。
• 暂存器D的左移/右移控制信号有：SAL、SAR。
• 程序计数器PC的计数控制信号有：PC+1。
• MAR和MDR输出到系统总线的控制信号有：EMAR、EMDR。
• 寄存器置入控制信号有：SMDR、SPSW。
• 主存的读/写信号有：RD、WR。</li>
</ul>
<p>脉冲型微命令：利用脉冲边沿（即正向或负向跳变）来表示某一时刻，起定时作用，或识别脉冲的有无。</p>
<ul>
<li>各寄存器均采用同步打入脉冲将ALU总线上的数据打入其中。</li>
<li>脉冲型微命令有：CP_{R0} 、CP_{R1} 、CP_{PC} 、CP_{IR} 、CP_{SP} 、CP_{MAR} 、CP_{MDR} 等。</li>
</ul>
<ol start="2">
<li>控制器</li>
</ol>
<p>功能：根据指令产生控制信号序列以控制相应部件分步完成指定的操作。</p>
<ul>
<li>向CPU内部发送控制信号，控制寄存器之间的数据传送，使ALU完成指定功能以及其他内部操作；</li>
<li>它也向CPU外部发出控制信号，以控制CPU与存储器或I/O设备之间传送数据。</li>
</ul>
<p>传统控制器的主要部件包括：</p>
<ul>
<li>指令寄存器IR</li>
<li>指令译码器</li>
<li>程序计数器PC</li>
<li>状态字寄存器PSW</li>
<li>时序系统</li>
<li>微操作信号发生器
在微型计算机中，将控制器和运算器（即CPU）集成在一块芯片上，因此现在
是将CPU作为一个整体来讨论。</li>
</ul>
<p>如图3-20所示，微操作信号发生器的输入由</p>
<ul>
<li>IR中的指令经译码后的输出</li>
<li>PSW的状态位</li>
<li>时序信号</li>
<li>外部的控制信号（如中断信号）组成。
微操作信号发生器则依据它的输入产生指令执行时所需要的微操作信号（即控制信号）。</li>
</ul>
<h2 id="32-数据传送"><a class="header" href="#32-数据传送">3.2 数据传送</a></h2>
<ol>
<li>寄存器之间的数据传送</li>
</ol>
<p>在模型机中，寄存器之间可直接通过ALU总线传送数据，具体传送由输出门和打入脉冲控制。</p>
<p>如图3-20所示，</p>
<ul>
<li>某寄存器<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">i</span></span></span></span> 的输出和打入分别由<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9334em;vertical-align:-0.2501em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0077em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span>控制。</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">i</span></span></span></span> 的输出门控制信号<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 为高电平时，输出门打开，Ri 的内容就送到了ALU总线上；</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>为低电平时，输出门关闭，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">i</span></span></span></span>的输出呈高阻态，与ALU总线隔离。</li>
<li>打入脉冲<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9334em;vertical-align:-0.2501em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0077em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span> 有效时，将ALU总线上的数据打入Ri 。</li>
</ul>
<p>例如，把寄存器R1的内容传送到寄存器R3，即实现传送操作R1→R3所需控制信号为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</p>
<ol start="2">
<li>主存数据到CPU</li>
</ol>
<p>如图3-20所示，要从主存中读一个数据到CPU</p>
<ul>
<li>CPU首先要把所取数据的地址送到MAR</li>
<li>然后将MAR中的地址输出到地址总线上，同时发读命令到主存；</li>
<li>主存完成读操作后将读出的16位数据送到数据总线上，再将数据线上的信息置入MDR。</li>
</ul>
<p>例如要从存储器中取指令到指令寄存器IR，通过以下操作序列即可实现：</p>
<ul>
<li>PC→MAR ；PC中的指令地址送存储器地址寄存器
<ul>
<li>实现PC→MAR传送操作所需的控制信号为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</li>
</ul>
</li>
<li>M→MDR→IR ；从存储器中读指令到IR
<ul>
<li>实现读操作M→MDR的控制信号为EMAR、RD、SMDR；</li>
<li>实现MDR→IR的控制信号为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>CPU数据到主存</li>
</ol>
<p>由图3-20可见，CPU数据要写入主存</p>
<ul>
<li>首先要将寄存器中的数据装入MDR，还要将写入主存单元的地址送MAR，然后发写命令；</li>
<li>主存将按MAR中的地址把MDR的内容写入对应单元中。</li>
</ul>
<p>例如在R2中存放需写入主存的数据，存储单元地址在R1中，则写一个数据到存储器可通过以下操作序列实现：</p>
<ul>
<li>R1→MAR ；地址送MAR
<ul>
<li>实现R1→MAR操作的控制信号为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</li>
</ul>
</li>
<li>R2→MDR ；数据送MDR
<ul>
<li>实现R2→MDR的控制信号为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
</li>
<li>MDR→M ；数据写入主存
<ul>
<li>实现写操作MDR→M的控制信号为EMAR、EMDR、WR。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>执行算数或逻辑操作</li>
</ol>
<p>执行算术或逻辑操作时，由于ALU本身是没有内部存储功能的组合电路，因此，如要执行加法运算，被相加的两个数必须在ALU的两个输入端同时有效，图3-20中的暂存器D即用于该目的。</p>
<ul>
<li>先将一个操作数经ALU总线送入暂存器D保存起来，D的内容在ALU的输入端A始终有效</li>
<li>再将另一个操作数经总线直接送到ALU的输入端B；这样两个操作数都
送入了ALU</li>
<li>运算结果暂存在暂存器Z中</li>
</ul>
<p>若要执行“把寄存器R1和R2的内容相加，结果送到R3”这个功能，需要分成三步执行：</p>
<ul>
<li>R1→D ；把R1的内容先送到寄存器D
<ul>
<li>实现R1→D操作的控制信号为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</li>
</ul>
</li>
<li>D+ R2→Z ；R2内容送到ALU的B端与D内容通过ALU相加，结果送Z
<ul>
<li>实现D + R2→Z的控制信号为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">Z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</li>
</ul>
</li>
<li>Z→R3 ；将相加结果送入R3中
<ul>
<li>实现Z→R3的控制信号为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
</li>
</ul>
<h1 id="4组合逻辑控制器原理"><a class="header" href="#4组合逻辑控制器原理">4、组合逻辑控制器原理</a></h1>
<p>按产生控制信号的方式不同，控制器可分为</p>
<ul>
<li>组合逻辑控制器</li>
<li>微程序控制器两种基本类型。</li>
</ul>
<p>组合逻辑控制器是指产生控制信号（即微命令）的部件，是用组合逻辑线路来实现的。</p>
<p>在模型机中有几十个微命令，则每个微命令都需要一组逻辑门电路，根据相应的逻辑条件（如指令的操作码、寻址方式、时序信号等）产生该微命令。控制器一旦制造完成后，这些逻辑电路之间的连接关系就固定了，不易改动，所以组合逻辑控制器又称为硬连逻辑控制器。</p>
<h2 id="41-模型机的指令系统"><a class="header" href="#41-模型机的指令系统">4.1 模型机的指令系统</a></h2>
<p>本节先介绍模型机的指令系统，然后假设模型机采用的是组合逻辑控制器，讨论其时序系统、指令执行流程及微命令的产生与综合。</p>
<h3 id="411-指令格式"><a class="header" href="#411-指令格式">4.1.1 指令格式</a></h3>
<p><img src="assets/model_instrution.png" alt="" /></p>
<p>对于转移指令字段，第0-3位中有一位为1，表示转移条件</p>
<ul>
<li>进位--<code>C</code></li>
<li>溢出--<code>V</code></li>
<li>结果为零--<code>Z</code></li>
<li>结果为负--<code>N</code><br />
第五位表明转移方式，若为0，表示相关标志位为0则转移。<br />
若第0-5位全为0，则表无条件转移</li>
</ul>
<p>可编程寄存器有七个，编号如下</p>
<ul>
<li>通用寄存器R0-R3,000-011</li>
<li>堆栈指针SP,100</li>
<li>程序状态字PSQ,101</li>
<li>程序计数器PC,111</li>
</ul>
<h3 id="412-寻址方式"><a class="header" href="#412-寻址方式">4.1.2 寻址方式</a></h3>
<ul>
<li>立即数寻址，操作数紧跟着指令，即在指令代码之中。</li>
<li>操作数在寄存器中，即寄存器寻址方式。</li>
<li>操作数在主存中，相应的寻址方式有：
<ul>
<li>直接寻址方式，地址紧跟指令操作码与寻址字段后。</li>
<li>寄存器间址方式，地址在寄存器中。</li>
<li>自增型寄存器间址方式。</li>
<li>自减型寄存器间址方式。</li>
<li>变址方式。</li>
</ul>
</li>
</ul>
<p><img src="assets/model_find_pos.png" alt="" /></p>
<ul>
<li>0型</li>
</ul>
<p>寄存器寻址方式，寻址字段代码000，汇编符号<code>R</code>，定义为：操作数在指定的寄存器中</p>
<ul>
<li>1型</li>
</ul>
<p>寄存器间址方式，寻址字段代码001，汇编符号<code>(R)</code>，定义为：操作数地址在指定寄存器中（即从指定寄存器中得到操作数地址，再按次地址访问主存，从主存中读取操作数）</p>
<ul>
<li>2型</li>
</ul>
<p>自减型寄存器寻址方式，寻址字段代码010，汇编符号<code>-(R)</code>，定义为：将指定寄存器内容减去1后为操作数地址，再按地址防伪主存，从主存中获取操作数</p>
<ul>
<li>3型</li>
</ul>
<p>立即/自增型寄存器寻址方式，寻址代码011，汇编代码<code>(R)+</code>，定义为：操作数地址在指定寄存器中，地址使用后将寄存器内容加1，</p>
<ul>
<li>4型</li>
</ul>
<p>直接寻址方式，寻址字段代码100，汇编符号<code>DI</code>，定义为：操作数地址紧跟指令操作码与寻址字段后的单元中，然后PC+1，将修改后的PC内容作为地址，据此访问紧跟当前指令操作码与寻址字段后的存储单元，从中取得操作数地址（称为绝对地址），据此再度访存，读得操作数，然后PC+1</p>
<ul>
<li>5型</li>
</ul>
<p>变址方式，寻址字段101，汇编符号<code>X(R)</code>，其中X是变址的一种习惯标注符，定义为：指定变址寄存器内容与紧跟指令操作码与寻址字段后的位移量相加，其结果为操作数地址。</p>
<h3 id="413-操作类型"><a class="header" href="#413-操作类型">4.1.3 操作类型</a></h3>
<p>操作码共4位，现设14中指令，余下两种操作码可共扩展</p>
<ol>
<li>传送指令</li>
</ol>
<ul>
<li><code>MOV</code>: 传送，操作码0000</li>
</ul>
<ol start="2">
<li>双操作数算数逻辑指令</li>
</ol>
<ul>
<li><code>ADD</code>: 加，操作码0001（带进位）</li>
<li><code>SUB</code>: 减，操作码0010（带进位）</li>
<li><code>AND</code>: logic and,operator 0011</li>
<li><code>OR</code>: logic or,operator 0100</li>
<li><code>EOR</code>: 逻辑异或,操作码0101</li>
</ul>
<ol start="3">
<li>singnal operator instruction</li>
</ol>
<ul>
<li><code>COM</code>: 求反,operator 0110</li>
<li><code>NEG</code>: 求补，operator 0111</li>
<li><code>INC</code>: add 1,operator 1000</li>
<li><code>DEC</code>: substruct 1,operator 1001</li>
<li><code>SL</code>: move left,operator 1010</li>
<li><code>SR</code>: move right,operator 1011</li>
</ul>
<ol start="4">
<li>program control instruction</li>
</ol>
<ul>
<li><code>JMP</code>: 转移指令,operator 1100</li>
</ul>
<p><img src="assets/jmp.png" alt="" /></p>
<p>如表3-5所示，JMP指令第3～0位选择一位为1，表明以PSW中的某一特征作为转移条件。</p>
<p>JMP指令第5位（IR5）决定转移条件为0转，还是为1转。若JMP指令第5～0位全为0，则表示无条件转移。</p>
<ul>
<li><code>RST</code>: 返回指令，operator 1100</li>
</ul>
<p>RST指令与JMP指令的操作码相同，可视为一条指令。RST指令只能采用自增型寄存器间址表明转移地址，并指定寄存器为SP，即寻址方式为（SP）+。它从堆栈中取出返回地址，然后修改堆栈指针SP+1。实际上，“JMP（SP）+”指令就是一条RST指令。</p>
<ul>
<li><code>JSR</code>: 转子指令，operator 1101</li>
</ul>
<p>执行JSR指令时，先将返回地址压栈保存，然后按寻址方式找到转移地址（即子程序入口地址），将它送入PC中。</p>
<h2 id="42-模型机的时序系统"><a class="header" href="#42-模型机的时序系统">4.2 模型机的时序系统</a></h2>
<p>组合逻辑控制器依靠不同的时间标志，使CPU分步工作。</p>
<p>模型机采用前述的三级时序系统，即将时序信号分为工作周期、节拍（时钟周期）和工作脉冲。</p>
<h3 id="421-工作周期划分"><a class="header" href="#421-工作周期划分">4.2.1 工作周期划分</a></h3>
<p>模型机设置了6种工作周期，分别用6个周期状态触发器来表示它们的状态。任一时刻只允许一个触发器为1，表明CPU现在所处的工作周期状态，并为该阶段的工作提供时间标志与依据。</p>
<ol>
<li>取指令周期<code>FT</code></li>
</ol>
<p>完成取指所需的操作。</p>
<ol start="2">
<li>源周期<code>ST</code></li>
</ol>
<p>如果需要从主存中读取源操作数，则进入ST。在ST中将依据指令寄存器IR的源地址字段信息进行操作，形成源地址，读取源操作数。</p>
<ol start="3">
<li>目的周期<code>DT</code></li>
</ol>
<p>如果需要从主存中读取目的地址或目的操作数，则进入DT。在DT中将依据指令寄存器IR的目的地址段信息进行操作。</p>
<ol start="4">
<li>执行周期<code>ET</code></li>
</ol>
<p>取得操作数后，则进入ET，将依据IR中操作码执行相应操作，如传送、算术运算、逻辑运算、获得转移地址等。</p>
<ol start="5">
<li>中断响应周期<code>IT</code></li>
</ol>
<p>CPU在响应中断请求之后，进入中断响应周期IT。</p>
<ul>
<li>在IT中将直接依靠硬件进行关中断、保存断点、转处理程序入口等操作。</li>
<li>IT结束后，进入取指周期FT，开始执行中断处理程序。</li>
</ul>
<blockquote>
<p>中断方式是指这样一种工作方式：由于某些异常情况或特殊请求，引起CPU暂停执行当前程序，转去执行中断处理子程序，以处理这些情况或请求，等处理完后又返回原程序断点继续执行，这一过程就称为中断。</p>
</blockquote>
<ol start="6">
<li>DMA传送周期<code>DMAT</code></li>
</ol>
<p>CPU响应DMA请求之后，进入DMAT。</p>
<p>在DMAT中</p>
<ul>
<li>CPU交出系统总线的控制权，即MAR、MDR与系统总线脱钩（呈高阻态）</li>
<li>改由DMA控制器控制系统总线，实现主存与外围设备间的数据直接传送</li>
<li>因此对CPU来说，DMAT是一个空操作周期。</li>
</ul>
<blockquote>
<p>DMA（Direct Memory Access）即直接访存方式，它的基本思想是在主存储器和I/O设备 之间建立直接的数据传送通路，由专门的DMA控制器控制主存和I/O设备间的数据传送，在传送时不需CPU干预。由于传送过程完全由硬件实现，所花费的时间短，因此能满足高速数据传送的需要。</p>
</blockquote>
<p><img src="assets/cpu_period.png" alt="" /></p>
<p>为此，在每一周期结束前，都要判断下一个周期状态将是什么，并为此准备好进入该周期的条件，如发出电位信号1→ST等。到本周期结束的时刻，再实现周期状态的定时切换。</p>
<p>由于DMA周期要实现的是高速数据直传，所以DMA请求的优先级高于中断请求。</p>
<blockquote>
<p>注意，实际的计算机大多允许在一个系统总线周期结束时插入DMAT。本模型机为了简化其控制逻辑，限制在一条指令结束时才判别与响应DMA请求。</p>
</blockquote>
<h3 id="422-节拍时钟周期"><a class="header" href="#422-节拍时钟周期">4.2.2 节拍（时钟周期）</a></h3>
<p>每个工作周期的操作一般需要分成若干步完成，为此将工作周期划分成若干节拍。</p>
<p>节拍宽度为最长微操作所需的时间，即访问主存操作所需的时间</p>
<blockquote>
<p>注意，在实际机器中节拍长度短于访存周期</p>
</blockquote>
<p>节拍发生器由计数器T与节拍译码器组成。当工作周期开始时，T=0，若本工作周期还需延长，则发命令T+1，计数器将继续计数，表示进入一个新的节拍；若本工作周期应当结束，则发命令T=0，计数器T复位，从T=0开始一个新的计数循环，进入新的工作周期。</p>
<h3 id="423-工作脉冲"><a class="header" href="#423-工作脉冲">4.2.3 工作脉冲</a></h3>
<p>在节拍中执行的有些操作需要同步定时脉冲，如将稳定的运算结果打入寄存器，又如周 期状态切换等。为此，模型机在每个节拍的末尾发一个工作脉冲P，作为各种同步脉冲的来源</p>
<ul>
<li>工作脉冲P的前沿作为打入寄存器的定时信号，它标志着一次数据通路操作的完成。</li>
<li>P的后沿作为节拍与工作周期切换的定时信号，在此刻对节拍计数器T计数、打入新的工作周期状态。</li>
</ul>
<h2 id="43-指令流程"><a class="header" href="#43-指令流程">4.3 指令流程</a></h2>
<p>分析指令流程是为了在寄存器这一层次分析指令序列的读取与执行过程，也就是讨论CPU的工作机制</p>
<p>设计和确定指令执行的具体流程通常有两种方法</p>
<ul>
<li>工作周期为线索: 以工作周期为主轴来制定各类指令的操作流程</li>
<li>指令为线索: 以指令类型为主轴来制定流程</li>
</ul>
<h3 id="431-取指令周期ft"><a class="header" href="#431-取指令周期ft">4.3.1 取指令周期FT</a></h3>
<p>FT中的操作是各类指令流程都需首先经历的，与指令类型无关，通常称为公共操作。</p>
<h4 id="进入ft的条件"><a class="header" href="#进入ft的条件">进入FT的条件</a></h4>
<p>取指周期状态触发器FT为1</p>
<p><img src="assets/ft_trrigle.png" alt="" /></p>
<ol>
<li>初始化置入FT</li>
</ol>
<p>当机器加电或按“复位”键后，将产生一个“复位信号”预置全机的初始状态。</p>
<ul>
<li>首先将某值（如全0）置入程序计数器PC中，此即为开机后执行的第一条指令的地址，同时将取指周期状态触发器FT置1。</li>
<li>当复位信号结束后，开放时钟，开始执行取指操作，进入操作系统程序运行状态。由于在复位信号作用时，时钟被封锁，因此采取S端置入方式。</li>
</ul>
<ol start="2">
<li>程序运行过程中，同步打入FT</li>
</ol>
<p>在正常的程序运行过程中，时钟已开放，可用同步方式实现周期状态转换。</p>
<ul>
<li>若要进入FT，则事先在状态触发器D端准备好条件1→FT，然后产生同步脉冲<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> ，由<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>的上升沿（即脉冲P的后沿），将1打入FT。</li>
<li>若要结束FT状态，则让D端电平为0，并产生<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>将0打入FT，使FT变为0，表示取指周期结束。</li>
</ul>
<p>有三种情况可采用同步方式进入新的取指周期：</p>
<ul>
<li>当一条指令将执行完毕时，即在执行周期ET中，如果不响应DMA请求与中断请求，程序正常执行，接着就转入新的FT，开始执行下一条指令。</li>
<li>在中断周期IT这一过渡阶段操作结束后，就应转入中断处理程序，即进入FT。</li>
<li>在DMA周期完成一次DMA传送后，如果没有新的DMA请求，也没有中断请求，则恢复执行被暂停的程序，也应进入FT。</li>
</ul>
<p>因此，产生控制信号1→FT的逻辑条件如下：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">FT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1333em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ET</span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1333em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1333em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1333em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<blockquote>
<p>整个表达式是一个布尔逻辑表达式，所有变量都只有两种状态（0或1），用来表示不同条件的真或假，以便触发控制信号<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">FT</span></span></span></span>。</p>
</blockquote>
<h4 id="取指流程"><a class="header" href="#取指流程">取指流程</a></h4>
<p><img src="assets/get_instruction.png" alt="" /></p>
<ul>
<li>在<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中先将指令地址由PC送入MAR；</li>
<li>在<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中从主存读出指令代码到MDR再送到指令寄存器IR中，由于PC本身具有计数功能，所以可同时修改程序计数器PC的内容，让PC+1，则修改后的PC指向紧跟当前指令操作码与寻址字段后的下一主存单元。</li>
</ul>
<h4 id="微操作时间表"><a class="header" href="#微操作时间表">微操作时间表</a></h4>
<p><img src="assets/smalloperationtable.png" alt="" /></p>
<p>表3-6以操作时间表形式，进一步给出了为实现取指流程的每步基本操作与转入下一步操作所需的微命令（包括控制电位和脉冲）。</p>
<ul>
<li>左栏给出节拍序号，如T0 、T1 、…，也可将工作周期状态与节拍序号综合标注，如FT0 形式。</li>
<li>中栏给出在本拍中应发的电平型微命令，这些命令同时发出，维持一个节拍宽度。
<ul>
<li>有些命令只在某些逻辑条件下才发出，则进一步在括号中标注其补充逻辑条件</li>
<li>如果表中空间不便写全，或是在拟定本表时还不能给出全部逻辑条件，要等到全部指令流程与操作时间表都列完后才能全部确定，则可在括号中先注明逻辑条件，以后再补充相应逻辑式</li>
</ul>
</li>
<li>右栏给出本拍中应发的脉冲型微命令，并示意性地表明脉冲是在时钟周期的末尾发出的，由工作脉冲P或其反相脉冲P定时。</li>
</ul>
<hr />
<p>让我们分析FT操作时间表中各个微命令的含义。如表3-6所示，</p>
<ul>
<li>在<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li>要完成PC→MAR操作，则应发控制信号<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，由它们控制将PC的内容送ALU总线并打入MAR中。</li>
<li>控制信号T+1、CPT 控制转入下一个节拍FT1 。</li>
</ul>
</li>
<li>在FT1中
<ul>
<li>要完成M→MDR→IR操作，控制信号EMAR、RD、SMDR控制从主存中读一个字（指令）置入MDR，由<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 、<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>将MDR内容打入IR中。</li>
<li>要完成PC+1→PC操作，控制信号PC+1、<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">PC</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 将PC内容加1计数。</li>
</ul>
</li>
</ul>
<p>在取指周期结束时，需根据已取到IR中的指令操作码与寻址方式，判断应转入哪个周期， 因此1→ST、1→DT、1→ET这三个电位信号中只能有一个为1，其逻辑条件主要涉及操作码与寻址方式。</p>
<p>当周期状态发生转换时，FT触发器的D端1→FT为0，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">FT</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>将其打入0。<br />
在周期状态结束时，T+1为0，由CPT使T计数器置0。</p>
<h3 id="432-move指令"><a class="header" href="#432-move指令">4.3.2 MOVE指令</a></h3>
<p>如果当前指令是MOV指令，CPU将执行MOV指令流程，如图3-26所示。</p>
<p><img src="assets/move_instruction.png" alt="" /></p>
<p>MOV指令流程图包含了各种寻址方式的组合</p>
<ul>
<li>流程分支的逻辑依据就是指令的寻址方式字段代码，图中标注为相应的汇编符号。</li>
<li>每个工作周期结束时要判断后继工作周期将是什么。</li>
</ul>
<ol>
<li>FT</li>
</ol>
<p>取指令周期FT</p>
<ol start="2">
<li>ST</li>
</ol>
<p>在FT中根据寻址方式作出判别，决定在ST中的分支。</p>
<ul>
<li>R型: 源操作数在指定寄存器中
<ul>
<li>第1拍ST0将寄存器Ri内容送入C中。</li>
</ul>
</li>
<li>(R)型
<ul>
<li>第1拍ST0 完成从指定寄存器Ri 中取得源地址</li>
<li>第2拍ST1 访存读取操作数，经MDR送入C中暂存。</li>
</ul>
</li>
<li>−(R)型
<ul>
<li>第1拍先修改地址指针内容，即指定寄存器Ri 内容减1，所得结果打入Z。</li>
<li>第2拍将Z同时送入Ri 与MAR，形成源地址</li>
<li>第3拍访存读取操作数，送入C暂存。</li>
</ul>
</li>
<li>I/(R)+型
<ul>
<li>第1拍取得地址</li>
<li>第2拍读取操作数</li>
<li>第3、4拍修改地址指针，即Ri 加1。</li>
</ul>
</li>
<li>DI型 操作数地址紧跟着指令。取指后PC已加1，指向紧跟当前指令的下一单元
<ul>
<li>ST0 将PC内容送MAR</li>
<li>ST1 据此访存，从中取得操作数地址，并同时修改PC。</li>
<li>ST2 读取操作数。</li>
</ul>
</li>
<li>X(R)型 需两次访存，第1次在PC指点下读取位移量，第2次读取操作数。
<ul>
<li>ST0 中将PC内容送MAR。</li>
<li>ST1 读取位移量，暂存于D，并修改PC指针。</li>
<li>ST2 实现变址计算，即变址寄存器Ri中的变址量与D中的位移量相加，获得操作数地址。</li>
<li>ST3 操作数地址送MAR。</li>
<li>ST4 读取操作数。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>DT</li>
</ol>
<p>与ST相似，但对于MOV指令，DT直到取得目的地址为止。</p>
<blockquote>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>表示目的地址采用寄存器寻址方式，若不是寄存器寻址方式，则用<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>表示。</p>
</blockquote>
<ol start="4">
<li>ET</li>
</ol>
<p>执行周期的基本任务是实现操作码要求的传送操作，这就需要考虑在进入ET时，操作数是送往寄存器还是送往主存，可以根据DR状态区分。因此，按DR形成两种分支，如图3-26所示。</p>
<p>指令流程图只反映了正常执行程序的情况，实际上在最后一拍还需判别是否响应DMA请求与中断请求，即是否发1→DMAT或1→IT。如果都没有，则建立1→FT，转入下一条指令。</p>
<h3 id="433-双操作数指令"><a class="header" href="#433-双操作数指令">4.3.3 双操作数指令</a></h3>
<p>双操作数指令共有5条：加ADD、减SUB、与AND、或OR、异或EOR，其指令流程如图3-27所示。</p>
<p>其中取指和取源操作数周期，与MOV指令相同，图中不再细画。目的周期DT也与MOV指令的DT相似，但多一步操作，即访存读取目的操作数，其余则完全相同，不再赘述。</p>
<p>OP是操作运算符，例如C OP D→Z，若该指令是一条加法指令，则所描述的含义即为C+D→Z。</p>
<p><img src="assets/double_operator_instruction.png" alt="" /></p>
<h3 id="434-单操作数指令"><a class="header" href="#434-单操作数指令">4.3.4 单操作数指令</a></h3>
<p>单操作数指令共有6条：求反COM、求补NEG、加“1”INC、减“1”DEC、左移SL、右移SR，其指令流程图如图3-28所示。</p>
<p><img src="assets/single_operator_instruction.png" alt="" /></p>
<p>单操作数指令只有一个操作数，处理后送回原处，因此不需源周期状态ST，取指后直接进入目的周期DT，执行周期ET中的流程分支也只有两类，其余均与双操作数指令相同。<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中的具体操作含义取决于操作码OP，例如OP D→Z，若该指令是一条求反指令，则所描述的含义为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>→Z。</p>
<h3 id="435-转移指令jmp返回指令rst"><a class="header" href="#435-转移指令jmp返回指令rst">4.3.5 转移指令JMP/返回指令RST</a></h3>
<p>JMP指令的流程如图3-29所示。RST指令被视为JMP指令的一种特例。</p>
<p><img src="assets/jump_insruction.png" alt="" /></p>
<p>JMP/RST指令的主要任务是获得转移地址或返回地址，安排在执行周期ET中完成，因此</p>
<ul>
<li>在FT中读得指令并修改PC后，直接进入ET。</li>
<li>根据指令规定的转移条件与PSW相应的位的实际状态，决定是否转移，相应地分成转移成功（JP）、转移不成功（NJP）两种可能。</li>
</ul>
<ol>
<li>转移不成功<code>NJP</code></li>
</ol>
<p>转移条件不满足，则程序将顺序执行。 在决定下一条指令地址时有以下两种可能的情况</p>
<ul>
<li>
<p>转移地址段中的寻址方式所指定的寄存器如果不是PC寄存器，称为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>型(即通用寄存器、堆栈指针SP)，则后继指令紧跟着当前转移指令（在FT中修改后的PC内容，就是后继指令地址）。</p>
</li>
<li>
<p>转移地址段中的寻址方式所指定的寄存器指明是PC，称为PC型，则紧跟指令操作码与寻址字段之后的单元已用来存放转移地址，再下一个存储单元内容才是后继指令，所以在ET中令PC再次加1。</p>
</li>
</ul>
<ol start="2">
<li>转移成功JP</li>
</ol>
<p>即转移条件满足，按寻址方式获得转移地址。</p>
<ul>
<li>寄存器寻址R: 从指定寄存器中读取转移地址。</li>
<li>寄存器间址（R）: 从指定寄存器中读取间址单元地址，再从间址单元中读取转移地址。</li>
<li>自增型寄存器间址（R）+ : 比上一种寻址方式增加一步修改指针R i 的操作。</li>
<li>返回指令RST 其寻址方式固定为（SP）+，即从堆栈中读取返回地址，然后修改指针SP。</li>
<li>相对寻址X（PC）: 以PC内容为基准进行转移地址计算。</li>
</ul>
<h3 id="434-转子指令jsr"><a class="header" href="#434-转子指令jsr">4.3.4 转子指令JSR</a></h3>
<p><img src="assets/vrzi_instruction.png" alt="" />
转子指令采用（R）或（R）+型，安排在源周期ST，从主存中读取转移地址，暂存于C中。</p>
<p>在ET0 ～ET3 中，先将返回地址压入堆栈保存，即修改堆栈指针，将PC内容（返回地址）经MDR写入堆栈。在ET4 中再将子程序入口地址送入PC。</p>
<h3 id="435-中断响应周期it"><a class="header" href="#435-中断响应周期it">4.3.5 中断响应周期IT</a></h3>
<p>当外部有中断请求信号送入CPU时</p>
<ul>
<li>若允许响应，则在一条指令的执行周期ET的最后一拍，向请求源发中断响应回答信号INTA，并在ET结束时将IT置1，即转入中断响应周期。</li>
<li>进入IT后，将断点与PSW压入堆栈，然后关中断，最后形成中断处理程序的入口地址并送入PC。</li>
<li>IT一结束就切换到取指周期FT，即开始执行中断处理程序。</li>
</ul>
<blockquote>
<p>有关中断的内容将在以后的章节深入讨论。</p>
</blockquote>
<h3 id="436-dma周期"><a class="header" href="#436-dma周期">4.3.6 DMA周期</a></h3>
<p>在一条指令执行结束时查询有无DMA请求</p>
<ul>
<li>如有请求且CPU允许响应，则CPU与总线断开，将总线控制权交给DMA控制器，并转入DMA周期。</li>
<li>在DMAT中，CPU暂停工作，由DMA控制器接管系统总线，向总线发出有关地址码与控制信息，控制主存与外设接口之间的信息传送。</li>
<li>由于DMAT并不影响程序计数器PC的内容与有关现场，只是暂停执行程序，所以只要由DMAT转入FT，程序就将恢复执行。</li>
</ul>
<h3 id="437-键盘操作"><a class="header" href="#437-键盘操作">4.3.7 键盘操作</a></h3>
<p>模型机在加电或复位后，产生一个“复位信号”对全机进行初始化，使PC置0，然后进入取指周期FT。</p>
<ul>
<li>主存0号单元中存放的是一条无条件转移指令，它指向“操作系统”的入口。</li>
<li>机器进入系统状态后，可通过键盘输入各种命令信息，使机器进入所要求的工作状态。</li>
</ul>
<h2 id="44-微命令的综合与产生"><a class="header" href="#44-微命令的综合与产生">4.4 微命令的综合与产生</a></h2>
<p>在组合逻辑（硬连逻辑）控制器中</p>
<ul>
<li>微命令是由组合逻辑电路产生的。产生微命令的逻辑条件有工作周期名称、节拍序号、定时脉冲，以及操作码、寻址方式、寄存器号、PSW状态、中断请求、DMA请求等。</li>
<li>在给出全部指令的流程图和微操作时间表后，通过对它们进行综合分析，就可列出各个微命令的逻辑表达式。</li>
</ul>
<p>微命令的逻辑表达式都是“与-或”式的逻辑形态，各“与”项通常包括：指令操作码译码信号、寻址字段译码信号、工作周期状态、节拍、工作脉冲等。</p>
<p>例如：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">FT</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">MO</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.1056em;"></span><span class="mord">...</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的输出由不同指令（如FT和MOV）与控制信号（如<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span></span></span></span>等<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">）组合触发。</span></span></span></span><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">FT</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">MO</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">...</span></span></span></span><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">在特定状态</span></span></span></span>P<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">、周期</span></span></span></span>T_0<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">及指令条件下触发</span></span></span></span>CP_{MAR}$信号输出。</p>
<p>上述微命令的逻辑式反映出在什么情况下需发出某个微命令，将它们整理化简后就获得一组最终的逻辑表达式，可用组合逻辑门电路实现，也可用PLA门阵列实现。所有产生微命令的组合逻辑电路就构成了微操作信号发生器，如图3-20所示。</p>
<p><img src="assets/logic_map.png" alt="" /></p>
<h2 id="45-小结"><a class="header" href="#45-小结">4.5 小结</a></h2>
<p>组合逻辑控制方式</p>
<ul>
<li>优点：组合逻辑控制方式是用逻辑门电路产生微命令的，其速度主要取决于电路延迟，因此在高速计算机，如RISC处理器中，常采用这种速度较快的硬连控制方式。</li>
<li>缺点：在组合逻辑控制器中，产生微命令的门电路所需的逻辑形态很不规整，因此组合逻辑控制器的核心部分比较繁琐、零乱，设计效率较低，检查调试也比较困难。而且设计结果用印制电路板（硬连逻辑）固定下来以后，就很难再修改与扩展。</li>
</ul>
<p>解决上述问题的方法是采用微程序控制方式</p>
<ul>
<li>将程序技术引入到CPU的构成级，即像编制程序那样编制微命令序列，从而使设计规整化</li>
<li>另一方面，将存储结构引入CPU，取代组合逻辑的微操作信号发生器。也就是将微命令表示为二进制代码直接存入一个存储器中，只要修改所存储的代码即微命令信息，就可修改有关功能与执行方式。</li>
</ul>
<h1 id="5-微程序控制器原理"><a class="header" href="#5-微程序控制器原理">5. 微程序控制器原理</a></h1>
<h2 id="微程序控制概念"><a class="header" href="#微程序控制概念">微程序控制概念</a></h2>
<p>有些CPU采用微程序控制方式来产生微命令，相应的控制器称为微程序控制器。</p>
<h3 id="基本概念与术语"><a class="header" href="#基本概念与术语">基本概念与术语</a></h3>
<ol>
<li>微命令与微操作</li>
</ol>
<ul>
<li>
<p>微命令：构成控制信号序列的最小单位（例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等）微命令由控制器通过控制线向有关的部件发出。</p>
</li>
<li>
<p>微操作：微命令控制微操作的发生，微操作是微命令的具体实现。</p>
</li>
</ul>
<ol start="2">
<li>微指令与微周期</li>
</ol>
<ul>
<li>微指令</li>
</ul>
<p>若干微命令的组合，以编码形式存放在控制存储器的一个单元中，控制实现一步操作。一条微指令的功能就是给出完成指令某一步操作所需的微操作控制信息和后继微 指令地址信息。</p>
<p><img src="assets/little_instruction.png" alt="" /></p>
<ul>
<li>微周期</li>
</ul>
<p>通常指从控制存储器中读取一条微指令并执行相应的
微操作所需的时间。</p>
<ol start="3">
<li>微程序与微程序设计</li>
</ol>
<ul>
<li>微程序：一系列微指令的有序集合。</li>
<li>微程序设计：是将传统的程序设计方法运用到控制逻辑的设计中</li>
</ul>
<ol start="4">
<li>工作程序与微程序、主存储器与控制存储器</li>
</ol>
<ul>
<li>
<p>程序员所编制的工作程序以机器指令为单位存放在主存储器中，由于解决不同问题的工作程序中所包含的机器指令、数据及机器指令条数可能有所不同，要求主存单元内容是可以更新的，因此主存储器是可读可写的随机访问存储器。</p>
</li>
<li>
<p>而由机器设计者编制的微程序是以微指令为基本单位，在制作机器时用特殊方式将其写入控制存储器中，由于机器的指令系统是固定的，所以实现指令系统的微程序也是固定的，并且在CPU执行机器指令时，控制存储器只能被读出，不能写入，故控制存储器用只读存储器来实现。</p>
</li>
</ul>
<h3 id="微程序控制方式的基本思想"><a class="header" href="#微程序控制方式的基本思想">微程序控制方式的基本思想</a></h3>
<ul>
<li>
<p>将机器指令分解为基本的微命令序列，用二进制代码表示这些微命令，并编成微指令，多条微指令再形成微程序。</p>
</li>
<li>
<p>每条机器指令对应一段微程序，在制造CPU时固化在CPU中的一个控制存储器（CM）中。</p>
</li>
<li>
<p>当执行一条机器指令时，CPU依次从控制存储器CM中取微指令，从而产生微命令序列。</p>
</li>
<li>
<p>一条微指令包含的微命令，控制实现一步（一个节拍）操作；</p>
</li>
<li>
<p>若干条微指令组成的一小段微程序解释执行一条机器指令。CM中的微程序能解释执行整个指令系统的所有机器指令。</p>
</li>
<li>
<p>这种将微命令以代码形式存储起来的做法就是前面提到的存储控制逻辑，而微指令序列设计方法可以借助于一般的程序设计技术实现。</p>
</li>
</ul>
<p><img src="assets/little_control_principle.png" alt="" /></p>
<p>微程序控制器的核心是控制存储器CM，用它存放各条指令对应的微程序。</p>
<ul>
<li>CM可用只读存储器ROM构成。</li>
<li>若采用可擦除可编程只读存储器EPROM作为CM，则有利于微程序的修改和动态微程序设计。</li>
</ul>
<p>控制存储器CM中的一行表示存放的一条微指令</p>
<ul>
<li>列线输出微指令代码。</li>
<li>行列交叉处有黑点者表示该位信息为1，行列交叉处无黑点者表示该位信息为0。</li>
</ul>
<p>微指令寄存器存放从CM中读出的微指令，它包含两大部分：</p>
<ul>
<li>微操作控制字段（微命令字段）: 微命令字段可直接按位或通过译码提供微命令</li>
<li>顺序控制字段（微地址字段）: 顺序控制字段用于控制产生下一条微指令地址</li>
</ul>
<h3 id="微程序执行过程的描述"><a class="header" href="#微程序执行过程的描述">微程序执行过程的描述</a></h3>
<p>机器所有指令对应的微程序放在控制存储器CM中，其一条机器指令对应的微程序执行过程可描述如下：</p>
<ol>
<li>根据微地址寄存器的内容（通常为0或1），从CM的0号（或1号）单元中读出一条“取机器指令”微指令，送到微指令寄存器，这是一条公用微指令。</li>
</ol>
<blockquote>
<p>该微指令的微命令字段产生有关控制信号，完成从存储器中取出机器指令送往指令寄存器IR，并修改程序计数器PC的内容。</p>
</blockquote>
<ol start="2">
<li>
<p>IR中机器指令的操作码通过微地址形成电路形成这条指令对应的微程序入口地址，并送入微地址寄存器中。</p>
</li>
<li>
<p>根据微地址寄存器中的微地址从CM中取出对应微程序的一条微指令，其微命令字段产生一组微命令控制有关操作；由顺序控制字段形成下一条微指令地址，送入微地址寄存器。重复步骤3直到该机器指令的微程序执行完。</p>
</li>
<li>
<p>执行完一条机器指令的微程序后，返回到CM的0号（或1号）微地址单元，重复步骤1，读取“取机器指令”微指令，以便取下一条机器指令。</p>
</li>
</ol>
<h2 id="微指令编码方式"><a class="header" href="#微指令编码方式">微指令编码方式</a></h2>
<ol>
<li>直接控制编码（不译码法）</li>
</ol>
<p>微指令的微命令字段中每一位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0就可以了。因此，微命令的产生不需译码。</p>
<p>这种编码的优点是简单、直观、执行速度快、操作并行性好，其缺点是微指令字长过长。</p>
<ol start="2">
<li>分段直接译码法</li>
</ol>
<ul>
<li>互斥性微命令：在同一微周期中不能同时出现的微命令</li>
</ul>
<blockquote>
<p>例如，控制ALU操作的各种微命令ADD、SUB、 AND等是不能同时出现的，即在一条微指令中只能出现一种运算操作。 又如主存储器的读命令与写命令也不能同时出现。</p>
</blockquote>
<ul>
<li>相容性微命令：在同一微周期中可以同时出现的微命令</li>
</ul>
<p>如果将微指令的微命令字段分成若干小字段，把相斥性微命令组合在同一字段中，而把相容性微命令组合在不同的字段中。每个字段独立编码，每种编码代表一个微命令，且各字段编码含义单独定义，与其他字段无关，这就称为分段直接编译法</p>
<p>分段直接编译法可以缩短微指令字长，同时又保持一定的并行控制能力。</p>
<p>常见的分段方法有两种：</p>
<ul>
<li>将机器的全部微命令中相斥性微命令尽可能编入同一字段，而不管它们是否属于同一类操作。</li>
<li>将同类操作（或控制同一部件的操作）中相斥性微命令划分在一个字段内</li>
</ul>
<ol start="3">
<li>分段间接译码法</li>
</ol>
<p>一个字段的含义不仅决定于本字段编码，还兼由其他字段来解释，以便使用较少的信息位表示更多的微命令。</p>
<p>属于这种编码方法的常见形式有以下两种：</p>
<ul>
<li>可解释的字段译码</li>
</ul>
<p>例如微指令中A字段（高3位）的含义兼由第0位来解释，当第0位为1时，字段A表示某一类操作中的8个相斥性微命令；第0位为0时，字段A表示另一类操作中的8个微命令。因此，第0位与A字段总共可表示16种微命令。</p>
<p>这种方法可将属于不同类型的操作归并为一个字段。当然解释位也可扩展为一个字段或某一个状态触发器。</p>
<ul>
<li>分类编译</li>
</ul>
<p>按微指令的功能将其分成几类，分别安排各类微指令的格式和编码，由某一字段或状态触发器来控制和区别。例如，可分为ALU操作类、I/O操作类等。</p>
<ol start="4">
<li>常数源字段E的设置</li>
</ol>
<p>在微指令中，一般设有一个常数源字段E，就如同机器指令中的立即操作数一样，用来提供微指令所使用的常数（由设计者填写）</p>
<ul>
<li>如提供计数器初值，通用寄存器地址，转移地址等。</li>
<li>字段E也可用来参与其他控制字段的间接编码，以减少微指令字长，增加微指令的灵活性。</li>
</ul>
<p>字段E在微指令中的形式为</p>
<p><img src="assets/little_yr_operator.png" alt="" /></p>
<h2 id="微程序的顺序控制方式"><a class="header" href="#微程序的顺序控制方式">微程序的顺序控制方式</a></h2>
<h3 id="微程序入口地址的形成"><a class="header" href="#微程序入口地址的形成">微程序入口地址的形成</a></h3>
<p>由于每条机器指令都需要取指操作，所以将取指操作编制成一段公用微程序，通常安排在控制存储器的0号或1号单元开始的一段CM空间。</p>
<p>每一条机器指令对应着一段微程序，其入口就是初始微地址。首先由“取机器指令”微程序取出一条机器指令到IR中，然后根据机器指令操作码转换成该指令对应的微程序入口地址。</p>
<p>这是一种多分支（或多路转移）的情况，常用以下三种方式形成入口地址:</p>
<ol>
<li>当操作码的位数与位置固定时，可直接使操作码与入口地址码的部分相对应。</li>
</ol>
<p>例如，操作码为P，则入口地址为000P，这样控制存储器0页的一些单元地址被安排作为各段微程序入口地址，再通过单元内的无条件转移微指令与各自的后续微程序相连接。</p>
<ol start="2">
<li>当每类指令中的操作码位数与位置固定，而各类指令之间的操作码与位置不固定时，可采用分级转移的方式。</li>
</ol>
<p>例如，操作码为P，则入口地址为000P，这样控制存储器0页的一些单元地址被安排作为各段微程序入口地址，再通过单元内的无条件转移微指令与各自的后续微程序相连接。</p>
<ol start="3">
<li>当机器指令的操作码位数和位置都不固定时，通常可以采用PLA电路将每条指令的操作码翻译成对应的微程序入口地址，也可以采用PROM（可编程只读存储器）实现转移，将指令操作码作为PROM的地址输入，其对应的PROM单元内容即为该机器指令的微程序入口地址。</li>
</ol>
<h3 id="后继地址的形成"><a class="header" href="#后继地址的形成">后继地址的形成</a></h3>
<p>转移到一条机器指令对应的微程序入口地址后，就开始执行微程序，这时每条微指令执行完毕时，需根据其中的顺序控制字段的要求形成后继微指令地址。</p>
<p>形成后继微指令地址的方式很多，总的来说，可分为两大基本类型。</p>
<ol>
<li>增量方式（顺序-转移型微地址）</li>
</ol>
<p>在微程序控制器中，可设置一个微程序计数器μPC</p>
<ul>
<li>在顺序执行微指令时，后继微指令地址由当前微地址（即μPC内容）加上一个增量（通常为1）来形成</li>
<li>遇到转移时，由微指令给出转移微地址，使微程序按新的顺序执行。</li>
</ul>
<p><img src="assets/little_next_addr_add.png" alt="" />
增量方式可能有以下形态：</p>
<ul>
<li>顺序执行: 由转移方式字段指明。此时，μPC加1给出后继微地址。为减少微指令长度，可将转移地址字段暂作为微命令字段。</li>
<li>无条件转移: 由转移方式字段指明。转移地址字段提供微地址的全部；或给出低位部分，高位与当前微地址相同。</li>
<li>条件转移: 由转移方式字段指明判别条件，转移地址字段指明转移成功的去向，不成功则顺序执行。</li>
</ul>
<blockquote>
<p>机器中可作为转移判别的条件有多个，但每次只能选择一个测试判别源，所以一次只允许两路分支。</p>
</blockquote>
<ul>
<li>转微子程序: 由转移方式字段指明。微子程序入口地址由转移地址字段（或与μPC组合）提供。在转微子程序之前，要将该条微指令的下一条微指令地址（μPC+1）送入返回地址寄存器中，以备返回微主程序。</li>
<li>微子程序返回: 由转移方式字段指明。此时将返回地址寄存器内容作为后继微地址送入μPC中，从而实现从微子程序返回到原来的微主程序。此时，可将转移地址字段暂用作微命令字段。</li>
</ul>
<p>缺点是这种方式不利于解决两路以上的并行微程序转移，因而不利于提高微程序的执行速度。</p>
<ol start="2">
<li>断定方式</li>
</ol>
<p>所谓断定型微地址是指后继微地址可由微程序设计者指定，或者根据微指令所规定的测试结果直接决定后继微地址的全部或部分值。</p>
<p><img src="assets/little_instruction_next_drdk.png" alt="" /></p>
<ul>
<li>非测试段: 可由设计者直接给定，通常是后继微地址的高位部分，用以指定后继微指令在某个区域内。</li>
<li>测试段: 根据有关状态的测试结果确定其地址值，占后继微地址的低位部分。这相当于在指定区域内断定具体的分支。所依据的测试状态可能是指定的开关状态、指令操作码、状态字等。</li>
</ul>
<p>事实上，在多数机器的微指令系统中，增量方式和断定方式是混合使用的</p>
<h2 id="微指令格式"><a class="header" href="#微指令格式">微指令格式</a></h2>
<h3 id="水平型微指令"><a class="header" href="#水平型微指令">水平型微指令</a></h3>
<p>特征：</p>
<ul>
<li>微指令较长，通常为几十位到上百位左右。如VAX-11/780的微指令字长96位，总之，机器规模越大、速度越快，其微指令字越长。</li>
<li>微指令中的微操作具有高度并行性，这种并行操作能力是以数据通路中各部件间的并行操作结构为基础的。例如执行一条水平型微指令就能控制信息从若干源部件同时传送到若干目的部件。</li>
<li>微指令编码简单，减少微命令的译码时间。</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：执行效率高、灵活性好，微程序条数少，因此广泛应用于速度较快的机器中。</li>
<li>缺点：其微指令字较长，复杂程度高，难以实现微程序设计自动化。</li>
</ul>
<h3 id="垂直型微指令"><a class="header" href="#垂直型微指令">垂直型微指令</a></h3>
<p>特征是微指令较短，微指令的并行操作能力有限，一般一条微指令只能控制数据通路的一两种信息传送操作。</p>
<p>通常每条微指令都有一个微操作码字段、源地址和目的地址及某些扩展操作字段。</p>
<ul>
<li>优点：便于编制微程序。由此编制的微程序规整、直观、有利于设计的自动化。</li>
<li>缺点：但垂直型微指令不能充分利用数据通路的并行操作能力，微程序长，因而效率低。</li>
</ul>
<h2 id="5-模型机微程序指令格式"><a class="header" href="#5-模型机微程序指令格式">5. 模型机微程序指令格式</a></h2>
<p>微指令的微操作控制字段是按操作性质划分字段，对于一些零乱的微操作可归入辅助操作一组。</p>
<p>由于模型机CPU内部采用的是单总线结构，每次只能完成一种基本的数据通路传送操作，如PC→MAR，这表明其微指令格式应偏向于垂直型；但由于微指令控制字段的设置是面向微命令的，因此又具有水平型微指令的某些特点，故可以看成是混合型微指令。</p>
<p>对于微程序的顺序控制方式，在模型机中采用增量方式和断定方式相结合的方案，当微程序顺序执行、无条件和条件转移，以及转微子程序与返回时，用增量方式形成后继微地址；当微程序需要多路转移时，用断定方式形成相应的各路转移微地址。</p>
<p><img src="assets/little_instruction_model.png" alt="" /></p>
<ol>
<li>基本数据通路控制字段</li>
</ol>
<ul>
<li>$F_{OUT}<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">：寄存器的输出控制字段</span><span class="mord">−</span></span></span></span>F_{ALU}<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">：</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">LU</span><span class="mord cjk_fallback">的操作与</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mord cjk_fallback">的移位控制字段</span><span class="mord">−</span></span></span></span>F_{CP}<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">：寄存器的同步打入控制字段</span><span class="mord">−</span></span></span></span>F_{PC}<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">：</span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mord cjk_fallback">的操作控制字段</span><span class="mord">2.</span><span class="mord cjk_fallback">访存控制字段</span><span class="mord">−</span></span></span></span>F_{EMAR}<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">：</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">输出控制字段</span><span class="mord">−</span></span></span></span>F_{R/W}<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">：主存读写与</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">开支字段</span><span class="mord">3.</span><span class="mord cjk_fallback">辅助控制字段</span><span class="mord">−</span></span></span></span>F_{ST}<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">：辅助操作控制字段</span><span class="mord">4.</span><span class="mord cjk_fallback">顺序控制字段</span><span class="mord">−</span></span></span></span>JC$：转移方式字段，用以选择后继指令地址的形成方式</li>
</ul>
<h1 id="精简指令计算机risc"><a class="header" href="#精简指令计算机risc">精简指令计算机(RISC)</a></h1>
<ol>
<li>RISC和CISC</li>
</ol>
<p>统的CISC设计思想并不利于提高计算机的速度。而且复杂的指令系统必然增加硬件实现的复杂性，从而使计算机的研制周期长、投资大。因此人们开始研究指令系统的合理性问题。对CISC指令系统运行的统计分析表明，各种指令的使用频率相差悬殊，最常用的是一些比较简单的指令，仅占指令总数的20%，但在程序中出现的频率却占80%。</p>
<ol start="2">
<li>特点</li>
</ol>
<p>精简指令系统计算机的着眼点不是简单地放在简化指令系统上，而是通过简化指令使计算机的结构更加简单合理，更易于流水线的实现，从而提高处理速度。</p>
<ul>
<li>面向寄存器的结构</li>
</ul>
<p>所有运算使用的数据都来自寄存器，运算结果也都写入寄存器。通常CPU内应设置大量的通用寄存器，以减少访问主存储器。</p>
<ul>
<li>采用LOAD/STORE结构</li>
</ul>
<p>能够访问主存储器的只有两种指令：从存储器读取数据到寄存器的LOAD（取数）指令和从寄存器向存储器写数据的STORE（存数）指令。</p>
<ul>
<li>较少的指令数和寻址方式</li>
</ul>
<p>选取使用频率最高的一些简单指令，以及很有用但不复杂的指令，可简化控制部件。选用简单的寻址方式，有利于减少指令的执行周期数。</p>
<ul>
<li>所有指令长度相同</li>
</ul>
<p>指令长度相同，指令格式固定简单，可简化指令的译码逻辑，并 有利于提高流水线的执行效率。为了便于编译的优化，常采用三地址 指令格式。</p>
<ul>
<li>硬布线控制逻辑</li>
</ul>
<p>由于指令系统的精简，控制部件可由组合逻辑实现，不用或少用微程序控制，这样可使控制部件的速度大大提高。</p>
<ul>
<li>注重编译的优化</li>
</ul>
<p>RISC指令系统的简化，必然使编译生成的代码长度增长。但通过编译优化技术，将编译初步生成的代码重新组织，调度指令的执行次序，以充分发挥内部操作的并行性，从而进一步提高流水线的执行效率。</p>
<ol start="3">
<li>超标量与超流水线概念</li>
</ol>
<p>在一个单执行部件的RISC中，多数指令是单周期执行，但仍有少数指令需要一个周期以上的执行时间。因此，其每条指令执行的平均周期数CPI接近于1，但不能小于1。</p>
<p>要使CPI小于1</p>
<ul>
<li>
<p>超标量结构: 将RISC设计成具有多个执行部件的结构，同时在每一个周期内允许发出多条指令，并调度多条指令在不同的执行部件中并行执行操作</p>
</li>
<li>
<p>超标量结构: 将流水线的每个节拍分成3个或4个小节拍，每个小节拍执行一个操作，便有可能在取出第i 条指令后，相隔一个小节拍，就取出第i +1条指令，这样就可能在一个流水线的节拍内，取出3条或4条指令，送入流水线去执行，从而使CPI小于1</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<p>第四章、指令系统层</p>
<p>计算机的基本工作主要体现为执行指令。</p>
<p>指令系统(指令集)：指令格式、寻址方式、指令类型与功能。</p>
<p>相对微体系结构层，是一个抽象的层次，它是硬件和软件之间的接口（硬件和编译器都能理解的语言）</p>
<p>其主要特征就是指令系统的两种状态</p>
<ul>
<li>内核模式</li>
<li>用户模式</li>
</ul>
<p>本章将以80x86为背景讨论指令系统层，介绍</p>
<ul>
<li>80x86系列cpu的结构</li>
<li>80x86主存储器和寄存器</li>
<li>80x86指令系统</li>
</ul>
<ul>
<li><a href="4.instruction_system.html#1-80x86cpu">1. 80x86CPU</a>
<ul>
<li><a href="4.instruction_system.html#11-80868088cpu">1.1 8086/8088cpu</a>
<ul>
<li><a href="4.instruction_system.html#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%BB%93%E6%9E%84">指令流水线结构</a></li>
<li><a href="4.instruction_system.html#%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84">内部架构</a></li>
<li><a href="4.instruction_system.html#8086%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90">8086主存地址的形成</a>
<ul>
<li><a href="4.instruction_system.html#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="4.instruction_system.html#12-8038680486cpu">1.2 80386/80486cpu</a></li>
<li><a href="4.instruction_system.html#3-pentium%E7%B3%BB%E5%88%97cpu">3. Pentium系列cpu</a>
<ul>
<li><a href="4.instruction_system.html#pentium-cpu">Pentium cpu</a></li>
<li><a href="4.instruction_system.html#pentium-pro-cpu">Pentium Pro cpu</a></li>
<li><a href="4.instruction_system.html#pentium2-cpu">Pentium2 cpu</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="4.instruction_system.html#2-80x86-cpu%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8">2. 80x86 cpu的寄存器和主存储器</a>
<ul>
<li><a href="4.instruction_system.html#21-80x86-cpu%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8">2.1 80x86 cpu的寄存器</a>
<ul>
<li><a href="4.instruction_system.html#211-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84">2.1.1 基本结构寄存器组</a>
<ul>
<li><a href="4.instruction_system.html#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8">通用寄存器</a></li>
<li><a href="4.instruction_system.html#%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8">指令指针寄存器和标志寄存器</a></li>
</ul>
</li>
<li><a href="4.instruction_system.html#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8-1">段寄存器</a></li>
<li><a href="4.instruction_system.html#212-%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%AF%84%E5%AD%98%E5%99%A8">2.1.2 系统级寄存器</a></li>
</ul>
</li>
<li><a href="4.instruction_system.html#22-80x86%E7%9A%84%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8">2.2 80x86的主存储器</a>
<ul>
<li><a href="4.instruction_system.html#221-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E7%9A%84%E5%9C%B0%E5%9D%80%E5%92%8C%E5%86%85%E5%AE%B9">2.2.1 存储单元的地址和内容</a></li>
<li><a href="4.instruction_system.html#222-%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AF%BB%E5%9D%80">2.2.2 实模式存储寻址</a></li>
<li><a href="4.instruction_system.html#223-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%BB%E5%9D%80">2.2.3 保护模式存储器寻址</a></li>
<li><a href="4.instruction_system.html#224-80x86%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9D%A5%E6%BA%90">2.2.4 80x86逻辑地址的来源</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="4.instruction_system.html#3-80x86cpu%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F">3. 80x86cpu的指令系统</a>
<ul>
<li><a href="4.instruction_system.html#31-80x86%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">3.1 80x86寻址方式</a>
<ul>
<li><a href="4.instruction_system.html#311-%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">3.1.1 立即寻址方式和寄存器寻址方式</a></li>
<li><a href="4.instruction_system.html#312-%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%BB%E5%9D%80">3.1.2 存储器寻址</a>
<ul>
<li><a href="4.instruction_system.html#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">直接寻址方式</a></li>
<li><a href="4.instruction_system.html#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80">寄存器间接寻址</a></li>
<li><a href="4.instruction_system.html#%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80">寄存器相对寻址</a></li>
<li><a href="4.instruction_system.html#%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">基址变址寻址方式</a></li>
<li><a href="4.instruction_system.html#%E6%AF%94%E4%BE%8B%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">比例变址寻址方式</a></li>
<li><a href="4.instruction_system.html#%E5%9F%BA%E5%9D%80%E6%AF%94%E4%BE%8B%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">基址比例变址寻址方式</a></li>
</ul>
</li>
<li><a href="4.instruction_system.html#313-%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">3.1.3 串操作寻址方式</a></li>
</ul>
</li>
<li><a href="4.instruction_system.html#32-80x86cpu%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F">3.2 80x86cpu指令系统</a>
<ul>
<li><a href="4.instruction_system.html#%E4%BC%A0%E9%80%81%E7%B1%BB%E6%8C%87%E4%BB%A4">传送类指令</a>
<ul>
<li><a href="4.instruction_system.html#mov">MOV</a></li>
<li><a href="4.instruction_system.html#pushpop">PUSH/POP</a></li>
<li><a href="4.instruction_system.html#xchg">XCHG</a></li>
<li><a href="4.instruction_system.html#%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E7%B1%BB">地址传送类</a></li>
<li><a href="4.instruction_system.html#%E6%A0%87%E5%BF%97%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">标志传送指令</a></li>
<li><a href="4.instruction_system.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4">类型转换指令</a></li>
</ul>
</li>
<li><a href="4.instruction_system.html#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4">算数运算类指令</a></li>
<li><a href="4.instruction_system.html#%E9%80%BB%E8%BE%91%E7%B1%BB%E6%8C%87%E4%BB%A4">逻辑类指令</a></li>
<li><a href="4.instruction_system.html#%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">串操作指令</a>
<ul>
<li><a href="4.instruction_system.html#%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">串传送指令</a></li>
</ul>
</li>
<li><a href="4.instruction_system.html#%E7%A8%8B%E5%BA%8F%E8%BD%AC%E7%A7%BB%E7%B1%BB%E6%8C%87%E4%BB%A4">程序转移类指令</a>
<ul>
<li><a href="4.instruction_system.html#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB">无条件转移</a></li>
<li><a href="4.instruction_system.html#%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB">条件转移</a></li>
<li><a href="4.instruction_system.html#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">循环控制</a></li>
</ul>
</li>
<li><a href="4.instruction_system.html#%E5%A4%84%E7%90%86%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%B1%BB%E6%8C%87%E4%BB%A4">处理机控制类指令</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="1-80x86cpu"><a class="header" href="#1-80x86cpu">1. 80x86CPU</a></h1>
<p>目前，主要的CPU架构有四种</p>
<ul>
<li>ARM</li>
<li>X86</li>
<li>MIPS Power</li>
<li>ALPHA<br />
目前，在移动芯片领域，ARM架构的芯片占据了90%以上的市场份额，在服务器CPU市场上，英特尔X86处理器占据超过90%市场份额</li>
</ul>
<p>80x86是Intel首先开发制造的一种微处理器体系结构的泛称</p>
<p><img src="./assets/all80x86cpu.png" alt="80x86CPU概括" /></p>
<h2 id="11-80868088cpu"><a class="header" href="#11-80868088cpu">1.1 8086/8088cpu</a></h2>
<ul>
<li>
<p>8086
16位微处理器，即8086CPU的内外数据总线为16位，⼀个总线周期可以传送⼀个字（16位）数据。</p>
</li>
<li>
<p>8088
准16位微处理器,即8088CPU的内部DB为16位，外部DB为8位，⼀个总线周期只能传送⼀个字节。</p>
</li>
</ul>
<p>8086/8088两者的内部结构基本上相同，地址引脚均为20位，可寻址1MB主存空间。指令系统完全相同，在软件上是完全兼容的。</p>
<h3 id="指令流水线结构"><a class="header" href="#指令流水线结构">指令流水线结构</a></h3>
<ul>
<li>BIU总线接口部件: 取指令（或取操作数）</li>
<li>EU执行部件: 执行指令<br />
当EU执行某条指令时，BIU同时完成从主存中预取后继指令，两个部件并行地工作。</li>
</ul>
<h3 id="内部架构"><a class="header" href="#内部架构">内部架构</a></h3>
<p><img src="assets/2024-11-20-13-51-35.png" alt="8086cpu内部架构" /></p>
<ol>
<li>执行部件EU</li>
</ol>
<p>包括：</p>
<ul>
<li>一个ALU（16位）</li>
<li>一组通用寄存器（16位）</li>
<li>暂存器</li>
<li>标志寄存器（16位）</li>
<li>EU控制器</li>
</ul>
<p>功能：</p>
<ul>
<li>从指令队列中取出指令代码，由EU控制器进⾏译码后产⽣对应的控制信号到各部件以完成指令规定的操作。</li>
<li>对操作数进⾏算术和逻辑运算，并将运算结果的特征状态存放在标志寄存器中。</li>
<li>由于EU不直接与系统总线连接，因此当需要与主存储器或I/O端⼝传送数据时，EU向BIU发出命令，并提供给BIU 16位有效地址与传送的数据。</li>
</ul>
<ol start="2">
<li>总线接口部件BIU</li>
</ol>
<p>包括</p>
<ul>
<li>一组段寄存器</li>
<li>指令指针</li>
<li>指令队列（6字节，8088是4字节）</li>
<li>总线地址形成部件（20位，地址加法器）</li>
<li>总线控制逻辑</li>
</ul>
<p>功能：完成CPU与主存储器或I/O端口之间的信息传送</p>
<ul>
<li>从主存取出指令送到指令队列中排队</li>
<li>从主存或I/O端⼝取操作数或存放运算结果</li>
<li>计算并形成访问主存的20位物理地址</li>
</ul>
<h3 id="8086主存地址的形成"><a class="header" href="#8086主存地址的形成">8086主存地址的形成</a></h3>
<p>8086cpu内部寄存器即数据线均为16位，可访问存储器空间64K，实际主存地址20位，寻址空间1M。16位字长的机器如何提供20位地址？</p>
<p>解决办法：分段：将1M空间分成64K一段</p>
<ol>
<li>地址概念</li>
</ol>
<ul>
<li>物理地址：每个存储单元的唯一的20位地址</li>
<li>段基址
<ul>
<li>段起始地址，XXXX0H</li>
<li>段起始地址的20位后4位为零，所以只需要表示前16位即可，前16位地址称为段基址</li>
<li>段基址放在段寄存器中</li>
</ul>
</li>
<li>偏移地址：段内相对于段起始地址的偏移量</li>
<li>逻辑地址：
<ul>
<li>由段基址和逻辑地址组成，记作<code>段基址:偏移地址</code></li>
</ul>
</li>
</ul>
<p>物理地址与逻辑地址的转换
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">物理地址</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">段基址</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">偏移地址</span></span></span></span></span></p>
<p><img src="assets/2024-11-20-13-57-58.png" alt="8086主存地址的形成" /></p>
<h4 id="段寄存器"><a class="header" href="#段寄存器">段寄存器</a></h4>
<p>汇编语言源程序是分段结构（代码段、数据段...）</p>
<p>在8086～80286中，有4个专门存放段基值的寄存器，称为段寄存器。</p>
<blockquote>
<p>每个段寄存器可以确定一个段的起始地址</p>
</blockquote>
<ol>
<li>段寄存器的种类</li>
</ol>
<ul>
<li>CS: 代码段
存放当前正在运行的程序</li>
<li>DS: 数据段
存放当前运行程序所用的数据</li>
<li>SS: 堆栈段
定义了堆栈的所在区域</li>
<li>ES: 附加段
附加的数据段，一个辅助的数据区，也是串处理指令的目的操作数存放区</li>
</ul>
<blockquote>
<p>在80386及其后继的80x86中，除上述4个段寄存器外，又增加了2个段寄存器FS和GS，它们也是附加的数据段寄存器</p>
</blockquote>
<ol start="2">
<li>段寄存器与存放偏移地址的寄存器之间的默认组合关系</li>
</ol>
<ul>
<li>8086/8088,80286</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>段寄存器</th><th>偏移地址</th></tr></thead><tbody>
<tr><td>CS</td><td>IP</td></tr>
<tr><td>SS</td><td>SP或BP</td></tr>
<tr><td>DS</td><td>BX,SI,DI或一个16位数</td></tr>
<tr><td>ES</td><td>DI(用于串指令)</td></tr>
</tbody></table>
</div>
<ul>
<li>80386及后续机型</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>段寄存器</th><th>偏移地址</th></tr></thead><tbody>
<tr><td>CS</td><td>IP</td></tr>
<tr><td>SS</td><td>SP或BP</td></tr>
<tr><td>DS</td><td>BX,SI,DI或一个16位数</td></tr>
<tr><td>ES</td><td>EAX,EBX,ECX,EDX,EDI,ESI,一个8位或32位数</td></tr>
<tr><td>FS</td><td>无默认</td></tr>
<tr><td>GS</td><td>无默认</td></tr>
</tbody></table>
</div>
<h2 id="12-8038680486cpu"><a class="header" href="#12-8038680486cpu">1.2 80386/80486cpu</a></h2>
<ol>
<li>80386</li>
</ol>
<ul>
<li>32位地址，可直接寻址的物理存储空间为4 GB。</li>
<li>具有片内存储管理部件，使虚拟存储空间（逻辑地址空间）可达64 TB。</li>
<li>字长32位，系统总线的数据通路宽度32位。</li>
<li>采用多级流水线结构(多独立部件，重叠执行)。</li>
<li>平均运算速度约为4 MIPS（4百万指令每秒）。</li>
</ul>
<ol start="2">
<li>80486</li>
</ol>
<p>80486相当于一个增强型的80386、一个增强型的80387数值协处理器（浮点部件FPU）、一个8 KB的高速缓存（Cache）的集成，基本上沿用了80386的体系结构,5级流水</p>
<p><img src="assets/2024-11-20-17-51-59.png" alt="80486cpu结构" /></p>
<ul>
<li>
<p>总线接口部件BIU:</p>
<ul>
<li>包含
<ul>
<li>地址驱动器</li>
<li>数据收发器</li>
<li>总线控制器</li>
</ul>
</li>
<li>功能:
<ul>
<li>CPU与存储器及I/O设备之间的高速接口</li>
<li>当取指令、取数据或写数据、响应分页部件或分段部件请求时，能有效地满足CPU对系统总线的传送要求。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>指令部件</p>
<ul>
<li>包含
<ul>
<li>指令预取部件</li>
<li>指令译码部件</li>
<li>产生微命令的控制部件</li>
<li>高速缓存Cache。</li>
</ul>
</li>
<li>功能:
<ul>
<li>完成预取指令</li>
<li>分析指令</li>
<li>然后产生指令所需的微命令去控制相应部件操作。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>执行部件</p>
<ul>
<li>数据部件: 执行控制部件所指定的数据操作,包括:
<ul>
<li>通用寄存器</li>
<li>一个有乘除功能的ALU</li>
<li>一个64位的桶形移位器</li>
</ul>
</li>
<li>浮点部件FPU
<ul>
<li>浮点部件FPU</li>
<li>浮点寄存器组</li>
</ul>
<blockquote>
<p>由于浮点部件FPU和浮点寄存器组集成在80486芯片内，缩短了FPU与处理器各部件之间的距离，因此FPU的执行速度比80386和80387组成的系统快3倍。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>存储器管理部件MMU</p>
<ul>
<li>将存储器按段来组织，以适应用户程序的逻辑结构，段的大小可变，最大可达到4 GB。</li>
<li>针对主存物理空间的组织，又将存储器划分为页，每页大小均为4 KB。</li>
<li>存储器管理部件设置了分段部件与分页部件
<ul>
<li>分段部件按控制部件的要求计算有效地址，并且将逻辑地址（由段基值和偏移地址组成）转换成线性地址，即：线性地址=段基址+有效地址（即偏移地址）</li>
<li>分页部件通过页变换，将来自分段部件或指令预取部件的线性地址转换成主存的物理地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上述9个部件可以独立操作，也能与其他部件并行工作。在取指令和执行指令的过程中，每个部件都完成一部分功能，因此80486可以同时对不同指令进行操作。</p>
<p>80486具有5级流水线，使不同指令的操作重叠程度更高，从而允许一些常用指令在一个时钟周期内完成。</p>
<blockquote>
<p>尽管这些指令的读取、译码和执行实际上占用了多个时钟周期，但由于这些指令与其他指令的译码和执行相重叠，因此平均每条指令的执行时间只占一个时钟周期。</p>
</blockquote>
<h2 id="3-pentium系列cpu"><a class="header" href="#3-pentium系列cpu">3. Pentium系列cpu</a></h2>
<h3 id="pentium-cpu"><a class="header" href="#pentium-cpu">Pentium cpu</a></h3>
<p>Pentium CPU是第一个实现系统管理方式的高性能微处理器，它能很好地实现PC机系统的能耗与安全管理。</p>
<p>Pentium CPU是Intel 80x86系列微处理器的第五代产品，其性能比它的前一代产品又有较大的提高，但它仍保持与Intel 8086、80286、80386、80486兼容。</p>
<p><img src="assets/2024-11-20-18-08-24.png" alt="Pentium cpu的功能结构" /></p>
<ol start="0">
<li>
<p>64位数据总线</p>
</li>
<li>
<p>超标量体系</p>
</li>
</ol>
<ul>
<li>三条指令执行流水线
<ul>
<li>两条独立的整数指令流水线（U流水线和V流水线）</li>
<li>一条浮点指令流水线</li>
</ul>
</li>
</ul>
<p>意味着每条流水线拥有</p>
<ul>
<li>独立的算数逻辑运算部件</li>
<li>地址生成逻辑</li>
<li>高数数据缓存接口</li>
</ul>
<blockquote>
<p>一个时钟周期执行两条简单指令，比相同频率下的80486性能提高1倍</p>
</blockquote>
<ol start="2">
<li>浮点指令流水线与浮点指令部件</li>
</ol>
<p>浮点指令流水线具有8级，U流水线的扩充。</p>
<ul>
<li>U流水线的前4级准备一条浮点指令，浮点部件中的后4级执行浮点运算操作并报错。</li>
<li>浮点指令（加、减、除）采用专用硬件电路，这比相同频率下的80486浮点处理性能提高了4倍。</li>
</ul>
<ol start="3">
<li>指令转移预测指令</li>
</ol>
<p>小型1KB高速缓存（称为转移目标缓冲器BTB）</p>
<ul>
<li>记录正在执行的程序最近所发生的几次转移</li>
<li>预示很可能会引向何处</li>
<li>进入流水线的新指令与有关转移信息进行比较
<ul>
<li>多数预测是正确的</li>
<li>若错误，重新取指令。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>数据和指令高数缓存</li>
</ol>
<p>两个超高速缓冲存储器Cache</p>
<ul>
<li>8KB的数据Cache</li>
<li>8KB的指令Cache<br />
并行操作。减少指令预取和数据操作之间冲突，提高微处理器的信息存取速度</li>
</ul>
<h3 id="pentium-pro-cpu"><a class="header" href="#pentium-pro-cpu">Pentium Pro cpu</a></h3>
<p>Pentium Pro CPU即P6，中文名称为高能奔腾处理器，适用32位操作系统</p>
<ul>
<li>三路发布超标量微结构，14级超流水线，使一个时钟周期内可同时执行三条简单指令。</li>
<li>5个并行处理单元
<ul>
<li>两个整数运算部件</li>
<li>一个装入部件</li>
<li>一个存储部件</li>
<li>一个浮点运算部件（FPU）。</li>
</ul>
</li>
<li>8KB两路组相关指令高速缓存，8KB四路组相关数据高速缓存。</li>
<li>专用全速总线上的256 KB SRAM使二级高速缓存与微处理器紧密相联。</li>
<li>事务处理I/O总线和非封锁高速缓存分级结构。</li>
<li>乱序执行，动态分支预测和推理执行。</li>
</ul>
<h3 id="pentium2-cpu"><a class="header" href="#pentium2-cpu">Pentium2 cpu</a></h3>
<ol>
<li>概述</li>
</ol>
<p>PentiumⅡ（PⅡ）CPU采用了与Pentium Pro CPU相同的核心结构。同时，增加了对多媒体的支持和对16位代码优化的特性，它能够同时处理两条MMX多媒体指令。</p>
<ul>
<li>双重独立总线DIB体系结构，能同时使用具有纠错功能的64位系统总线和具有可选纠错功能的64位Cache总线。</li>
<li>多重跳转分支预测。</li>
<li>数据流分析。分析哪一条指令依赖于其他指令的结果或数据，由此来优化指令调度。根据分析结果来重排指令，使指令以优化的顺序执行，而与原始程序的顺序无关。</li>
<li>指令推测执行。使用转移预测和数据流分析，让指令在程序实际执行之前就“推测执行”，并把结果暂时存储起来。通过执行可能需要的指令，使处理器的执行机制尽可能地保持繁忙。</li>
<li>采用Intel MMX技术。它包括57条增强的MMX指令，可处理视频、声频及图像数据。</li>
</ul>
<ol start="2">
<li>内部结构</li>
</ol>
<p><img src="assets/2024-11-20-18-19-47.png" alt="Pentium2 cpu的内部架构" /></p>
<p>PⅡ有3条指令流水线，每条指令流水线共有14级</p>
<p><img src="assets/2024-11-20-18-20-30.png" alt="Pentium2 cpu14级流水" /></p>
<p>PⅡ CPU在体系结构上较以前的处理器有很大变化，一个最明显的技术特征就是其核心完全采用RISC微结构，为了保持与80x86其他处理器兼容，仍继续采用CISC指令集，因此内部增加了RISC与CISC之间的转换硬件。</p>
<p>PⅡ与P6一样采用*BE7～*BE0作为8个存储体的选择信号对存储器的访问加以控制。它们在非流水线的地址方式下需要两个时钟周期进行总线操作，在P6和早期PⅡ系统中，系统总线的速度为66 MHz，主频为250 MHz，以后的PentiumⅡ系统总线速度提高到100 MHz。</p>
<ol start="3">
<li>操作模式</li>
</ol>
<p>PentiumⅡ具有3种操作模式：实模式、虚拟8086模式和保护模式。</p>
<blockquote>
<p>实际上，80386及后继机型都具有这3种模式。</p>
</blockquote>
<ul>
<li>
<p>在实模式下</p>
<ul>
<li>所有8088/8086之后增加的新特性都被关闭</li>
<li>这时PentiumⅡ就像一台单纯的8088/8086一样运行</li>
</ul>
</li>
<li>
<p>在虚拟8086模式下</p>
<ul>
<li>可以用一种受保护的方式来运行老的8088/8086程序</li>
<li>这时，有一个实际的操作系统在控制整个计算机。</li>
</ul>
</li>
<li>
<p>在保护模式下</p>
<ul>
<li>有4种可用的特权级别，它们由程序状态字中的对应位控制</li>
<li>第0级相当于别的计算机中的内核模式，它可以完全控制计算机，因而只由操作系统使用</li>
<li>第3级用于运行用户程序，它阻塞用户程序对某些特殊的关键指令和控制寄存器的访问，以防止某些鲁莽的用户程序搞垮整个计算机</li>
</ul>
<blockquote>
<p>第1级和第2级很少使用。</p>
</blockquote>
</li>
</ul>
<h1 id="2-80x86-cpu的寄存器和主存储器"><a class="header" href="#2-80x86-cpu的寄存器和主存储器">2. 80x86 cpu的寄存器和主存储器</a></h1>
<h2 id="21-80x86-cpu的寄存器"><a class="header" href="#21-80x86-cpu的寄存器">2.1 80x86 cpu的寄存器</a></h2>
<ol>
<li>基本结构寄存器组</li>
</ol>
<ul>
<li>通用寄存器</li>
<li>指令指针寄存器</li>
<li>标志寄存器</li>
<li>段寄存器</li>
</ul>
<ol start="2">
<li>浮点寄存器组</li>
</ol>
<ul>
<li>数据寄存器</li>
<li>标记字寄存器</li>
<li>指令和数据指针寄存器</li>
<li>控制字寄存器</li>
</ul>
<ol start="3">
<li>系统级寄存器</li>
</ol>
<ul>
<li>系统地址寄存器</li>
<li>控制寄存器</li>
<li>测试寄存器</li>
<li>调试寄存器</li>
</ul>
<h3 id="211-基本结构寄存器组"><a class="header" href="#211-基本结构寄存器组">2.1.1 基本结构寄存器组</a></h3>
<p><img src="assets/2024-11-21-13-26-14.png" alt="基本结构寄存器组图示" /></p>
<h4 id="通用寄存器"><a class="header" href="#通用寄存器">通用寄存器</a></h4>
<ol>
<li>通用寄存器</li>
</ol>
<p>8086/8088和80286所具有的寄存器: 图中除阴影区以外的寄存器,都是16位寄存器。</p>
<p>四个16位数据寄存器</p>
<ul>
<li>AX: 数据存储器，累加器，I/O</li>
<li>BX: 数据存储器，基址寄存器</li>
<li>CX: 数据存储器，循环次数</li>
<li>DX: 数据存储器，与AX连用表示32为数据；I/O的端口地址</li>
</ul>
<blockquote>
<p>也可作为8位使用AH、AL、BH、BL……</p>
</blockquote>
<ol start="2">
<li>变址寄存器</li>
</ol>
<p>4个变址寄存器（地址指针寄存器）</p>
<ul>
<li>SP：栈顶指针寄存器</li>
<li>BP：基址指针寄存器</li>
<li>SI： 源变址寄存器</li>
<li>DI：目的变址寄存器</li>
</ul>
<blockquote>
<p>SP、BP、DI、SI也可做16位的数据寄存器使用</p>
</blockquote>
<h4 id="指令指针寄存器和标志寄存器"><a class="header" href="#指令指针寄存器和标志寄存器">指令指针寄存器和标志寄存器</a></h4>
<ol>
<li>IP（Instruction Pointer）</li>
</ol>
<p>指令指针寄存器，它用来存放代码段中的偏移地址。<br />
8086中的CS:IP类似于其他CPU中的PC</p>
<ol start="2">
<li>FLAGS</li>
</ol>
<p>标志寄存器，又称PSW（Program Status Word），即程序状态寄存器。存放条件码标志、控制标志等</p>
<p><img src="assets/2024-11-21-13-36-08.png" alt="80x86cpu中标志寄存器的内容" /></p>
<p>条件码标志:</p>
<ul>
<li>
<p>OF: Over Flow Flag溢出标志
溢出时，则OF置1；否则OF置0</p>
</li>
<li>
<p>SF: Sign Flag符号(负数)标志
结果为负，则SF置1；结果为正，则SF置0</p>
</li>
<li>
<p>ZF: Zero Flag零标志
结果各位全为0时，则ZF置1；否则ZF置0</p>
</li>
<li>
<p>CF: Carry Flag进位/借位标志
进位或借位时，则CF置1；否则置0</p>
</li>
<li>
<p>PF: Parity Flag奇偶标志
运算结果中1的个数为偶数时置1，否则置0</p>
</li>
<li>
<p>AF: Auxiliary Carry Flag辅助进位标志
低字节，低4位</p>
</li>
</ul>
<p>控制标志:</p>
<ul>
<li>DF: Direction Flag方向标志；
在串处理指令中
<ul>
<li>当DF=1时，负向, SI和DI不断减小</li>
<li>当DF＝0时，正向，SI和DI增⼤，使串处理从低地址向⾼地址⽅向处理。</li>
</ul>
</li>
<li>IF: Interrupt Flag中断标志</li>
<li>TF: Trap Flag单步运行标志</li>
</ul>
<p>调试程序DEBUG中提供了测试标志位的手段，它用符号表示某些标志位的值：</p>
<div class="table-wrapper"><table><thead><tr><th>标志名</th><th>标志为1</th><th>标志为0</th></tr></thead><tbody>
<tr><td>OF 溢出（是/否）</td><td>OV</td><td>NV</td></tr>
<tr><td>DF 方向（增量/减量）</td><td>DN</td><td>UP</td></tr>
<tr><td>IF 中断（允许/关闭）</td><td>EI</td><td>DI</td></tr>
<tr><td>SF 符号（正/负）</td><td>NG</td><td>PL</td></tr>
<tr><td>ZF 零（是/否）</td><td>ZR</td><td>NZ</td></tr>
<tr><td>PF 奇偶（偶/奇）</td><td>PE</td><td>PO</td></tr>
<tr><td>CF 进位（是/否）</td><td>CY</td><td>NC</td></tr>
<tr><td>AF 辅助进位（是/否）</td><td>AC</td><td>NA</td></tr>
</tbody></table>
</div>
<p>系统标志:</p>
<ul>
<li>TF(Trap Flat)
标志处理器是否进入单步调试状态</li>
<li>IF(Interrupt Flat)
控制是否允许响应外部中断请求</li>
<li>IOPL（I/O Privilege Level）
设置当前任务访问 I/O 指令的权限级别</li>
<li>NT（Nested Task）
嵌套任务标志，用来表示当前的任务是否嵌套在另一任务内</li>
<li>RF（Resume Flag）
恢复标志位，它与调试寄存器的断点一起使用，以保证不重复处理断点。</li>
<li>VM（Virtual-8086 Mode）
虚拟8086模式位 。</li>
<li>AC（Alignment Check mode）
对准检查方式位 。</li>
<li>VIF（Virtual Interrupt Flag）
虚拟中断标志。</li>
<li>VIP（Virtual Interrupt Pending flag）
虚拟中断未决标志。</li>
<li>ID（IDentification flag）
标识标志，程序有设置和清除ID标识的能力，以指示处理机对CPU ID指令的支持。</li>
</ul>
<h3 id="段寄存器-1"><a class="header" href="#段寄存器-1">段寄存器</a></h3>
<p>汇编语言源程序是分段结构（代码段、数据段…），段寄存器用来存放段起始地址</p>
<ol>
<li>分类</li>
</ol>
<ul>
<li>CS：（Code Segment）代码段</li>
<li>DS：（Data Segment）数据段</li>
<li>SS：（Stack Segment）堆栈段</li>
<li>ES：（Extra Segment）附加段</li>
</ul>
<blockquote>
<p>386后增加了FS、GS两个附加段</p>
</blockquote>
<ol start="2">
<li>段寄存器与存放偏移地址的寄存器之间的默认组合关系</li>
</ol>
<ul>
<li>8086/8088,80286</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>段寄存器</th><th>偏移地址</th></tr></thead><tbody>
<tr><td>CS</td><td>IP</td></tr>
<tr><td>SS</td><td>SP或BP</td></tr>
<tr><td>DS</td><td>BX,SI,DI或一个16位数</td></tr>
<tr><td>ES</td><td>DI(用于串指令)</td></tr>
</tbody></table>
</div>
<ul>
<li>80386及后续机型</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>段寄存器</th><th>偏移地址</th></tr></thead><tbody>
<tr><td>CS</td><td>IP</td></tr>
<tr><td>SS</td><td>SP或BP</td></tr>
<tr><td>DS</td><td>BX,SI,DI或一个16位数</td></tr>
<tr><td>ES</td><td>EAX,EBX,ECX,EDX,EDI,ESI,一个8位或32位数</td></tr>
<tr><td>FS</td><td>无默认</td></tr>
<tr><td>GS</td><td>无默认</td></tr>
</tbody></table>
</div>
<h3 id="212-系统级寄存器"><a class="header" href="#212-系统级寄存器">2.1.2 系统级寄存器</a></h3>
<p>系统级寄存器组是指不能由用户程序访问而只能由系统管理的寄存器</p>
<!-- TODO: many systemtic register -->
<h2 id="22-80x86的主存储器"><a class="header" href="#22-80x86的主存储器">2.2 80x86的主存储器</a></h2>
<p><img src="assets/2024-11-21-13-54-51.png" alt="存储单元的地址和内容" /></p>
<blockquote>
<p>低位字节存放在低位地址中</p>
</blockquote>
<h3 id="221-存储单元的地址和内容"><a class="header" href="#221-存储单元的地址和内容">2.2.1 存储单元的地址和内容</a></h3>
<p>存储器里以字节为单位存储信息，每一个字节单元给予一个唯一的编号即存储器地址，称为物理地址。地址从0开始编号，也是用二进制数来表示的。书写格式为十六进制数。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord cjk_fallback">地址总线宽度</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">位</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">可寻址</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7144em;"></span><span class="mord cjk_fallback">寻址空间</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>字、双字存放：以低位地址作为整个字/双字的地址</p>
<ul>
<li>对准字：字地址为偶地址</li>
<li>非对准字：字地址为奇地址</li>
</ul>
<blockquote>
<p>非对准字的存取速度比对准字慢，故尽量避免</p>
</blockquote>
<h3 id="222-实模式存储寻址"><a class="header" href="#222-实模式存储寻址">2.2.2 实模式存储寻址</a></h3>
<p>80x86中除8086/8088只能在实模式下工作外，其他的CPU均可在实模式或保护模式下工作。</p>
<ul>
<li>实模式下允许的最大寻址空间为1 MB。8086/8088的地址总线宽度为20位，因而其最大寻址空间正好是1MB。</li>
<li>在1MB的存储器里，每个存储单元都有一个唯一的20位地址，称为物理地址。</li>
<li>对于其他微处理器在实模式下只能访问前1MB的存储器地址。</li>
</ul>
<h3 id="223-保护模式存储器寻址"><a class="header" href="#223-保护模式存储器寻址">2.2.3 保护模式存储器寻址</a></h3>
<ol>
<li>逻辑地址</li>
</ol>
<p>在保护模式存储器寻址中 ，程序员在程序中指定逻辑地址， CPU采用一种比较复杂的方法来求得相应的物理地址。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">逻辑地址</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">段选择器</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">偏移地址</span></span></span></span></span></p>
<p>段选择器存放在段寄存器中，由CPU通过一定的方法利用段选择器取得段基址，再和偏移地址相加，从而求得所选存储单元的线性地址，线性地址再通过分页部件转换成物理地址。</p>
<ol start="2">
<li>描述符</li>
</ol>
<p>段选择器是通过描述符表取得描述符，从而得到段基址的。</p>
<p>描述符有8个字节长，用来说明段的起始地址、段的大小、段在存储器中的位置及有关的控制和状态信息，其格式如下图所示:</p>
<p><img src="assets/2024-11-21-14-10-44.png" alt="80286描述符" />
<img src="assets/2024-11-21-14-11-07.png" alt="80386/80486/Pentium描述符" /></p>
<p>描述符由段基址、段界限、访问权和附加字段4部分组成</p>
<ul>
<li>
<p>段基址（Base）
用来指定段的起始地址。80386以上处理器的段基址为32位，说明段可以从4 GB存储器的任何地址开始。</p>
</li>
<li>
<p>段界限（Limit）
用来存放该段的段长度。80386及其后继机型的段界限为20位，同时在其描述符中又给出了一个粒度位G（Granularity）</p>
<ul>
<li>当G = 0时，段长的粒度单位为字节</li>
<li>当G = 1时，段长的粒度单位为页，每页为4 KB</li>
</ul>
</li>
<li>
<p>访问权（Access Rights）
有8位，所以又称为访问权字节,用来说明该段在系统中的功能，并给出访问该段的一些控制信息。
<img src="assets/2024-11-21-14-19-03.png" alt="访问权标志" /></p>
<ul>
<li>
<p>P（Present）存在位</p>
<ul>
<li>P = 1说明该段已装入物理存储器，其段基址和段界限值有效</li>
<li>P = 0则说明该段并未装入物理存储器，段基址和段界限值无用</li>
</ul>
</li>
<li>
<p>DPL（Descriptor Privilege Level）描述符特权级字段2位
用来指定该存储段的特权级0～3，0级为最高特权级。</p>
</li>
<li>
<p>S（Segment Descriptor）段描述符位</p>
<ul>
<li>S = 0表示该段为系统段</li>
<li>S = 1则表示该段为应用程序的代码段或数据（包括堆栈）段</li>
</ul>
</li>
<li>
<p>A（Accessed）已访问位</p>
<ul>
<li>A = 0表示该段尚未被访问过</li>
<li>A = 1表示该段已被访问过。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>附加字段部分在386及其后继机型中存在，它们包括G、D/B、0和AVL 共4位。</p>
<ul>
<li>
<p>G为粒度位
前面已有说明。</p>
</li>
<li>
<p>D/B位
在代码段里，该位称为D（Default OperationSize）默认操作长度位</p>
<ul>
<li>D= 1表示操作数及有效地址长度均为32位</li>
<li>D = 0则为16位操作数和16位有效地址。</li>
</ul>
</li>
<li>
<p>0位
该位必须为0，为未来的处理机保留。</p>
</li>
<li>
<p>AVL（Available）
该位只能由系统软件使用。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>描述符表</li>
</ol>
<p>描述符存放在描述符表中，主要有4种描述符表：</p>
<ul>
<li>
<p>全局描述符表GDT（Global Descriptor Table）
用于存放操作系统和各任务公用的描述符，如公用的数据和代码段描述符、各个任务的TSS描述符和LDT描述符等。</p>
</li>
<li>
<p>局部描述符表LDT（Local Descriptor Table）
用于存放各个任务私有的描述符，如本任务的代码段描述符和数据段描述符等。</p>
</li>
<li>
<p>中断描述符表IDT（Interrupt Descriptor Table）
用于存放系统中断描述符。</p>
</li>
<li>
<p>任务状态段TSS（Task State Segment）
用来存放各个任务的私有运行状态信息描述符。</p>
</li>
</ul>
<p>描述符表都存放在存储器中，每个表分别构成一个64 KB长的段，表中可存放8 K个描述符。</p>
<p>全局描述符表中的描述符所指定的段可用于所有程序，而局部描述符表中的描述符所指定的段通常只用于一个用户程序（或称一个任务）。在整个系统里，只有一个全局描述符表和一个中断描述符表，而局部描述符表可以有多个，它们分别对应于不同的任务。</p>
<ol start="4">
<li>段选择器</li>
</ol>
<p>段选择器提供描述符在描述符表中的位置，存放在段寄存器中，16位长，其格式如下：</p>
<p><img src="assets/2024-11-21-14-26-08.png" alt="段选择器的格式" /></p>
<ul>
<li>
<p>INDEX为索引值，即描述符表索引值
它给出所选描述符在描述符表中的地址。该字段共13位，可从表中8K个描述符中选取一个。</p>
</li>
<li>
<p>RPL（Requested Privilege Level）为请求特权级，这是对该存储段请求访问的特权级
其值可为0～3，0级特权级最高，如RPL和该段描述符中的DPL相等（同一特权级）或RPL＜DPL（请求特权级高于描述符特权级）则允许对该段的访问</p>
</li>
<li>
<p>TI（Table Indicator）为选择位</p>
<ul>
<li>TI = 0指示从全局描述符表GDT中选择描述符</li>
<li>TI = 1则指示从局部描述符表LDT中选择描述符。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>描述符寄存器</li>
</ol>
<p>为了提高保护模式存储器寻址的速度，CPU中设置了6个64位的描述符寄存器，用来存放对应段的描述符，如下图所示
<img src="assets/2024-11-21-14-31-35.png" alt="段寄存器和描述符" /></p>
<p>每当段寄存器中段选择器的值确定以后，硬件会自动地根据段选择器的索引值，从系统的描述符表中取出一个8字节（64位）的描述符，装入到相应的段描述符寄存器中</p>
<p>以后每当出现对该段存储器的访问时，就可直接使用相应的描述符寄存器中的段基址作为线性地址计算的一个元素，而不需要在内存中查表得到段基址，因此加快了存储器物理地址的形成。</p>
<p>应当指出，段寄存器是程序可访问的，而描述符寄存器则是程序不可访问的。</p>
<h3 id="224-80x86逻辑地址的来源"><a class="header" href="#224-80x86逻辑地址的来源">2.2.4 80x86逻辑地址的来源</a></h3>
<p>从以上内容可知</p>
<ul>
<li>实模式下的逻辑地址：由段基值和偏移地址组成</li>
<li>保护模式下的逻辑地址：由段选择器和偏移地址组成。</li>
</ul>
<p>实际上段基值和选择器都是由段寄存器提供。</p>
<p>在汇编语言程序中，逻辑地址可表示为：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">段基值（或段选择器）：偏移地址</span></span></span></span></span></p>
<p>在80x86 CPU中，逻辑地址的两个分量之间存在一种默认组合关系，可以不在程序中指明
<img src="assets/2024-11-21-14-41-49.png" alt="80x86cpu逻辑地址两分量中的默认组合" /></p>
<blockquote>
<p>如用到非默认的组合关系（如使用允许替代来源），则必须用段跨越前缀加以说明。</p>
</blockquote>
<h1 id="3-80x86cpu的指令系统"><a class="header" href="#3-80x86cpu的指令系统">3. 80x86cpu的指令系统</a></h1>
<p>80x86 CPU的指令集是在8086/8088 CPU的指令系统上发展起来的。</p>
<ul>
<li>8086/8088 指令系统是基本指令集</li>
<li>80286、80386、80486和Pentium指令系统是在基本指令集上进行了扩充。扩充指令的
<ul>
<li>一部分是增强的8086/8088基本指令和一些专用指令；</li>
<li>另一部分是系统控制指令，即特权指令，它们对80286、80386、80486和Pentium保护模式的多任务、存储器管理和保护机制提供了控制能力。</li>
</ul>
</li>
</ul>
<p>80x86 CPU采用了变字长的机器指令格式，由1～15个字节组成一条指令。一般格式如下图所示:</p>
<p><img src="assets/2024-11-22-11-37-14.png" alt="80x86cpu机器指令格式" /></p>
<h2 id="31-80x86寻址方式"><a class="header" href="#31-80x86寻址方式">3.1 80x86寻址方式</a></h2>
<p>指令中的寻址方式是用来确定操作数地址以找到指令所需的操作数。</p>
<ul>
<li>
<p>8086和80286</p>
<p>字长是16位</p>
<ul>
<li>⼀般情况下只处理8位和16位操作数</li>
<li>只是在乘、除指令中才会有32位操作数；</li>
</ul>
</li>
<li>
<p>80386及其后继机型</p>
<p>字长为32位</p>
<ul>
<li>因此它除可处理8位和16位操作数外，还可处理32位操作数</li>
<li>在乘、除法情况下可产⽣64位操作数。</li>
</ul>
</li>
</ul>
<p>本节下面所述例⼦中，如处理的是32位操作数，则适用于80386及其后继机型</p>
<h3 id="311-立即寻址方式和寄存器寻址方式"><a class="header" href="#311-立即寻址方式和寄存器寻址方式">3.1.1 立即寻址方式和寄存器寻址方式</a></h3>
<ol>
<li>立即寻址方式</li>
</ol>
<p>指令所需的操作数直接在指令代码中，随着取指令一起取到CPU中。</p>
<p>这种操作数称为立即数。立即数用来表示常数</p>
<ul>
<li>经常用于给寄存器赋初值</li>
<li>只能用于源操作数字段，不能用于目的操作数字段</li>
<li>源操作数长度应与目的操作数长度一致</li>
<li>在汇编指令中，立即数若是数值常数可直接书写，若是字符常数则应加上引号。</li>
</ul>
<ol start="2">
<li>寄存器寻址方式</li>
</ol>
<p>指令所需的操作数存放在CPU的寄存器（通用寄存器或段寄存器）中，通过指令中的寄存器地址去找到操作数</p>
<p>在汇编指令中，寄存器地址直接用寄存器名表示，如用AX、BX、AL、BH、EAX、EBX、DS、ES等，这些寄存器可以是8位的、16位的或32位的。</p>
<h3 id="312-存储器寻址"><a class="header" href="#312-存储器寻址">3.1.2 存储器寻址</a></h3>
<p>在汇编语言程序中，一个存储单元的地址采用逻辑地址来表示，其形式为:
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">段基址（或段选择器）</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">偏移地址</span></span></span></span></span></p>
<ul>
<li>操作数地址（物理地址）是根据段基值（或段选择器）和偏移地址通过一定的方法得到。
<ul>
<li>段基址在实模式和保护模式下可从不同的途径取得。</li>
<li>偏移地址是指存放操作数的存储单元与段起始地址（段基址）之间的字节距离</li>
</ul>
<blockquote>
<p>在80x86里，把按寻址方式计算出来的操作数偏移地址称为有效地址EA（Effective Address）。</p>
</blockquote>
</li>
</ul>
<hr />
<p>获得有效地址EA（偏移地址）的方法</p>
<p>EA可由4个地址分量的某种组合求得
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">基地址</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">（变址量</span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">比例因子）</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">位移量</span></span></span></span></span></p>
<blockquote>
<p>上式中的每一个地址分量均可空缺，但比例因子只能与变址寄存器同时使用。</p>
</blockquote>
<ul>
<li>
<p>位移量</p>
<p>指令代码中的一个8位、16位或32位二进制数，但它不是立即数，而是一个地址量。</p>
</li>
<li>
<p>基地址</p>
<p>基址寄存器或基址指针中的内容</p>
</li>
<li>
<p>变址量</p>
<p>变址寄存器中的内容</p>
</li>
<li>
<p>比例因子</p>
<p>它是80386及其后继机型新增加的寻址方式中的一个术语，其值可为1，2，4或8。在含比例因子的寻址方式中，可用变址寄存器的内容乘以比例因子来取得变址值</p>
</li>
</ul>
<p>8086/80386只能用16位寻址，80386及后续机型可用32位寻址</p>
<div class="table-wrapper"><table><thead><tr><th><strong>地址分量</strong></th><th><strong>16位寻址</strong></th><th><strong>32位寻址</strong></th></tr></thead><tbody>
<tr><td><strong>位移量</strong></td><td>0，8，16位</td><td>0，8，32位</td></tr>
<tr><td><strong>基址寄存器</strong></td><td>BX，BP</td><td>任何32位通用寄存器（包括ESP）</td></tr>
<tr><td><strong>变址寄存器</strong></td><td>SI，DI</td><td>除ESP以外的32位通用寄存器</td></tr>
<tr><td><strong>比例因子</strong></td><td>无</td><td>1，2，4，8</td></tr>
</tbody></table>
</div>
<h4 id="直接寻址方式"><a class="header" href="#直接寻址方式">直接寻址方式</a></h4>
<ul>
<li>指令所需的操作数存放在存储单元中</li>
<li>EA直接由指令代码中的位移量提供。
即EA只包含位移量这一种地址分量</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">位移量</span></span></span></span></span></p>
<ol>
<li>数值地址表示EA</li>
</ol>
<p>如用数值表示操作数的有效地址，则操作数所在段的段寄存器必须指明，不能省略。例如</p>
<pre><code class="language-asm">MOV BX,段寄存器名:[位移量]
MOV BX,DS:[1000H]
</code></pre>
<ol start="2">
<li>符号地址表示EA</li>
</ol>
<p>源程序中</p>
<ul>
<li>常用符号地址表示存放操作数的存储单元</li>
<li>段基址缺省（DS）或用段跨越前缀给出</li>
</ul>
<pre><code class="language-asm">MOV BX,VARIABLE_NAME
</code></pre>
<h4 id="寄存器间接寻址"><a class="header" href="#寄存器间接寻址">寄存器间接寻址</a></h4>
<ul>
<li>指令所需的操作数在存储单元中</li>
<li>EA直接从基址寄存器或变址寄存器中获得
即EA是由基址（或变址）寄存器内容来提供的</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">基地址</span><span class="mord">/</span><span class="mord cjk_fallback">变地址</span></span></span></span></span></p>
<pre><code class="language-asm">MOV BX,[R_变址]/[R_基址]
MOV BX,[BP]
</code></pre>
<ul>
<li>
<p>16位寻址时可用的寄存器：基址BX、BP、变址SI、DI</p>
<blockquote>
<p>注意：BP缺省段地址为SS，其余3个缺省DS</p>
</blockquote>
</li>
<li>
<p>32位寻址时可用的寄存器：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI</p>
<blockquote>
<p>用BP、ESP、EBP时, 默认为SS段;其他默认为DS段</p>
</blockquote>
</li>
</ul>
<h4 id="寄存器相对寻址"><a class="header" href="#寄存器相对寻址">寄存器相对寻址</a></h4>
<ul>
<li>指令所需的操作数在存储单元中</li>
<li>EA是两个地址分量之和: 基址(或变址)寄存器的内容与指令中指定的位移量之和
<ul>
<li>若使用的是变址寄存器称为变址寻址方式</li>
<li>若使用的是基址寄存器称为基址寻址方式</li>
<li>位移量部分：可用数值表示，也可用符号地址表示</li>
</ul>
</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">变址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">基址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">位移量</span></span></span></span></span></p>
<pre><code class="language-asm">MOV BX,位移量[R_变址/R_基址]
MOV BX,2[BX]
MOV BX,VARIABLE_NAME[BX]
</code></pre>
<p>常用来访问顺序存放在主存中的一维数组、表、字符串等。其典型用法是将指令中不能修改的位移量作为基准地址，而将变址或基址寄存器内容作为修改量</p>
<h4 id="基址变址寻址方式"><a class="header" href="#基址变址寻址方式">基址变址寻址方式</a></h4>
<ul>
<li>指令所需的操作数在主存单元中</li>
<li>EA是三个地址分量之和：基址寄存器内容、变址寄存器内容与指令中的位移量（0位、8位、16位或32位）之和</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">变址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">基址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">位移量</span></span></span></span></span></p>
<pre><code class="language-asm">MOV BX,位移量[R_变址][R_基址]
MOV BX,2[BX][SI]
MOV BX,VARIABLE_NAME[BX][Si]
</code></pre>
<p>由于基址变址寻址⽅式中有两个地址分量可以在程序执⾏过程中进⾏修改，因此常用来访问存放在主存中的⼆维数组 。</p>
<h4 id="比例变址寻址方式"><a class="header" href="#比例变址寻址方式">比例变址寻址方式</a></h4>
<ul>
<li>指令所需的操作数在主存单元中</li>
<li>EA是变址寄存器的内容乘以指令中指定的比例因子再加上位移量之和</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">变址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">比例因子</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">位移量</span></span></span></span></span></p>
<pre><code class="language-asm">MOV BX,位移量[(R_{变址}) * 比例因子]
MOV EAX，COUNT[ESI * 4]
</code></pre>
<p>对于元素大小为2，4，8字节的数组，可以在变址寄存器中给出数组元素下标，而由寻址方式控制直接用比例因子把下标转换为变址值。</p>
<h4 id="基址比例变址寻址方式"><a class="header" href="#基址比例变址寻址方式">基址比例变址寻址方式</a></h4>
<ul>
<li>指令所需的操作数在主存单元中</li>
<li>EA由4种成分组成:变址寄存器的内容乘以比例因子，加上基址寄存器的内容，再加上位移量（0位、8位或32位）之和</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">变址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">比例因子</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">基址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">位移量</span></span></span></span></span></p>
<pre><code class="language-asm">MOV BX,位移量[(R_{基址})][(R_{变址}) * 比例因子]
MOV BX,VARIABLE_NAME[BP][DI * 4]
MOV BX,2[BP][DI * 2]
</code></pre>
<h3 id="313-串操作寻址方式"><a class="header" href="#313-串操作寻址方式">3.1.3 串操作寻址方式</a></h3>
<p>80x86提供专门的串操作指令，这些指令所用的操作数也在存储器中，但它们不能使用上述寻址方式，而是隐含使用变址寄存器SI、ESI、DI或EDI</p>
<ul>
<li>隐含使用SI或ESI作为在数据段中的源串（即源操作数）的地址指针</li>
<li>隐含使用DI或EDI作为在附加段中的目的串的地址指针</li>
<li>在完成一次串操作后，指令自动修改SI或ESI、DI或EDI两个地址指针，使SI或ESI、DI或EDI指向下一个串元素的存储单元。</li>
</ul>
<h2 id="32-80x86cpu指令系统"><a class="header" href="#32-80x86cpu指令系统">3.2 80x86cpu指令系统</a></h2>
<p>80x86 CPU指令按操作数地址个数可划分为3种类:</p>
<ol>
<li>双操作数指令</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">OPR</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li><code>OPR</code>: 指令操作码</li>
<li><code>DEST</code>: 目的操作数地址</li>
<li><code>SRC</code>: 源操作数地址</li>
</ul>
<blockquote>
<p>为了避免指令过长，双操作数指令的两个操作数不能同时是内存中的数</p>
</blockquote>
<ol start="2">
<li>单操作数指令</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ORP</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span></span></span></span></span></p>
<ul>
<li><code>OPR</code>: 指令操作码</li>
<li><code>DEST</code>
<ul>
<li>既是源地址又是目的地址</li>
<li>目的地址，源操作数隐含</li>
</ul>
</li>
</ul>
<ol start="3">
<li>无操作数指令</li>
</ol>
<ul>
<li><code>OPR</code>: 指令操作码</li>
<li>操作数隐含</li>
<li>不需要操作数</li>
</ul>
<h3 id="传送类指令"><a class="header" href="#传送类指令">传送类指令</a></h3>
<p>把数据、地址送到寄存器或存储单元中</p>
<h4 id="mov"><a class="header" href="#mov">MOV</a></h4>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">MO</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li>操作：<code>(SRC) -&gt; DEST</code></li>
<li>说明
<ul>
<li>SRC和DEST操作数位数一致</li>
<li>DEST不能是立即数和CS</li>
<li>不能将立即数给段寄存器</li>
<li>不能将段寄存器给段寄存器
<img src="assets/2024-11-22-13-36-09.png" alt="MOV指令的源操作数和目的操作数" /></li>
</ul>
</li>
</ul>
<h5 id="带符号扩展传送指令movsx"><a class="header" href="#带符号扩展传送指令movsx">带符号扩展传送指令MOVSX</a></h5>
<blockquote>
<p>MOVSX和MOVZX指令只支持386以后机型</p>
</blockquote>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">MO</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.07847em;">SX</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li>操作：<code>符号扩展(SRC) -&gt; DEST</code></li>
<li>说明
<ul>
<li>SRC可以是8位或16位的寄存器或存储单元的内容</li>
<li>DEST必须是16位或32位寄存器</li>
<li>将源操作数进⾏符号扩展后送⼊目的寄存器，8位扩展到16位或32位,16位到32位</li>
</ul>
<blockquote>
<p>符号扩展：将缺少的高位填入符号位进行位数扩展</p>
</blockquote>
</li>
</ul>
<h5 id="带零扩展传送指令"><a class="header" href="#带零扩展传送指令">带零扩展传送指令</a></h5>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">MO</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.07847em;">ZX</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li>操作：<code>零扩展(SRC) -&gt; DEST</code></li>
<li>说明
<ul>
<li>SRC是⽆符号整数，作零扩展，</li>
<li>即不管源操作数的符号位是否为1，⾼位均扩展为零</li>
</ul>
</li>
</ul>
<h4 id="pushpop"><a class="header" href="#pushpop">PUSH/POP</a></h4>
<ol>
<li>PUSH</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li><code>(SP)/(ESP) - 2 -&gt; (SP)/(ESP)</code></li>
<li><code>16位SRC -&gt; (SP)/(ESP)</code>
<img src="assets/2024-11-22-13-54-47.png" alt="PUSH AX举例" /></li>
</ul>
<ol start="2">
<li>POP</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">POP</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span></span></span></span></span></p>
<ul>
<li>操作：</li>
<li><code>(SP)/(ESP) -&gt; (DST)</code></li>
<li><code>(SP)/(ESP) + 2 -&gt; (SP)/(ESP)</code>
<img src="assets/2024-11-22-13-55-40.png" alt="POP AX举例" /></li>
</ul>
<ol start="3">
<li>说明</li>
</ol>
<ul>
<li>以字（16位）或双字(32位)为单位入、出栈</li>
<li>寄存器、段寄存器、存储单元可入栈，80286之后立即数允许入栈</li>
<li>除CS外，寄存器、段寄存器、存储单元都可作为出栈目的DST</li>
<li>对于不同长度的操作数，所执行的操作不同
<img src="assets/2024-11-22-13-57-58.png" alt="不同操作数长度时所执行de 不同的操作" /></li>
</ul>
<h5 id="pushapushd"><a class="header" href="#pushapushd">PUSHA/PUSHD</a></h5>
<ol>
<li>PUSHA</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">A</span></span></span></span></span></p>
<ul>
<li>16位通用寄存器依次进栈</li>
<li>进栈次序为AX、CX、DX、BX,以及指令执⾏前的SP、BP、SI、DI</li>
<li>指令执⾏后<code>（SP）&lt;-（SP）- 16</code>指向新栈顶</li>
</ul>
<ol start="2">
<li>PUSHAD</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></span></p>
<ul>
<li>32位通用寄存器依次进栈</li>
<li>进栈次序为EAX、ECX、EDX、EBX，以及指令执⾏前的ESP、EBP、ESI和EDI</li>
<li>指令执⾏后<code>（SP）&lt;-（SP）- 32</code></li>
</ul>
<h5 id="popapopad"><a class="header" href="#popapopad">POPA/POPAD</a></h5>
<ol>
<li>POPA</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">POP</span><span class="mord mathnormal">A</span></span></span></span></span></p>
<ul>
<li>16位通用寄存器依次出栈</li>
<li>出栈次序为DI、SI、BP、SP、BX、DX、CX、AX</li>
<li>指令执⾏后<code>（SP）&lt;-（SP）+ 16</code></li>
</ul>
<blockquote>
<p>SP的出栈只是修改了指针使其后的BX能顺利出栈，而堆栈中原先由PUSHA指令存入的SP的原始内容被丢弃，并未真正送到SP寄存器中去（SP的伪出栈）</p>
</blockquote>
<ol start="2">
<li>POPAD</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">POP</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></span></p>
<ul>
<li>32位通用寄存器依次出栈 (ESP的伪出栈)</li>
<li>出栈次序为EDI、ESI、EBP、ESP、EBX、EDX、ECX、EAX</li>
<li>指令执⾏后<code>（ESP）&lt;-（ESP）＋ 32</code></li>
</ul>
<h4 id="xchg"><a class="header" href="#xchg">XCHG</a></h4>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">XC</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li>
<p>操作</p>
<ul>
<li><code>(DEST) Rightleftarrow (SRC)</code></li>
<li>交换SRC和DEST的内容</li>
</ul>
</li>
<li>
<p>说明</p>
<ul>
<li>通用寄存器间或与存储单元,不允许段寄存器、立即数</li>
</ul>
</li>
</ul>
<h4 id="地址传送类"><a class="header" href="#地址传送类">地址传送类</a></h4>
<p>将存储器操作数的地址传送给指定的寄存器，而不是传送操作数</p>
<ul>
<li>LEA（Load Effective Address）有效地址送寄存器</li>
<li>LDS（Load DS with pointer）地址指针送寄存器和DS</li>
<li>LES（Load ES with pointer）地址指针送寄存器和ES</li>
<li>LFS（Load FS with pointer） 地址指针送寄存器和FS</li>
<li>LGS（Load GS with pointer）地址指针送寄存器和GS</li>
<li>LSS（Load SS with pointer） 地址指针送寄存器和SS</li>
</ul>
<h5 id="lea"><a class="header" href="#lea">LEA</a></h5>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li><code>DEST &lt;- SRC的偏移地址</code></li>
<li>DEST不允许是段寄存器，只能是16位或32位通用寄存器</li>
<li>SRC不允许是立即数、寄存器，必须是存储单元</li>
<li>目的操作数位数和源操作数有效地址长度不同时执行的操作
<img src="assets/2024-11-22-14-12-32.png" alt="目的操作数位数和源操作数有效地址长度不同时执行的操作" /></li>
</ul>
<h5 id="ldsleslfslgslss"><a class="header" href="#ldsleslfslgslss">LDS,LES,LFS,LGS,LSS</a></h5>
<p>将地址指针指向的内存单元内容送寄存器和段寄存器指令</p>
<p><img src="assets/2024-11-22-14-19-52.png" alt="SRC地址指针指向内存的存储情况" /></p>
<ol>
<li>LDS</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li><code>(SRC) -&gt; DEST</code></li>
<li>偏移地址送至DEST通用寄存器</li>
<li><code>(SRC + 2/4) -&gt; DS</code></li>
<li>段基址送至段寄存器</li>
</ul>
<ol start="2">
<li>LES</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">ES</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EST</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li><code>(SRC) -&gt; DEST</code></li>
<li><code>(SRC + 2/4) -&gt; ES</code></li>
</ul>
<ol start="3">
<li>
<p>LFS,LGS,LSS指令格式类似，不过指定的段寄存器不同</p>
</li>
<li>
<p>说明</p>
</li>
</ol>
<ul>
<li>DEST不允许是段寄存器，只能是16位或32位通用寄存器</li>
<li>SRC不允许是立即数、寄存器，必须是存储单元</li>
</ul>
<h4 id="标志传送指令"><a class="header" href="#标志传送指令">标志传送指令</a></h4>
<p>用于对标志寄存器进行存取操作，都是无操作数指令</p>
<ol>
<li>
<p><code>LAHF</code>: <code>(FLAGS低8位) -&gt; AH</code></p>
</li>
<li>
<p><code>SAHF</code>: <code>(AH) -&gt; FLAGS低八位</code></p>
</li>
<li>
<p><code>PUSHF/PUSHFD</code>: <code>16位FLAGS入栈/32位FLAGS入栈</code></p>
</li>
<li>
<p><code>POPF/POPFD</code>: <code>16位FLAGS出栈/32位FLAGS出栈</code></p>
</li>
</ol>
<h4 id="类型转换指令"><a class="header" href="#类型转换指令">类型转换指令</a></h4>
<p>将字节、字转换为字、双字，共有4条指令且都是无操作数指令<br />
操作数隐含（在AL或AX或EAX中）</p>
<ol>
<li>CBW（Convert Byte to Word）</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">CB</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></span></p>
<ul>
<li>字节转换为字</li>
<li>AL最高位置入AH的所有位，AL扩为AX</li>
</ul>
<ol start="2">
<li>CWD/CWDE(Convert Word to Double Word）</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></span></p>
<ul>
<li>字转换为双字</li>
<li>CWD
<ul>
<li>AX最高位置入DX的所有位，AX扩为DX:AX</li>
</ul>
</li>
<li>CWDE
<ul>
<li>AX扩展成EAX</li>
</ul>
</li>
</ul>
<ol start="3">
<li>CDQ（Convert Double to Quad）</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">Q</span></span></span></span></span></p>
<ul>
<li>双字转换为4字</li>
<li>EAX扩展成EDX：EAX</li>
</ul>
<ol start="4">
<li>BSWAP（Byte SWAP）</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">BS</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">A</span><span class="mord mathnormal">PREG</span><span class="mord">32</span></span></span></span></span></p>
<ul>
<li>使指令指定的32位寄存器的字节次序变反</li>
<li>具体操作为：1，4字节互换；2，3字节互换。</li>
</ul>
<blockquote>
<p>该指令只能用于80486及其后继机型</p>
</blockquote>
<h3 id="算数运算类指令"><a class="header" href="#算数运算类指令">算数运算类指令</a></h3>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th><th>操作</th></tr></thead><tbody>
<tr><td>加</td><td>ADD DEST, SRC</td><td>(DEST) + (SRC) → DEST</td></tr>
<tr><td>带进位加</td><td>ADC DEST, SRC</td><td>(DEST) + (SRC) + (CF) → DEST</td></tr>
<tr><td>减</td><td>SUB DEST, SRC</td><td>(DEST) - (SRC) → DEST</td></tr>
<tr><td>带借位减</td><td>SBB DEST, SRC</td><td>(DEST) - (SRC) - (CF) → DEST</td></tr>
<tr><td>比较</td><td>CMP DEST, SRC</td><td>(DEST) - (SRC)</td></tr>
</tbody></table>
</div>
<blockquote>
<p>CMP指令后往往跟条件转移指令，根据比较结果产生不同分支</p>
</blockquote>
<ul>
<li>影响所有标志位(ZF,SF,CF,OF,PF,AF)</li>
<li>DEST不能是立即数</li>
<li>不允许两存储单元操作</li>
</ul>
<ol>
<li>ADD举例</li>
</ol>
<p><img src="assets/2024-11-22-14-49-02.png" alt="ADD举例" /></p>
<ul>
<li>ZF(零) = 0</li>
<li>OF(溢出) = 0</li>
<li>PF(奇数个1) = 0</li>
</ul>
<blockquote>
<p>OF表示带符号数的溢出，CF表示无符号数的溢出</p>
</blockquote>
<ol start="2">
<li>SUB举例</li>
</ol>
<p><img src="assets/2024-11-22-14-52-58.png" alt="SUB举例" /></p>
<ul>
<li>ZF = 0</li>
<li>OF = 0</li>
<li>PF = 1</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th><th>操作</th></tr></thead><tbody>
<tr><td>交换并相加</td><td>XADD DEST,SRC</td><td>（DEST）+（SRC）→TEMP;（DEST →SRC;（TEMP）→DEST</td></tr>
</tbody></table>
</div>
<ul>
<li>SRC只能用寄存器寻址⽅式</li>
<li>DEST可用寄存器或任⼀种存储器寻址⽅式</li>
<li>对标志位的影响同ADD指令</li>
<li>只能用于80486及其后继机型</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th><th>操作</th></tr></thead><tbody>
<tr><td>加1</td><td>INC OPR</td><td>(OPR) + 1 → OPR</td></tr>
<tr><td>减1</td><td>DEC OPR</td><td>(OPR) - 1 → OPR</td></tr>
</tbody></table>
</div>
<ul>
<li>不影响CF，其余影响</li>
<li>OPR不允许是立即数、段寄存器</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th><th>操作</th></tr></thead><tbody>
<tr><td>求补</td><td>NEG OPR</td><td>0 - (OPR) → OPR</td></tr>
</tbody></table>
</div>
<ul>
<li>影响所有标志</li>
<li>OPR不允许是立即数、段寄存器</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th></tr></thead><tbody>
<tr><td>比较并交换指令</td><td>CMPXCHG DEST,SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>操作</p>
<ul>
<li>累加器AC与（DEST）相比较（相减）</li>
<li>如果相等，则1→ ZF，（SRC）→ DEST ；</li>
<li>否则 0→ ZF ， （DEST） → AC</li>
</ul>
</li>
<li>
<p>累加器可为AL、AX或EAX寄存器</p>
</li>
<li>
<p>SRC只能用8位、16位或32位寄存器</p>
</li>
<li>
<p>DEST则可用寄存器或存储单元</p>
</li>
<li>
<p>该指令只能用于80486及其后继机型</p>
</li>
<li>
<p>该指令对其他标志位的影响与CMP指令相同</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th></tr></thead><tbody>
<tr><td>比较并交换8字节指令</td><td>CMPXCHG8B DEST</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>操作</p>
<ul>
<li>EDX：EAX与DEST相比较，64位数比较</li>
<li>如果相等，则 1→ ZF，（ EDX：EAX ）→ DEST</li>
<li>否则 0→ ZF ，（DEST）→EDX：EAX</li>
</ul>
</li>
<li>
<p>该指令只影响ZF位，但不影响其他标志位</p>
</li>
<li>
<p>该指令只能用于Pentium及其后继机型</p>
</li>
<li>
<p>操作数均为64位数，目的操作数必须采用存储器寻址⽅式确定⼀个64位数</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th></tr></thead><tbody>
<tr><td>无符号乘法</td><td>MUl SRC</td></tr>
<tr><td>带符号乘法</td><td>IMUL SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>操作</p>
<ul>
<li>字节：<code>(AL)*(SRC)→(AX)</code></li>
<li>字：<code>(AX)*(SRC)→(DX:AX)</code></li>
<li>双字：<code>(EAX)*(SRC)→(EDX:EAX)</code></li>
</ul>
<blockquote>
<p>隐含另一操作数在累加器中</p>
</blockquote>
</li>
<li>
<p>影响CF、OF,其余无定义</p>
</li>
<li>
<p>SRC为寄存器或用byte_ptr或word_ptr指明的存储单元</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th></tr></thead><tbody>
<tr><td>无符号除法</td><td>DIV SRC</td></tr>
<tr><td>带符号除法</td><td>IDIV SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>操作</p>
<ul>
<li>除数为字节：<code>(AX)/(SRC)→ 商(AL)余数(AH)</code></li>
<li>除数为字：<code>(DX:AX)/(SRC)→ 商(AX)余数(DX)</code></li>
<li>除数为字：<code>(EDX:EAX)/(SRC)→ 商(EAX)余数(EDX)</code></li>
</ul>
<blockquote>
<p>隐含被除数在EDX/EAX/DX/AX中</p>
</blockquote>
</li>
<li>
<p>对标志位无定义</p>
</li>
<li>
<p>SEC为寄存器或用byte_ptr或word_ptr指明的存储单元</p>
</li>
</ul>
<!-- NOTE: BCD码校正指令跳过 -->
<h3 id="逻辑类指令"><a class="header" href="#逻辑类指令">逻辑类指令</a></h3>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>指令格式</th></tr></thead><tbody>
<tr><td>与</td><td>AND DEST, SRC</td></tr>
<tr><td>或</td><td>OR DEST, SRC</td></tr>
<tr><td>异或</td><td>XOR DEST, SRC</td></tr>
<tr><td>测试</td><td>TEST DEST, SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>将CF、OF置0，影响SF，ZF，ZF</li>
<li>SRC可以是立即数，REG和MEM，字/字节/双字</li>
<li>DEST允许是ERG,MEM</li>
<li>不允许两存储单元操作</li>
</ul>
<ol>
<li>测试TEST</li>
</ol>
<p><code>(DEST)Λ(SRC)</code>，相与，结果不保存,ZF</p>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>指令格式</th></tr></thead><tbody>
<tr><td>非</td><td>NOT OPR</td></tr>
</tbody></table>
</div>
<ul>
<li>不影响标志位</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>指令</th><th>格式</th><th>功能描述</th></tr></thead><tbody>
<tr><td>BT</td><td><code>BT DEST, SRC</code></td><td>把 <code>DEST</code> 中由 <code>SRC</code> 指定位的值送往标志位 <code>CF</code></td></tr>
<tr><td>BTS</td><td><code>BTS DEST, SRC</code></td><td>完成 <code>BT</code> 功能外，将 <code>DEST</code> 中的指定位置 1</td></tr>
<tr><td>BTR</td><td><code>BTR DEST, SRC</code></td><td>完成 <code>BT</code> 功能外，将 <code>DEST</code> 中的指定位置 0</td></tr>
<tr><td>BTC</td><td><code>BTC DEST, SRC</code></td><td>完成 <code>BT</code> 功能外，将 <code>DEST</code> 中的指定位取反</td></tr>
</tbody></table>
</div>
<ul>
<li>SRC是十进制数</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>指令格式</th></tr></thead><tbody>
<tr><td>正向位扫描</td><td>BSF REG，SRC</td></tr>
<tr><td>反向位扫描</td><td>BSR REG，SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>指令从位0开始自右向左扫描源操作数(反向位扫描则相反)，目的是检索第一个为1的位。</li>
<li>如遇到第一个为1的位则将ZF位置0，并把该位的位置装入目的寄存器中；</li>
<li>如源操作数为0，则将ZF位置1，目的寄存器无定义。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>指令</th><th>格式</th><th>功能描述</th></tr></thead><tbody>
<tr><td>SHL</td><td><code>SHL OPR, CNT</code></td><td>逻辑左移：最高位移入 <code>CF</code>，空出的位补 <code>0</code></td></tr>
<tr><td>SHR</td><td><code>SHR OPR, CNT</code></td><td>逻辑右移：最低位移入 <code>CF</code>，空出的位补 <code>0</code></td></tr>
<tr><td>SAL</td><td><code>SAL OPR, CNT</code></td><td>算术左移：最高位移入 <code>CF</code>，补 <code>0</code></td></tr>
<tr><td>SAR</td><td><code>SAR OPR, CNT</code></td><td>算术右移：最低位移入 <code>CF</code>，空出的位复制最高位</td></tr>
</tbody></table>
</div>
<ul>
<li>OPR可以是字、字节、双字,在存储单元或REG中</li>
<li>CNT可以是1或CL，指移位次数</li>
</ul>
<blockquote>
<p>对于80386及以后机型，COUNT还可以是8位立即数，可指定1～31的移位次数</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>指令</th><th>格式</th><th>功能描述</th></tr></thead><tbody>
<tr><td>SHLD</td><td><code>SHLD DEST, SRC, COUNT</code></td><td>双精度左移：将 <code>DEST</code> 的内容左移 <code>COUNT</code> 次，同时将 <code>SRC</code> 的高位移入 <code>DEST</code> 的低位，<code>SRC</code> 保持不变</td></tr>
<tr><td>SHRD</td><td><code>SHRD DEST, SRC, COUNT</code></td><td>双精度右移：将 <code>DEST</code> 的内容右移 <code>COUNT</code> 次，同时将 <code>SRC</code> 的低位移入 <code>DEST</code> 的高位，<code>SRC</code> 保持不变</td></tr>
</tbody></table>
</div>
<ul>
<li>80386及其后继机型可用</li>
<li><img src="assets/2024-11-22-15-22-06.png" alt="双精度移位指令图解" /></li>
<li>DEST：字或双字操作数，不允许立即数，REG 或 MEM</li>
<li>SRC：只能使用寄存器寻址方式且与 DEST目的操作数 相同长度的字或双字</li>
<li>COUNT：移位次数，它可以是一个8位的立即数或 CL移位次数的范围应为1～31，对于大于31的数，机器则自动取模32的值来取代。
<ul>
<li>COUNT ＝0，不影响标志位；</li>
<li>COUNT ≠ 0，根据移位后结果设置SF、ZF、PF、CF;
<ul>
<li>COUNT＝1，移位后符号位改变，OF＝1；否则为0</li>
<li>COUNT&gt;1, OF无定义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="串操作指令"><a class="header" href="#串操作指令">串操作指令</a></h3>
<h4 id="串传送指令"><a class="header" href="#串传送指令">串传送指令</a></h4>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">MO</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.07153em;">SRC</span></span></span></span></span></p>
<ul>
<li>DST、SRC提供类型(字节or字)</li>
<li>源串首址DS：SI→目的首址ES：DI</li>
<li>SI±1 →SI，DI±1 →DI(字节操作+1，字操作+2;DF＝0时用＋，DF＝1用－)</li>
<li>不影响标志位</li>
</ul>
<p>MOVSB
(已指明是字节)
MOVSW
(已指明是字）</p>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>操作描述</th></tr></thead><tbody>
<tr><td><strong>串传送</strong></td><td><code>MOVS DST, SRC</code></td><td>将<code>SRC</code>的数据传送到<code>DST</code>，通过<code>DS:SI</code>指向源地址，<code>ES:DI</code>指向目标地址。</td></tr>
<tr><td></td><td></td><td><code>SI</code>和<code>DI</code>根据方向标志<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td></td><td></td><td>不影响标志位。</td></tr>
<tr><td><strong>存入串</strong></td><td><code>STOS DST</code></td><td>将累加器（字节: <code>AL</code>，字: <code>AX</code>）存入由<code>ES:DI</code>指向的地址。</td></tr>
<tr><td></td><td></td><td><code>DI</code>根据<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td></td><td></td><td>不影响标志位。</td></tr>
<tr><td><strong>从串取</strong></td><td><code>LODS SRC</code></td><td>将<code>DS:SI</code>指向的值加载到累加器（字节: <code>AL</code>，字: <code>AX</code>）。</td></tr>
<tr><td></td><td></td><td><code>SI</code>根据<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td></td><td></td><td>不影响标志位。</td></tr>
<tr><td><strong>串比较</strong></td><td><code>CMPS DST, SRC</code></td><td>比较<code>DS:SI</code>指向的值和<code>ES:DI</code>指向的值(相减)，并影响标志位（<code>OF/SF/ZF/CF/PF/AF</code>）。</td></tr>
<tr><td></td><td></td><td><code>SI</code>和<code>DI</code>根据<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td><strong>串扫描</strong></td><td><code>SCAS DST</code></td><td>比较累加器（字节: <code>AL</code>，字: <code>AX</code>）与<code>ES:DI</code>指向的值(相减)，影响标志位（<code>OF/SF/ZF/CF/PF/AF</code>）。</td></tr>
<tr><td></td><td></td><td><code>DI</code>根据<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td><strong>方向标志</strong></td><td><code>CLD</code></td><td>设置方向标志<code>DF=0</code>，用于递增操作。</td></tr>
<tr><td></td><td><code>STD</code></td><td>设置方向标志<code>DF=1</code>，用于递减操作。</td></tr>
</tbody></table>
</div><!-- TODO: 到这里有点累了，歇歇 -->
<h3 id="程序转移类指令"><a class="header" href="#程序转移类指令">程序转移类指令</a></h3>
<p>执行指令的地址由CS:IP决定</p>
<ul>
<li>顺序执行时，IP的值根据指令的长度依次递增</li>
<li>转移时
<ul>
<li>若在同一段中，改变IP的值，CS不变；</li>
<li>若转向不同的段，改变CS和IP的值</li>
</ul>
</li>
</ul>
<h4 id="无条件转移"><a class="header" href="#无条件转移">无条件转移</a></h4>
<p>JMP 目标；转到目标处执行程序, 对标志位无影响</p>
<ul>
<li>标号</li>
<li>标会+常数</li>
<li>寄存器</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>指令格式</th><th>功能描述</th></tr></thead><tbody>
<tr><td>段内直接短转移</td><td><code>JMP SHORT OPR</code></td><td>(IP)+由OPR决定的8位位移量→(IP)</td></tr>
<tr><td>段内直接近转移</td><td><code>JMP NEAR PTR OPR</code></td><td>(IP)+由OPR决定的16位位移量→(IP)</td></tr>
<tr><td>段内间接近转移</td><td><code>JMP WORD PTR OPR</code></td><td>由OPR寻址方式决定的有效地址→(IP)</td></tr>
<tr><td>段间直接远转移</td><td><code>JMP FAR PTR OPR</code></td><td>OPR在段内的偏移量→(IP);OPR所在的段地址→(CS)</td></tr>
<tr><td>段间间接远转移</td><td><code>JMP DWORD PTR OPR</code></td><td>(EA)→(IP)(EA+2)→(CS) EA由OPR决定</td></tr>
</tbody></table>
</div>
<h4 id="条件转移"><a class="header" href="#条件转移">条件转移</a></h4>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.07847em;">XX</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">目标</span></span></span></span></span></p>
<ul>
<li>条件XX满足，转到目标处执行程序；</li>
<li>条件XX不满足，顺序执行程序。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>等效助记符</th><th>测试条件</th></tr></thead><tbody>
<tr><td>结果为0或相等</td><td><code>JZ OPR</code></td><td><code>JE</code></td><td><code>ZF=1</code> 转移</td></tr>
<tr><td>结果为负</td><td><code>JS OPR</code></td><td>无</td><td><code>SF=1</code> 转移</td></tr>
<tr><td>溢出</td><td><code>JO OPR</code></td><td>无</td><td><code>OF=1</code> 转移</td></tr>
<tr><td>有进位</td><td><code>JC OPR</code></td><td><code>JB, JNAE</code></td><td><code>CF=1</code> 转移</td></tr>
<tr><td>奇数个1</td><td><code>JP OPR</code></td><td><code>JPE</code></td><td><code>PF=1</code> 转移</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>等效助记符</th><th>测试条件</th></tr></thead><tbody>
<tr><td>非0或不等</td><td><code>JNZ OPR</code></td><td><code>JNE</code></td><td><code>ZF=0</code> 转移</td></tr>
<tr><td>结果为正</td><td><code>JNS OPR</code></td><td>无</td><td><code>SF=0</code> 转移</td></tr>
<tr><td>非溢出</td><td><code>JNO OPR</code></td><td>无</td><td><code>OF=0</code> 转移</td></tr>
<tr><td>无进位</td><td><code>JNC OPR</code></td><td><code>JNB, JAE</code></td><td><code>CF=0</code> 转移</td></tr>
<tr><td>偶数个1</td><td><code>JNP OPR</code></td><td><code>JPO</code></td><td><code>PF=0</code> 转移</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>等效助记符</th><th>测试条件</th></tr></thead><tbody>
<tr><td>大于或不小于且≠转移</td><td><code>JA OPR</code></td><td><code>JNBE</code></td><td><code>CF=0 且 ZF=0</code></td></tr>
<tr><td>大于等于或不小于转移</td><td><code>JAE OPR</code></td><td><code>JNB</code></td><td><code>CF=0 或 ZF=0</code></td></tr>
<tr><td>小于或不大于且≠转移</td><td><code>JB OPR</code></td><td><code>JNAE</code></td><td><code>CF=1 且 ZF=0</code></td></tr>
<tr><td>小于等于或不大于转移</td><td><code>JBE OPR</code></td><td><code>JNA</code></td><td><code>CF=1 或 ZF=0</code></td></tr>
</tbody></table>
</div>
<ul>
<li>比较两个无符号数，并根据结果转移</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>等效助记符</th><th>测试条件</th></tr></thead><tbody>
<tr><td>大于或不小于且≠转移</td><td><code>JG OPR</code></td><td><code>JNLE</code></td><td><code>ZF=0 且 SF⊕OF=0</code></td></tr>
<tr><td>大于等于或不小于转移</td><td><code>JGE OPR</code></td><td><code>JNL</code></td><td><code>ZF=1 或 SF⊕OF=0</code></td></tr>
<tr><td>小于或不大于且≠转移</td><td><code>JL OPR</code></td><td><code>JNGE</code></td><td><code>ZF=0 且 SF⊕OF=1</code></td></tr>
<tr><td>小于等于或不大于转移</td><td><code>JLE OPR</code></td><td><code>JNG</code></td><td><code>ZF=1 或 SF⊕OF=1</code></td></tr>
</tbody></table>
</div>
<ul>
<li>比较两个带符号数，并根据结果转移</li>
</ul>
<h4 id="循环控制"><a class="header" href="#循环控制">循环控制</a></h4>
<ol>
<li>LOOP</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.13889em;">OOP</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">标号</span></span></span></span></span></p>
<ul>
<li>(CX)－1→(CX)</li>
<li>若(CX)≠0 ,从标号处继续循环;若(CX)＝0 , 退出循环</li>
</ul>
<p>相当于</p>
<ul>
<li>DEC CX</li>
<li>JNZ 标号</li>
</ul>
<ol start="2">
<li>为 0/ 相等时循环
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">OOPE</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">标号</span></span></span></span></span></li>
</ol>
<ul>
<li>(CX)－1→(CX)</li>
<li>(CX)≠0且ZF＝1 ,转至标号处继续循环;若(CX)＝0 或ZF＝0, 顺序执行</li>
</ul>
<ol start="3">
<li>非 0/ 不等时循环
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">OOPNE</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">标号</span></span></span></span></span></li>
</ol>
<ul>
<li>(CX)－1→(CX)</li>
<li>(CX)≠0且ZF＝0 ,转至标号处继续循环;若(CX)＝0 或ZF＝1, 顺序执行</li>
</ul>
<ol start="4">
<li>按 CX 循环</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.07153em;">CXZ</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">标号</span></span></span></span></span></p>
<ul>
<li>(CX)＝0 ,转至标号处继续循环</li>
</ul>
<ol start="5">
<li>说明</li>
</ol>
<ul>
<li>循环指令不影响标志位</li>
<li>隐含(CX)－1操作</li>
<li>LOOP指令按循环次数决定是否结束循环</li>
<li>LOOPZ和LOOPNZ提供了提前结束循环的可能，常跟在比较指令之后</li>
<li>JCXZ常用于循环初值为0而发生循环的情况</li>
</ul>
<h3 id="处理机控制类指令"><a class="header" href="#处理机控制类指令">处理机控制类指令</a></h3>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<p>第五章、汇编语言层</p>
<ul>
<li><a href="5.assmbly.html#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="5.assmbly.html#2-%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F">2. 汇编语句格式</a>
<ul>
<li><a href="5.assmbly.html#%E6%8C%87%E4%BB%A4%E4%B8%8E%E4%BC%AA%E6%8C%87%E4%BB%A4">指令与伪指令</a>
<ul>
<li><a href="5.assmbly.html#%E5%90%8D%E5%AD%97%E5%AD%97%E6%AE%B5name-field">名字字段(Name Field)</a></li>
<li><a href="5.assmbly.html#%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AD%97%E6%AE%B5operator-field">操作符字段(Operator Field)</a></li>
<li><a href="5.assmbly.html#%E6%93%8D%E4%BD%9C%E6%95%B0%E5%AD%97%E6%AE%B5operand-field">操作数字段(Operand Field)</a></li>
<li><a href="5.assmbly.html#%E6%B3%A8%E9%87%8A%E5%AD%97%E6%AE%B5comment-field">注释字段(Comment Field)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="5.assmbly.html#3-80x86%E5%AE%8F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE">3. 80x86宏汇编语言数据</a>
<ul>
<li><a href="5.assmbly.html#31-%E5%B8%B8%E6%95%B0">3.1 常数</a>
<ul>
<li><a href="5.assmbly.html#%E6%95%B0%E5%80%BC%E5%B8%B8%E6%95%B0">数值常数</a></li>
<li><a href="5.assmbly.html#%E5%AD%97%E7%AC%A6%E5%B8%B8%E6%95%B0">字符常数</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#32-%E5%8F%98%E9%87%8F">3.2 变量</a>
<ul>
<li><a href="5.assmbly.html#321-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E9%A2%84%E7%BD%AE">3.2.1 变量的定义与预置</a></li>
<li><a href="5.assmbly.html#322-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8">3.2.2 变量的使用</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#33-%E7%BC%96%E5%8F%B7">3.3 编号</a></li>
<li><a href="5.assmbly.html#34-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6">3.4 表达式与运算符</a>
<ul>
<li><a href="5.assmbly.html#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6">算数运算符</a></li>
<li><a href="5.assmbly.html#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="5.assmbly.html#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</a></li>
<li><a href="5.assmbly.html#%E6%95%B0%E5%80%BC%E8%BF%94%E5%9B%9E%E8%BF%90%E7%AE%97%E7%AC%A6">数值返回运算符</a></li>
<li><a href="5.assmbly.html#%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E8%BF%90%E7%AE%97%E7%AC%A6">属性修改运算符</a></li>
<li><a href="5.assmbly.html#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">运算符的优先级</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="5.assmbly.html#4-80x86%E5%AE%8F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BC%AA%E6%8C%87%E4%BB%A4">4. 80x86宏汇编语言伪指令</a>
<ul>
<li><a href="5.assmbly.html#41-%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5">4.1 符号定义语句</a>
<ul>
<li><a href="5.assmbly.html#411-%E7%AD%89%E5%80%BC%E8%AF%AD%E5%8F%A5">4.1.1 等值语句</a></li>
<li><a href="5.assmbly.html#412-%E7%AD%89%E5%8F%B7%E8%AF%AD%E5%8F%A5">4.1.2 等号语句</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#42-%E5%A4%84%E7%90%86%E5%99%A8%E9%80%89%E6%8B%A9%E4%BC%AA%E6%8C%87%E4%BB%A4">4.2 处理器选择伪指令</a></li>
<li><a href="5.assmbly.html#43-%E6%AE%B5%E7%BB%93%E6%9E%84%E4%BC%AA%E6%8C%87%E4%BB%A4segmentends">4.3 段结构伪指令（SEGMENT/ENDS）</a>
<ul>
<li><a href="5.assmbly.html#431-%E6%AE%B5%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4">4.3.1 段定义伪指令</a></li>
<li><a href="5.assmbly.html#432-%E6%AE%B5%E5%AF%BB%E5%9D%80%E4%BC%AA%E6%8C%87%E4%BB%A4assume">4.3.2 段寻址伪指令（ASSUME）</a></li>
<li><a href="5.assmbly.html#433-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A3%85%E8%BD%BD">4.3.3 段寄存器的装载</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#%E6%AE%B5%E7%BB%84%E4%BC%AA%E6%8C%87%E4%BB%A4group">段组伪指令（GROUP）</a></li>
<li><a href="5.assmbly.html#45-%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AE%80%E5%8C%96%E6%AE%B5%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4">4.5 内存模式和简化段定义伪指令</a>
<ul>
<li><a href="5.assmbly.html#%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F%E4%BC%AA%E6%8C%87%E4%BB%A4model">内存模式伪指令(MODEL)</a></li>
<li><a href="5.assmbly.html#%E7%AE%80%E5%8C%96%E6%AE%B5%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4">简化段定义伪指令</a></li>
<li><a href="5.assmbly.html#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7">预定义符号</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#46-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AF%B9%E5%87%86%E4%BC%AA%E6%8C%87%E4%BB%A4">4.6 定义与对准伪指令</a>
<ul>
<li><a href="5.assmbly.html#%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4org%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%8A%80%E6%9C%AF%E5%99%A8%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%E8%AE%A1%E6%95%B0%E5%99%A8%E7%94%A8%E6%9D%A5%E8%AE%B0%E8%BD%BD%E6%AD%A3%E5%9C%A8%E6%B1%87%E7%BC%96%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%96%E6%8C%87%E4%BB%A4%E7%9A%84%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%BD%93%E5%89%8D%E6%AE%B5%E5%86%85%E7%9A%84%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA%E4%BD%8D%E7%BD%AE%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%BD%93%E5%89%8D%E5%80%BC">定义伪指令(ORG)和位置技术器()汇编程序有一个位置计数器，用来记载正在汇编的数据或指令的目标代码在当前段内的偏移地址，符号“”表示位置计数器的当前值。</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#%E5%AF%B9%E5%87%86%E4%BC%AA%E6%8C%87%E4%BB%A4">对准伪指令</a></li>
<li><a href="5.assmbly.html#47-%E8%BF%87%E7%A8%8B%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4procendp">4.7 过程定义伪指令(PROC/ENDP)</a></li>
<li><a href="5.assmbly.html#48-%E5%8C%85%E5%90%AB%E4%BC%AA%E6%8C%87%E4%BB%A4include">4.8 包含伪指令(INCLUDE)</a></li>
<li><a href="5.assmbly.html#49-%E6%A0%87%E9%A2%98%E4%BC%AA%E6%8C%87%E4%BB%A4title">4.9 标题伪指令(TITLE)</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#5-%E5%AE%8F%E5%91%BD%E4%BB%A4">5. 宏命令</a>
<ul>
<li><a href="5.assmbly.html#%E5%AE%8F%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B">宏命令的使用过程</a>
<ul>
<li><a href="5.assmbly.html#%E5%AE%8F%E5%AE%9A%E4%B9%89">宏定义</a></li>
<li><a href="5.assmbly.html#%E5%AE%8F%E8%B0%83%E7%94%A8">宏调用</a></li>
<li><a href="5.assmbly.html#%E5%AE%8F%E5%B1%95%E5%BC%80">宏展开</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#%E5%AE%8F%E6%93%8D%E4%BD%9C%E7%AC%A6">宏操作符</a>
<ul>
<li><a href="5.assmbly.html#%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%AC%A6">连接操作符&amp;</a></li>
<li><a href="5.assmbly.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%AC%A6">表达式操作符%</a></li>
<li><a href="5.assmbly.html#%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%AC%A6">文本操作符&lt;&gt;</a></li>
<li><a href="5.assmbly.html#%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E7%AC%A6">字符操作符！</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#local%E4%BC%AA%E6%8C%87%E4%BB%A4">LOCAL伪指令</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#6-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF">6. 汇编语言程序设计基本技术</a>
<ul>
<li><a href="5.assmbly.html#%E9%A1%BA%E5%BA%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">顺序程序设计</a></li>
<li><a href="5.assmbly.html#%E5%88%86%E6%94%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">分支程序设计</a>
<ul>
<li><a href="5.assmbly.html#%E5%8D%95%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">单分支结构</a></li>
<li><a href="5.assmbly.html#%E5%A4%9A%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">多分支结构</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#%E5%BE%AA%E7%8E%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">循环程序设计</a>
<ul>
<li><a href="5.assmbly.html#%E5%BD%A2%E5%BC%8F">形式</a></li>
<li><a href="5.assmbly.html#%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4">循环指令</a></li>
<li><a href="5.assmbly.html#%E4%BD%BF%E7%94%A8">使用</a></li>
</ul>
</li>
<li><a href="5.assmbly.html#%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E7%94%A8%E5%8F%8A%E8%BF%94%E5%9B%9E">子程序的调用及返回</a>
<ul>
<li><a href="5.assmbly.html#%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E7%94%A8">子程序的调用</a></li>
<li><a href="5.assmbly.html#%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%94%E5%9B%9E">子程序的返回</a></li>
<li><a href="5.assmbly.html#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">传递参数</a></li>
<li><a href="5.assmbly.html#%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8">系统功能子程序调用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="5.assmbly.html#debugexe%E7%94%A8%E6%B3%95">debug.exe用法</a>
<ul>
<li><a href="5.assmbly.html#%E6%B3%A8%E6%84%8F">注意：</a></li>
<li><a href="5.assmbly.html#-r">-r</a></li>
<li><a href="5.assmbly.html#-d">-d</a></li>
<li><a href="5.assmbly.html#-e">-e</a></li>
<li><a href="5.assmbly.html#-a">-a</a></li>
<li><a href="5.assmbly.html#-t">-t</a></li>
<li><a href="5.assmbly.html#-u">-u</a></li>
<li><a href="5.assmbly.html#-g">-g</a></li>
</ul>
</li>
</ul>
<p>在第3章中介绍的微体系结构层，可看作是为第四章的指令系统层提供了一个解释器，使指令系统的功能得以实现。</p>
<p>但是，直接用机器指令代码编程是非常困难的，而让微体系结构层直接执行高级语言也不是好办法。因此，人们为所有的计算机都设计了一个汇编语言层，它位于指令系统层、操作系统层与面向问题语言层之间。</p>
<p>从这一层看去，每一种计算机都有一套自己的汇编语言和解释它的汇编器，以及相应的程序设计及开发方法。</p>
<p>本章所讨论的汇编语言级程序设计是以80x86 CPU为硬件背景，以MASM 5.0～MASM 6.0为“汇编”环境。</p>
<h1 id="1-概述"><a class="header" href="#1-概述">1. 概述</a></h1>
<p>在计算机中，为使CPU能按照人们的设想去加工处理这些信息，就必须让计算机连续地执行有序的机器指令序列，即运行用中央处理器指令系统中的指令代码（即二进制代码）编制的程序。用计算机指令代码编制的程序称为机器语言程序，这种程序是计算机实现各种运算处理功能的最终目标代码。</p>
<p>汇编语言是一种面向机器结构的低级程序设计语言，它把由机器指令组成的机器语言程序“符号化”</p>
<blockquote>
<p>也就是说，汇编语言程序中每一条指令语句都与机器语言程序的每一条机器指令一一对应。</p>
</blockquote>
<p>从目标代码的长度和程序运行的时间来看，用汇编语言编制的程序与用机器指令编制的机器语言程序是一样的</p>
<p>汇编语言程序也是一种符号式的程序，用汇编语言编制的程序称为汇编语言源程序，这个源程序仍然不能由计算机直接执行，必须经过汇编程序（Assembler）“汇编”（即翻译）成目标代码后才能直接由计算机执行。</p>
<h1 id="2-汇编语句格式"><a class="header" href="#2-汇编语句格式">2. 汇编语句格式</a></h1>
<p>语句（Statements）是汇编语言程序的基本组成单位。在汇编语言源程序中有三种语句</p>
<ul>
<li>指令语句</li>
<li>伪指令语句</li>
<li>宏指令语句（或宏调用语句）</li>
</ul>
<h2 id="指令与伪指令"><a class="header" href="#指令与伪指令">指令与伪指令</a></h2>
<p>指令语句就是第4章中所述的80x86 CPU指令系统中的各条指令。每一条指令语句在源程序汇编时都要产生相应的、可供计算机执行的指令代码（即目标代码），所以这种语句又称为可执行语句。</p>
<p>伪指令语句用于指示（命令）汇编程序对源程序如何汇编，除其所定义的具体数据要生成目标代码外，其他项均没有对应的目标代码。</p>
<p>指令语句和伪指令语句有相同的语句格式，每条语句均由如下4个字段（Fields）组成：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">名字</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">操作符</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">操作数</span><span class="mspace" style="margin-right:1em;"></span><span class="mpunct">;</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">注释</span></span></span></span></span></p>
<h3 id="名字字段name-field"><a class="header" href="#名字字段name-field">名字字段(Name Field)</a></h3>
<ul>
<li>指令语句中: 这个字段叫标号，用冒号<code>:</code>作为名字字段的结束符
<ul>
<li>标号是一条指令的符号地址，它代表该指令代码的第一个字节单元地址。</li>
</ul>
</li>
<li>伪指令语句中: 对于不同的伪指令这个字段的名字有所不同，后面用空格<code> </code>作为结束符
<ul>
<li>伪指令语句的这些名字，有的代表一个具体常数值，有的作为存储单元的符号地址。它们都可以在指令语句和伪指令语句的操作数字段中直接加以引用。</li>
</ul>
</li>
</ul>
<p>名字字段的名字统称为标识符，组成规则如下：</p>
<ul>
<li>字符个数为1-31个</li>
<li>可包含字母，数字，问号，@和下划线，不能以数字开头</li>
<li>不能使用保留字</li>
</ul>
<h3 id="操作符字段operator-field"><a class="header" href="#操作符字段operator-field">操作符字段(Operator Field)</a></h3>
<ul>
<li>指令语句中: 这个字段就是指令助记符，表示程序在运行时CPU完成的操作功能。</li>
<li>伪指令中: 这个字段就是本章后面将要介绍的各种伪指令，表示汇编程序如何汇编（翻译）源程序各条语句。
<blockquote>
<p>如数据定义伪指令DB、DW、DD；段定义伪指令SEGMENT；过程定义伪指令PROC等</p>
</blockquote>
</li>
</ul>
<h3 id="操作数字段operand-field"><a class="header" href="#操作数字段operand-field">操作数字段(Operand Field)</a></h3>
<ul>
<li>本字段与操作符字段用空格<code> </code>或制表符<code>Tab</code>作为分界符</li>
<li>如果本字段要求有两个或两个以上操作数，那么各操作数之间用逗号<code>,</code>或空格<code> </code>分隔。</li>
</ul>
<h3 id="注释字段comment-field"><a class="header" href="#注释字段comment-field">注释字段(Comment Field)</a></h3>
<p>必须以分号<code>;</code>作为字段的开始符</p>
<blockquote>
<p>一条语句可以只有注释字段，此时该语句以分号<code>;</code>开始</p>
</blockquote>
<h1 id="3-80x86宏汇编语言数据"><a class="header" href="#3-80x86宏汇编语言数据">3. 80x86宏汇编语言数据</a></h1>
<p>在指令语句和伪指令语句中，操作数字段的主要内容是数据。宏汇编语言数据通常包含数值和属性两部分，这两部分对一条语句汇编成目标代码都有着直接关系。80x86宏汇编语言能识别的数据有：常数、变量和标号。</p>
<h2 id="31-常数"><a class="header" href="#31-常数">3.1 常数</a></h2>
<p>常数是没有任何属性的纯数值数据，在汇编源程序期间，它的值已能完全确定，且在程序运行中，它也不会发生变化。</p>
<h3 id="数值常数"><a class="header" href="#数值常数">数值常数</a></h3>
<p>可以用不同进制数的形式表示数值常数</p>
<ol>
<li>二进制</li>
</ol>
<p>以字母B结尾的0和1组成的数字序列</p>
<ol start="2">
<li>八进制</li>
</ol>
<p>以字母O或Q结尾的0～7数字序列组成的数</p>
<ol start="3">
<li>十进制</li>
</ol>
<p>0～9数字序列组成的数，可以用字母D结尾，也可以没有结尾字母</p>
<ol start="4">
<li>十六进制数</li>
</ol>
<p>以字母H结尾的0～9和A～F（或a～f）数字字母序列组成的数</p>
<p>凡以字母A～F（或a～f）为起始的十六进制数，必须在前面冠以数字0，否则汇编程序认作符号。</p>
<h3 id="字符常数"><a class="header" href="#字符常数">字符常数</a></h3>
<p>用单引号或双引号括起来的一个或多个字符，这些字符用它的ASCII码形式存储在存储单元中。</p>
<h2 id="32-变量"><a class="header" href="#32-变量">3.2 变量</a></h2>
<p>变量代表存放在存储单元中的数据，并作为存储数据单元的符号地址。</p>
<h3 id="321-变量的定义与预置"><a class="header" href="#321-变量的定义与预置">3.2.1 变量的定义与预置</a></h3>
<p>定义变量就是分配存储单元，这些存储单元可以预置数据初值或仅保留若干存储单元。定义与预置变量的语句格式如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">变量名</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">数据定义伪指令</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.3em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span></span></span></span></span></p>
<ol>
<li>变量名是任选的</li>
</ol>
<p>变量名是任选的</p>
<ul>
<li>若选用变量名，那么它就是这些存储单元中首字节单元的符号地址</li>
<li>在程序中访问这些存储单元时，就可以直接引用这个变量名。</li>
</ul>
<ol start="2">
<li>数据定义伪指令</li>
</ol>
<p>数据定义伪指令有：DB、DW和DD，它们用来定义字节、字和双字数据。</p>
<p>可以用DQ和DT来定义8和10字节的数据。80386及其以上机型中还可用DF来定义6字节数据。DW和DD伪指令还可定义存储地址，而DF伪指令可定义存储由16位段基值和32位偏移地址组成的地址指针。</p>
<p>经过定义后的变量（变量名），它们拥有一下三个属性</p>
<ul>
<li>
<p>段属性（SEG）</p>
<p>段属性表示变量存放在哪一个逻辑段中。</p>
</li>
<li>
<p>偏移地址属性（OFFSET）</p>
<p>偏移地址属性表示变量在逻辑段中离段起始单元的距离（字节数）。</p>
</li>
</ul>
<blockquote>
<p>段和偏移地址两个属性就构成一个变量的逻辑地址</p>
</blockquote>
<ul>
<li>
<p>类型属性（TYPE）</p>
<p>类型属性表示一个变量的数据大小，是字节（8位二进制数）、字（16位二进制数）、双字（32位二进制数）数据，或是6字节、8字节、10字节数据。这一属性是由数据定义伪指令DB、DW、DD、DF、DQ、DT来确定的。</p>
</li>
</ul>
<ol start="3">
<li>表达式</li>
</ol>
<p>数据定义伪指令（DB、DW等）在为数据分配存储单元的同时，还可以给这些存储单元预置初值，每个初值由相应的表达式确定。定义变量语句中表达式可以有如下4种情况：</p>
<ul>
<li>
<p>数值表达式</p>
<ul>
<li>在单一的存储单元，中设置一个数据
<blockquote>
<p>如<code>var DB 50H</code></p>
</blockquote>
</li>
<li>在连续的若干存储单元中设置数据，使用逗号将值隔开
<blockquote>
<p>如<code>var DB 50H,20H</code></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>字符串表达式</p>
<ul>
<li>字符串表达式中的字符串必须用引号（单引号或双引号）括起来</li>
<li>字符串中各字符均以ASCII码形式存放在相应的存</li>
<li>字符串表达式的表示方法和存储顺序：
<ul>
<li>
<p>在DB伪指令中</p>
<ul>
<li>一个字符串表达式可以连续书写少于255个的字符</li>
<li>每一个字符分配一个字节存储单元，按地址递增的排列顺序依次存放字符串自左至右的每一个字符</li>
</ul>
</li>
<li>
<p>DW伪指令中</p>
<ul>
<li>一个字符串表达式只能由1～2个字符组成</li>
<li>DW伪指令为每一个字符串表达式分配两个字节存储单元</li>
<li>如果表达式由两个字符组成，前一个字符的ASCII码存放在高字节中，后一个字符的ASCII码存放在低字节中。</li>
<li>如果表达式由一个字符组成，那么该字存储单元的高字节存放00，而唯一字符的ASCII码存放在低字节存储单元中。</li>
</ul>
</li>
<li>
<p>DD伪指令中</p>
<ul>
<li>一个字符串表达式也只能由1～2个字符组成</li>
<li>为每个表达式分配4字节的存储单元</li>
<li>两个低字节存储单元存放这1～2个字符的ASCII码（存储的顺序与DW伪指令相同），另外两个高字节存储单元均自动存放00。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="assets/2024-11-16-12-06-56.png" alt="使用不同的伪指令存储字符串&#39;string&#39;" /></p>
<ul>
<li>
<p>？表达式</p>
<ul>
<li>表示仅分配相应数量的存储单元</li>
</ul>
</li>
<li>
<p>带DUP表达式</p>
<ul>
<li>重复数据操作符DUP（Duplication），其格式如下
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">变量名</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">数据定义伪指令</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></span>
<ul>
<li>表达式1是重复的次数</li>
<li>表达式2是重复数据的内容。</li>
</ul>
<blockquote>
<p>DUP操作符可以嵌套使用</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="322-变量的使用"><a class="header" href="#322-变量的使用">3.2.2 变量的使用</a></h3>
<p>变量定义和预置后才可以使用。对变量的使用就是对变量名的引用。在程序的其他语句中，对变量名的使用通常分两种情况:</p>
<ol>
<li>在指令语句的操作数字段中</li>
</ol>
<p>引用的变量名作为地址表达式的组成部分之一。</p>
<ol start="2">
<li>数据定义语句的操作数字段上引用了变量名</li>
</ol>
<p>在为DW或DD伪指令分配的存储单元中，将预置被引用变量名的地址部分</p>
<blockquote>
<p>即存储引用变量的地址</p>
</blockquote>
<ul>
<li>如是DW，则仅有被引用变量名的偏移地址；</li>
<li>如是DD，则前两个字节存放偏移地址，后两个字节存放段基值。</li>
</ul>
<h2 id="33-编号"><a class="header" href="#33-编号">3.3 编号</a></h2>
<p>标号是一条指令的符号地址。</p>
<p>在无条件转移指令、条件转移指令和循环指令的操作数位置上，通常用标号作为程序转移指令的目标地址。</p>
<p>与变量一样，每个标号也具有3个属性：</p>
<ol>
<li>段属性（SEG）</li>
</ol>
<p>表示指令在哪个逻辑段中</p>
<ol start="2">
<li>偏移地址属性（OFFSET）</li>
</ol>
<p>表示这条指令离段起始单元之间的字节数（准确地讲，是这条指令目标代码的首字节单元与段起始单元之间的字节数）</p>
<blockquote>
<p>上述两个属性构成了这条指令的逻辑地址</p>
</blockquote>
<ol start="3">
<li>类型属性（TYPE）</li>
</ol>
<p>表示它的转移特性，即该标号是作为段内转移指令还是段间转移指令的目标地址。</p>
<ul>
<li>NEAR（近）: 表示段内转移，本标号只能作为标号所在段的转移指令的目标地址。</li>
<li>FAR（远）: 表示段间转移，本标号可作为其他段（不是标号所在段）的转移指令的目标地址。</li>
</ul>
<p>标号的类型属性可以用下面两种方法来设置：</p>
<ul>
<li>
<p>隐含方式</p>
<p>当某指令语句选用一个标号后，该标号就隐含为NEAR属性(缺省)</p>
</li>
<li>
<p>使用LABEL伪命令</p>
<ul>
<li>LABEL伪指令语句格式如下：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">名字</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">BE</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">类型</span></span></span></span></span></li>
<li>与指令语句连用时，LABEL语句中的名字就是一个新的标号，其类型可选择NEAR或FAR</li>
<li>当与数据定义语句连用时，LABEL语句中的名字就是一个新的变量名，其类型可选择BYTE，WORD或DWORD。</li>
<li>这个新的标号或变量名，与它们连用的指令语句的标号或数据定义语句的变量名有相同的段和偏移地址属性，即与它连用的语句有相同的逻辑地址。只是类型不同，存取控制方式不同</li>
</ul>
</li>
</ul>
<h2 id="34-表达式与运算符"><a class="header" href="#34-表达式与运算符">3.4 表达式与运算符</a></h2>
<p>表达式由常数、变量和标号通过某些运算符连接而成的。</p>
<p>任一表达式的数据计算或操作类型（指数据的大小、转移特性等）的确定是在汇编源程序过程中完成的，不是在程序运行时获得的。</p>
<p>80x86宏汇编语言程序设计</p>
<ul>
<li>可使用的表达式有两种：数值表达式和地址表达式。</li>
<li>表达式中的运算符有：算术运算符、逻辑运算符、关系运算符、数值返回运算符和属性修改运算符。</li>
</ul>
<h3 id="算数运算符"><a class="header" href="#算数运算符">算数运算符</a></h3>
<ul>
<li>
<p>+（加）</p>
</li>
<li>
<p>− （减）</p>
<p>减法可用于同段两个操作数地址（以变量名表示）的运算，其结果是一个常数，表示这两个地址之间的相距字节数。</p>
</li>
<li>
<p>*（乘）</p>
</li>
<li>
<p>/（除）</p>
<p>除法运算只取商的整数部分</p>
</li>
<li>
<p>MOD（模除）</p>
<p>MOD运算符是进行整数除法，运算结果只取它的余数部分。</p>
</li>
<li>
<p>SHL（左移）</p>
</li>
<li>
<p>SHR（右移）</p>
</li>
</ul>
<blockquote>
<p>+、−、*、/运算中，参加运算的数和运算的结果均是整数。</p>
</blockquote>
<h3 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h3>
<ul>
<li>AND（逻辑与）</li>
<li>OR（逻辑或）</li>
<li>NOT（逻辑非）</li>
<li>XOR（逻辑异或）</li>
</ul>
<p>运算符格式：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">逻辑运算符</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">NOT</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<blockquote>
<p>逻辑运算符是按位进行逻辑运算的。</p>
</blockquote>
<h3 id="关系运算符"><a class="header" href="#关系运算符">关系运算符</a></h3>
<ul>
<li>EQ（相等）</li>
<li>NE（不等）</li>
<li>LT（小于）</li>
<li>LE（小于等于）</li>
<li>GT（大于）</li>
<li>GE（大于等于）</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">关系运算符</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<p>如果比较关系成立，则用全1表示真，否则用全0表示假。</p>
<p>如果比较的是数值表达式，则按无符号数比较；</p>
<p>如果比较的是同段内的地址表达式，则比较它们的偏移地址。</p>
<h3 id="数值返回运算符"><a class="header" href="#数值返回运算符">数值返回运算符</a></h3>
<p>这种运算符的运算对象必须是存储器操作数，即由变量名或标号组成的地址表达式。运算的结果是一个纯数值，这个数值表示该存储器操作数地址的组成部分及其某些特征。数值返回运算符的格式如下：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">数值返回运算符</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">地址表达式</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<ol>
<li>SEG运算符和OFFSET运算符</li>
</ol>
<p>运算符结果分别是这个变量名或标号所在段的段基值或它在段内的偏移地址</p>
<ol start="2">
<li>TYPE运算符</li>
</ol>
<p>TYPE运算符是用数值形式表示变量和标号的类型属性</p>
<p><img src="assets/2024-11-16-12-45-01.png" alt="type运算符返回值所对应的类型" /></p>
<ol start="3">
<li>LENGTH运算符和SIZE运算符</li>
</ol>
<p>如果变量是用重复数据操作符DUP定义的，那么运算符LENGTH的运算结果是外层DUP的重复次数；如果没有用DUP定义的变量，运算结果总是1。</p>
<p>而运算符SIZE是LENGTH和TYPE两个运算结果的乘积。</p>
<h3 id="属性修改运算符"><a class="header" href="#属性修改运算符">属性修改运算符</a></h3>
<p>这种运算符用来对变量、标号或存储器操作数的类型属性进行说明和设定。
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">类型</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">PTR</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">地址表达式</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<p>把PTR运算符右边地址表达式所确定的存储单元<strong>临时</strong>设定为PTR运算符左边的“类型”（BYTE、WORD、DWORD或NEAR、FAR）。</p>
<h3 id="运算符的优先级"><a class="header" href="#运算符的优先级">运算符的优先级</a></h3>
<p><img src="assets/2024-11-16-12-47-38.png" alt="运算符的优先级表" /></p>
<h1 id="4-80x86宏汇编语言伪指令"><a class="header" href="#4-80x86宏汇编语言伪指令">4. 80x86宏汇编语言伪指令</a></h1>
<h2 id="41-符号定义语句"><a class="header" href="#41-符号定义语句">4.1 符号定义语句</a></h2>
<p>把某些常数或表达式用一个特定符号表示</p>
<h3 id="411-等值语句"><a class="header" href="#411-等值语句">4.1.1 等值语句</a></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">符号</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">EQ</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<p>EQU是等值伪指令，把表达式的值或符号赋给EQU左边的符号。</p>
<p>表达式可以是以下三种之一：</p>
<ul>
<li>常数或数值表达式</li>
<li>地址表达式</li>
<li>变量、标号或指令助记符</li>
</ul>
<p>等值伪指令语句定义的符号仅在汇编源程序时作为替代符号使用，不产生任何目标代码，也不占有存储单元。类似于<code>#define</code></p>
<blockquote>
<p>同一符号不能用EQU伪指令重新定义</p>
</blockquote>
<h3 id="412-等号语句"><a class="header" href="#412-等号语句">4.1.2 等号语句</a></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">符号</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">表达式</span></span></span></span></span></p>
<p>这种语句的含义和表达式的内容都与等值语句相同，不同的是等号语句</p>
<ul>
<li>可以重新定义符号</li>
<li>不能为指令助记符定义别名</li>
</ul>
<h2 id="42-处理器选择伪指令"><a class="header" href="#42-处理器选择伪指令">4.2 处理器选择伪指令</a></h2>
<p>作用：确定使用的指令系统</p>
<blockquote>
<p>缺省默认只使用8086/8088指令系统和8087协处理器指令集。</p>
</blockquote>
<p>处理器选择伪指令通常是放在源程序的开头位置，格式：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">.</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">目标处理器代号</span></span></span></span></span></p>
<blockquote>
<p>在程序中某处要使用一条286，386，486或586所增加的指令，那么可以在这条指令语句前加上处理器选择伪指令。</p>
</blockquote>
<h2 id="43-段结构伪指令segmentends"><a class="header" href="#43-段结构伪指令segmentends">4.3 段结构伪指令（SEGMENT/ENDS）</a></h2>
<p>在编制一个80x86汇编语言源程序时，段是基础。这有两方面的含义</p>
<ul>
<li>一是必须按段来构造程序</li>
<li>二是在程序执行时，要凭借几个段寄存器对各个段的存储单元进行访问。</li>
</ul>
<h3 id="431-段定义伪指令"><a class="header" href="#431-段定义伪指令">4.3.1 段定义伪指令</a></h3>
<pre><code class="language-asm">段名 SEGMENT [定位类型] [组合类型] [使用类型] ['类别名']
    ...
    ...
段名 ENDS
</code></pre>
<p>每一个段都以SEGMENT伪指令开始，以ENDS伪指令结束，在这两个伪指令之间可以编写各种语句序列。在SEGMENT伪指令中有几个参数可供选择。</p>
<ol>
<li>段名</li>
</ol>
<p>段名由用户自己选定，必须选用，且开始与结尾的段名应一致。</p>
<ol start="2">
<li>定位类型（Align Type）</li>
</ol>
<p>定位类型表示该段装入内存时，对段起始边界的要求。定位类型有下列4种选择：</p>
<ul>
<li>
<p>PAGE（页）
表示本段从一个页的边界开始。从存储器0号单元开始，每256字节为一页。所以段的起始地址一定能被256整除。</p>
<blockquote>
<p>这样段的起始地址（即段基址）的最后8位二进制数一定为0（即以00H结尾）。</p>
</blockquote>
</li>
<li>
<p>PARA（节）（缺省）</p>
<p>表示本段从一个小节的边界开始（一个小节为16字节）。所以段的起始地址一定能被16整除，最后4位二进制数一定为0</p>
</li>
<li>
<p>WORD（字）</p>
<p>表示本段从一个偶字节地址开始。段起始地址的最后1位二进制数一定是0</p>
</li>
<li>
<p>BYTE（字节）</p>
<p>表示本段起始地址可从任一地址开始。即前一个段结束就可设置本段，在两个段之间不留空单元。</p>
</li>
</ul>
<ol start="2">
<li>组合类型(Combine Type)</li>
</ol>
<p>组合类型指定段与段之间是怎样连接和定位的。这种类型有6种可供选择：</p>
<ul>
<li>
<p>NONE(缺省)</p>
<p>表示本段与其他段无连接关系，按照源程序中各个逻辑段的自然顺序依次在存储器中分配各段存储单元。</p>
</li>
<li>
<p>PUBLIC</p>
<p>满足定位类型的前提下，本段与其他有相同段名、且也用PUBLIC说明的段在存储单元分配时邻接在一起，形成一个新的逻辑段，公用一个段基址。所有存储单元的偏移地址都调整为相对于新逻辑段的起始地址。</p>
</li>
<li>
<p>COMMON</p>
<p>产生一个覆盖段。表示本段与其他有相同段名、且也用COMMON说明的段设置相同的起始地址，共享相同的存储区。共享存储区的长度由同名段中最大的段确定。</p>
</li>
<li>
<p>STACK</p>
<p>自动产生一个堆栈段。把所有相同段名的段连接在一起，形成一个新的逻辑段。系统自动对段寄存器SS初始化为新逻辑段的起始地址，并同时初始化堆栈指针SP。</p>
<blockquote>
<p>通常，用户程序中至少有一个段是用STACK说明的，否则需在程序运行中对SS和SP进行初始化。</p>
</blockquote>
</li>
<li>
<p>AT表达式</p>
<p>表示本段可定位在表达式所指定的小节边界上。</p>
</li>
<li>
<p>MEMORY</p>
<p>表示本段在存储器中应定位在所有其他段的最高地址。</p>
</li>
</ul>
<ol start="4">
<li>使用类型（Use Type）</li>
</ol>
<p>使用类型是用于80386，80486和Pentium处理器机型的两种段模式选择：</p>
<ul>
<li>USE 16 段基值为16位，偏移地址为16位。一个段的最大寻址空间为64 KB。</li>
<li>USE 32 段基值为16位，偏移地址为32位。一个段的最大寻址空间为4 GB。</li>
</ul>
<ol start="5">
<li>类别名</li>
</ol>
<p>类别名必须用单引号括起来，并由用户自己选用。</p>
<p>在程序连接处理时，连接程序LINK把类别名相同的所有段存放在连续的存储区内，如在组合类型中没有选择PUBLIC，COMMON，MEMORY时，这些类别名相同的段仍然是各自独立的段。</p>
<h3 id="432-段寻址伪指令assume"><a class="header" href="#432-段寻址伪指令assume">4.3.2 段寻址伪指令（ASSUME）</a></h3>
<p>由段寄存器指向的段是当前段，在任何时刻，只有当前段内的存储单元才可访问。在汇编源程序时，汇编程序必须知道哪些段是当前段，且它们分别由哪个段寄存器指向。</p>
<p>ASSUME伪指令就是告诉汇编程序，在下面程序中哪些段是当前段，它们分别由哪个段寄存器指向。</p>
<p>ASSUME伪指令只影响汇编源程序时的设定，而不影响程序运行时段寄存器的设置。</p>
<p>ASSUME伪指令格式如下:
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">SS</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">ME</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">段寄存器名</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">段名</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">段寄存器名</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">段名</span><span class="mord">...</span></span></span></span></span></p>
<ul>
<li>段寄存器名是指CS、SS、DS和ES（对于80386及其后续机型还有FS和GS）中的一个</li>
<li>段名是指在SEGMENT/ENDS伪指令语句中定义的段名</li>
<li>段寄存器名和段名之间必须用冒号“：”分隔。</li>
<li>可以用关键字NOTHING作为段名将前面的某些设置取消或直接<code>ASSUME NOTHING</code>将所有段寄存器取消</li>
</ul>
<h3 id="433-段寄存器的装载"><a class="header" href="#433-段寄存器的装载">4.3.3 段寄存器的装载</a></h3>
<ol>
<li>DS和ES的装载</li>
</ol>
<p>如在指令的操作数字段上引用段名，就是将该段的段基值以立即数形式出现在操作数字段中。</p>
<blockquote>
<p>MOV传送指令不能把立即数直接传送给段寄存器，所以只能把段基值先送给一个通用寄存器，然后再转送给段寄存器DS或ES。</p>
</blockquote>
<ol start="2">
<li>SS的装载</li>
</ol>
<p>SS是堆栈段寄存器，它的装载就是对堆栈的设置。堆栈的使用离不开堆栈指针SP，所以在完成SS的装入的同时要实现对SP的设置。对SS的装载有如下两种办法：</p>
<ul>
<li>
<p>自动装载</p>
<ul>
<li>在段定义伪指令（SEGMENT）的组合类型中选择“STACK”参数，指示这个段是堆栈段。</li>
<li>当含有这个段的目标代码载入内存后，SS已自动装载STACK1段的段基值，同时堆栈指针SP也自动指向这个段最大地址+1单元（即堆栈底部+1的存储单元）。</li>
</ul>
</li>
<li>
<p>用执行指令的方法装载</p>
</li>
</ul>
<ol start="3">
<li>CS的装载</li>
</ol>
<p>CS和IP提供了当前执行目标代码的段基值和偏移地址。为保证程序的正确执行，CS和IP载入新值必须一起完成。</p>
<ul>
<li>
<p>使用结束伪指令<br />
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">EN</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">地址表达式</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<ul>
<li>
<p>地址表达式一般是一个已定义的标号，也可以是一个标号加或减一个常数。地址表达式的值是这个程序要执行的第1条指令语句的地址。</p>
</li>
<li>
<p>END伪指令语句一方面告诉汇编程序，源程序到此结束，在END语句后面的任何语句均被汇编程序略去；
另一方面待程序目标代码装入内存储器时，系统用END语句中的地址表达式所示单元的段基值和偏移地址分别自动载入CS和IP中。</p>
</li>
</ul>
</li>
<li>
<p>执行段间程序转移指令时，CPU将自动修改CS和IP的内容。</p>
</li>
</ul>
<h2 id="段组伪指令group"><a class="header" href="#段组伪指令group">段组伪指令（GROUP）</a></h2>
<p>把程序中若干不同段名的段组成一个段组，在目标程序装入内存时，一个段组的若干段都装在一个≤64KB的物理段中。段组伪指令GROUP的格式如下：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">段组名</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">GRO</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">段名</span><span class="mord">1</span><span class="mord cjk_fallback">，短命</span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord">...</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<p>此时，对段组的引用就是使用段组名</p>
<h2 id="45-内存模式和简化段定义伪指令"><a class="header" href="#45-内存模式和简化段定义伪指令">4.5 内存模式和简化段定义伪指令</a></h2>
<h3 id="内存模式伪指令model"><a class="header" href="#内存模式伪指令model">内存模式伪指令(MODEL)</a></h3>
<p>内存模式伪指令MODEL用于确定用户程序中代码和数据如何安排和存放，以及其占用内存的大小。</p>
<p>内存模式伪指令MODEL的格式如下：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">./</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">MO</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">内存模式</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<ol>
<li>
<p>Tiny(最小型模式)</p>
<p>程序的代码和数据都放在同一个64 KB的段内。这就是扩展名为.COM的程序形式。程序的转移仅是段内转移，对数据的存取是在一个段内进行。</p>
</li>
<li>
<p>Small(小型模式)</p>
<p>程序的代码放在一个64 KB的段内，数据放在另一个64 KB的段内。程序的转移仅是段内转移，对数据的存取也是在一个段内进行。</p>
<blockquote>
<p>这是最常用的内存模式。</p>
</blockquote>
</li>
<li>
<p>Medium(中型模式)</p>
<p>程序的代码可以放在多个段中，但数据则放在一个64 KB的段内。这样，程序的转移就有可能是段间转移，而对数据的存取仍是在一个段内进行。</p>
</li>
<li>
<p>Compact(压缩型模式)</p>
<p>程序的代码放在一个64 KB的段内，而数据则可存放在多个段中。这样，程序的转移是段内转移，而对数据的存取要在不同段中进行</p>
</li>
<li>
<p>Large(大型模式)</p>
<p>程序中代码和数据都可以分别放在多个段中。因此，程序的转移就有可能是段间转移，而对数据的存取也可能要在不同段中进行。</p>
</li>
<li>
<p>Huge(巨型模式)</p>
<p>与大型模式（Large）类同，不同的是数据段可以超过64 KB。</p>
</li>
</ol>
<h3 id="简化段定义伪指令"><a class="header" href="#简化段定义伪指令">简化段定义伪指令</a></h3>
<p>使用简化段定义伪指令之前必须使用内存模式伪指令MODEL。</p>
<p>简化段定义伪指令有：</p>
<pre><code class="language-asm">. CODE [段名];代码段。若只有一个代码段，段名可任选；
             ;若是多个代码段，则应为每个代码段选定一个段名

. DATE;数据段，已初始化数据
. DATE?;数据段，未初始化数据
. CONST;常数段
. FARDATA [段名];远数据段。已初始化远数据
. FARDATA? [段名];远数据段。未初始化远数据
. STACK [长度];堆栈段。可指定堆栈的大小，缺省为1KB
</code></pre>
<ul>
<li>若FARDATA未指定段名，默认段名是FAR_DATA</li>
<li>而FARDATA？的默认段名是FAR_BSS</li>
</ul>
<blockquote>
<p>远数据段的设置主要是为了与高级语言接口连接</p>
</blockquote>
<p>一个简化段定义的开始也就是前一个段的结束，而不必使用ENDS伪指令，仅在最后一个段用结束伪指令END表示全部程序的结束。</p>
<h3 id="预定义符号"><a class="header" href="#预定义符号">预定义符号</a></h3>
<p>MASM提供一些在程序中使用的预定义符号，它类似于EQU伪指令定义的等价符号</p>
<ol>
<li>
<p>@Model</p>
<p>内存模式用数值形式表示。即Tiny = 1，Small= 2，Compact = 3，Medium = 4，Large = 5，Huge = 6。</p>
</li>
<li>
<p>@Code</p>
<p>简化段定义.CODE的等价别名，即代码段段名。</p>
</li>
<li>
<p>@Data</p>
<p>简化段定义.DATA的等价别名，即近数据段段名。</p>
</li>
<li>
<p>@Fardata</p>
<p>简化段定义.FARDATA的等价别名，即远数据段段名。</p>
</li>
<li>
<p>@Stack</p>
<p>简化段定义.STACK的等价别名，即堆栈段段名</p>
</li>
<li>
<p>@Codesize</p>
<p>用数值表示代码段的情况</p>
<ul>
<li>当内存模式为Tiny，Small，Compact时，只有一个代码段，此值为0</li>
<li>当内存模式为Medium，Large，Huge时，有多个代码段，此值为1。</li>
</ul>
</li>
<li>
<p>@Datasize</p>
<p>用数值表示数据段的情况。</p>
<ul>
<li>当内存模式为Tiny，Small，Medium时
<ul>
<li>只有一个数据段，此值为0</li>
</ul>
</li>
<li>当内存模式为Compact，Large时
<ul>
<li>有多个数据段，此值为1</li>
</ul>
</li>
<li>当内存模式为Huge时
<ul>
<li>有多个数据段且有超过64 KB的大数据段，此值为2。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="46-定义与对准伪指令"><a class="header" href="#46-定义与对准伪指令">4.6 定义与对准伪指令</a></h2>
<h3 id="定义伪指令org和位置技术器汇编程序有一个位置计数器用来记载正在汇编的数据或指令的目标代码在当前段内的偏移地址符号表示位置计数器的当前值"><a class="header" href="#定义伪指令org和位置技术器汇编程序有一个位置计数器用来记载正在汇编的数据或指令的目标代码在当前段内的偏移地址符号表示位置计数器的当前值">定义伪指令(ORG)和位置技术器(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mord cjk_fallback">汇编程序有一个位置计数器，用来记载正在汇编的数据或指令的目标代码在当前段内的偏移地址，符号</span><span class="mord">“</span></span></span></span>”表示位置计数器的当前值。</a></h3>
<p>定位伪指令ORG是对位置计数器设置、修改的控制命令。ORG伪指令语句格式如下：
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ORG</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">表达式</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<p>ORG伪指令语句把表达式的值赋给位置计数器，即ORG语句后面的目标代码（指令代码或数据）由表达式给定的值作为起始偏移地址。</p>
<blockquote>
<p>且表达式中可以包含位置计数器的现行值＄。</p>
</blockquote>
<h2 id="对准伪指令"><a class="header" href="#对准伪指令">对准伪指令</a></h2>
<p>对准伪指令EVEN也是对位置计数器的一个控制命令，它把位置计数器的值调整为偶数。</p>
<p>对准伪指令EVEN语句格式如下:
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">EN</span></span></span></span></span></p>
<p>在存储器中，对字单元（包括双字等多字单元）进行存取操作时，如是偶地址，那么存取速度较快。所以对准伪指令EVEN主要应用在定义字数据（包括多字数据）前，用以对位置计数器进行调整。</p>
<h2 id="47-过程定义伪指令procendp"><a class="header" href="#47-过程定义伪指令procendp">4.7 过程定义伪指令(PROC/ENDP)</a></h2>
<p>在程序设计中，我们常把具有一定功能的程序段组织成一个子程序。MASM宏汇编程序用“过程”来构造子程序。过程定义伪指令语句的格式如下：</p>
<pre><code class="language-asm">过程名 PROC [NEAR/FAR]
    ...
    指令序列
    ...
过程名 EDNP
</code></pre>
<p>一个过程名类同于标号，它也有三个属性：段、偏移地址 和类型属性。</p>
<blockquote>
<p>如没有选择类型属性，则隐含为NEAR</p>
</blockquote>
<p>在一个过程（子程序）中，至少有一条子程序返回指令RET，它可以在过程中的任何位置，但过程执行的最后一条指令一定是返回指令RET。</p>
<h2 id="48-包含伪指令include"><a class="header" href="#48-包含伪指令include">4.8 包含伪指令(INCLUDE)</a></h2>
<pre><code class="language-asm">INCLUDE &lt;文件名&gt;
</code></pre>
<p>INCLUDE伪指令把指定的文件插入到现在正在汇编的源程序中，作为源程序的一个组成部分</p>
<h2 id="49-标题伪指令title"><a class="header" href="#49-标题伪指令title">4.9 标题伪指令(TITLE)</a></h2>
<pre><code class="language-asm">TITLE &lt;文本&gt;
</code></pre>
<p>标题伪指令TITLE是给程序指定一个标题，以便在列表文件中每一页的第一行都显示这个标题文本。</p>
<p>文本内容可以由程序设计人员任选名字或字符串，但字符个数不得超过80。标题伪指令语句应在源程序开始处使用</p>
<h1 id="5-宏命令"><a class="header" href="#5-宏命令">5. 宏命令</a></h1>
<h2 id="宏命令的使用过程"><a class="header" href="#宏命令的使用过程">宏命令的使用过程</a></h2>
<h3 id="宏定义"><a class="header" href="#宏定义">宏定义</a></h3>
<p>使用宏指令，必须先用<code>MACRO/ENDM</code>进行宏定义，存在两种形式</p>
<pre><code class="language-asm">;1. 无参数的宏定义
宏名 MACRO
    ...
    宏体
    ...
    ENDM

;2. 带参数的宏定义
宏名 MACRO 形参1，形参2，...
    ...
    宏体
    ...
    ENDM
</code></pre>
<p>宏定义不出现在程序的目标代码中，因此宏定义可以在源程序的任何位置上。</p>
<h3 id="宏调用"><a class="header" href="#宏调用">宏调用</a></h3>
<pre><code class="language-asm">; 1.无参数宏调用
宏名

; 2. 带参数宏调用
宏名 实参1，实参2，...
</code></pre>
<ul>
<li>如实参个数比形参个数多，那么多余的实参自动被略去</li>
<li>如实参个数比形参个数少，那么在宏展开时，没有实参替代的形参自动用空白串替代。</li>
</ul>
<h3 id="宏展开"><a class="header" href="#宏展开">宏展开</a></h3>
<p>当宏汇编程序扫描到宏指令语句（宏调用）时，就把宏定义中宏体的目标代码插入在宏调用的位置上，这就是宏展开。</p>
<h2 id="宏操作符"><a class="header" href="#宏操作符">宏操作符</a></h2>
<p>在宏定义和宏调用中，有几个常用的宏操作符。</p>
<h3 id="连接操作符"><a class="header" href="#连接操作符">连接操作符&amp;</a></h3>
<p>在宏定义中使用连接操作符&amp;时，它可以在形参的前面，也可以在形参的后面。</p>
<p>在宏展开时，对应形参的实参与它后面或前面的符号连接在一起构成一个新的符号。</p>
<h3 id="表达式操作符"><a class="header" href="#表达式操作符">表达式操作符%</a></h3>
<pre><code class="language-asm">%表达式
</code></pre>
<p>表达式操作符%告诉宏汇编程序获取表达式的值，而不是获取表达式文本本身。</p>
<h3 id="文本操作符"><a class="header" href="#文本操作符">文本操作符&lt;&gt;</a></h3>
<p>有时一个实参是由一串字符、逗号或空格构成，可以用文本操作符＜＞把一个完整的实参括起来，作为一个单一的实参。</p>
<h3 id="字符操作符"><a class="header" href="#字符操作符">字符操作符！</a></h3>
<pre><code class="language-asm">!字符
</code></pre>
<p>惊叹号“!”后面的字符不作为特别的操作符使用，而是字符本身。</p>
<blockquote>
<p>转义符</p>
</blockquote>
<h2 id="local伪指令"><a class="header" href="#local伪指令">LOCAL伪指令</a></h2>
<pre><code class="language-asm">LOCAL &lt;符号表&gt;
</code></pre>
<p>宏定义中如含有变量名或标号，且在同一源程序中又多次被宏调用，那么宏汇编程序在宏展开时，要产生多个相同的变量名或标号，这就不能满足变量名或标号在同一程序中必须唯一的要求，从而产生汇编出错。为避免这个错误，又要在宏定义中能使用变量名或标号，应使用局部符号伪指令LOCAL。</p>
<p>宏汇编程序在宏展开时，对LOCAL伪指令指定的变量名和标号自动生成格式为<code>？？× × × ×</code>的符号，其中后4位顺序使用0000～FFFF的十六进制数字。</p>
<h1 id="6-汇编语言程序设计基本技术"><a class="header" href="#6-汇编语言程序设计基本技术">6. 汇编语言程序设计基本技术</a></h1>
<blockquote>
<p>摘抄自ppt</p>
</blockquote>
<h2 id="顺序程序设计"><a class="header" href="#顺序程序设计">顺序程序设计</a></h2>
<p>顺序结构程序: 按编写指令的顺序执行，无分支、循环、转移，且每条指令只执行一次</p>
<ol>
<li>用到的指令</li>
</ol>
<ul>
<li>数据传送类: mov,xchg,push,pop,lea,lds,les,pushf,popf,lahf,sahf</li>
<li>算数运算类: add,adc,inc,sub,sbb,dec,neg,cmp,mul,imul,div,idiv,cbw,cwd</li>
<li>逻辑运算类: and,or,not,xor,test,shl,sal,shr,sar,rol,ror,rcl,rcr</li>
</ul>
<ol start="2">
<li>查表举例</li>
</ol>
<ul>
<li>将TABLE的偏移地址送进BX</li>
<li>将需要查找的表内偏移地址加上BX的值后送回BX</li>
<li>以BX作为间接寻址取出表中的数据送入AL</li>
<li>将AL的值作为结果输出</li>
</ul>
<h2 id="分支程序设计"><a class="header" href="#分支程序设计">分支程序设计</a></h2>
<p>分支程序: 指令的执行顺序和存储顺序不一致</p>
<p>执行指令的地址由<code>CS:IP</code>决定</p>
<ul>
<li>顺序执行时，IP的值根据指令的长度依次递增</li>
<li>转移时
<ul>
<li>若在同一段中，改变IP的值，CS不变</li>
<li>若转向不同的段，改变CS和IP的值</li>
</ul>
</li>
</ul>
<h3 id="单分支结构"><a class="header" href="#单分支结构">单分支结构</a></h3>
<ol>
<li>无条件转移使用JMP指令</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.13889em;">MP</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">目标</span></span></span></span></span></p>
<ul>
<li>转到目标出执行程序，对标志位无影响</li>
<li>目标可以是
<ul>
<li><code>标号</code></li>
<li><code>标号+常数</code></li>
<li><code>寄存器(或存储器)</code></li>
</ul>
</li>
</ul>
<ol start="2">
<li>条件转移使用JXX指令</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.07847em;">XX</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">目标</span></span></span></span></span></p>
<ul>
<li>条件满足，转到目标处执行程序；条件不满足，顺序执行程序</li>
<li>条件根据PSW中的条件码测试：ZF、SF、OF、CF、PF</li>
</ul>
<h3 id="多分支结构"><a class="header" href="#多分支结构">多分支结构</a></h3>
<p>数据段定义一张跳转地址表TABLE，每个表项占两个单元(段内转移)，表示各个分支的目标标号，可通过<code>JMP 表中的偏移地址</code>实现多分支的跳转</p>
<pre><code class="language-asm">data segment 
    ...
    TABLE dw addr0,addr1,...,addrn
    ...
data ends
code segment 
        ...
        mov ah,0
        mov al,NUM 
        add ax,ax; AX*2
        mov si,ax; 将si作为表中的偏移地址
        mov bx,TABLE[si]; 偏移地址加上TABLE地址得到目标表项的内容
        jmp near ptr bx; 跳转到目标表项代表的标号处
    addr0:
        ...
        jmp end 
    addr1:
        ...
        jump end 
    ...
    addrn:
        ...
        jump end 
    end:
        ...
code ends
</code></pre>
<h2 id="循环程序设计"><a class="header" href="#循环程序设计">循环程序设计</a></h2>
<h3 id="形式"><a class="header" href="#形式">形式</a></h3>
<p><img src="assets/2024-12-04-14-45-12.png" alt="循环程序结构形式" /></p>
<ol>
<li>初始化：设置循环次数、循环初始状态值等</li>
<li>循环体：循环的主体部分，分两部分
<ul>
<li>循环工作部分：完成程序功能的主要程序段</li>
<li>循环调整部分：更新用于判断循环结束的数值</li>
</ul>
</li>
<li>循环条件：判断循环是否结束</li>
</ol>
<h3 id="循环指令"><a class="header" href="#循环指令">循环指令</a></h3>
<ol>
<li>普通循环
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.13889em;">OOP</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">标号</span></span></span></span></span></li>
</ol>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span></span></span></span></li>
<li>若<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，从标号处继续循环</li>
<li>若<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，退出循环</li>
</ul>
<blockquote>
<p>相当于两条指令：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07153em;">EC</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.07153em;">NZ</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">标号</span></span></span></span></p>
</blockquote>
<ol start="2">
<li>为0/相等时循环
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">OOPE</span><span class="mord">/</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OOPZ</span><span class="mord cjk_fallback">标号</span></span></span></span></span></li>
</ol>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span></span></span></span></li>
<li>若<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.13889em;">ZF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，从标号处继续循环</li>
<li>若<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord cjk_fallback">或</span><span class="mord mathnormal" style="margin-right:0.13889em;">ZF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，顺序执行</li>
</ul>
<ol start="3">
<li>非0/不等时循环
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">OOPNE</span><span class="mord">/</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OOPNZ</span><span class="mord cjk_fallback">标号</span></span></span></span></span></li>
</ol>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span></span></span></span></li>
<li>若<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.13889em;">ZF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，从标号处继续循环</li>
<li>若<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord cjk_fallback">或</span><span class="mord mathnormal" style="margin-right:0.13889em;">ZF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，顺序执行</li>
</ul>
<ol start="4">
<li>按CX循环
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.07153em;">CXZ</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">标号</span></span></span></span></span></li>
</ol>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，转至标号处继续循环</li>
<li>否则，顺序执行</li>
</ul>
<h3 id="使用"><a class="header" href="#使用">使用</a></h3>
<ol>
<li>注意</li>
</ol>
<ul>
<li>循环指令不影响标志位</li>
<li>隐含<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">CX</span><span class="mclose">)</span><span class="mord cjk_fallback">－</span><span class="mord">1</span></span></span></span>操作</li>
<li>JCXZ常用于循环初值为0而发生循环的情况</li>
<li>LOOP指令按循环次数决定是否结束循环</li>
<li>LOOPZ和LOOPNZ提供了提前结束循环的可能，常跟在比较指令之后</li>
</ul>
<ol start="2">
<li>循环的基本结构</li>
</ol>
<pre><code class="language-asm">code setment
    ...
    MOV CX,n; 给循环计数器赋初值
AGAIN:
    ...
    ...;循环体
    ...
    LOOP AGAIN; 跳回开始处
code ends
</code></pre>
<ol start="3">
<li>循环的控制方法</li>
</ol>
<ul>
<li>
<p>用计数控制循环</p>
<ul>
<li>循环次数已知</li>
<li>若选用CX做计数器，递减，可用LOOP,LOOPE,LOOPNE等</li>
<li>选取其他寄存器或存储单元作计数器，可用INC/DEC指令和条件转移指令JNZ配合</li>
</ul>
</li>
<li>
<p>用条件控制循环</p>
<ul>
<li>循环次数不确定</li>
<li>每循环一次，测试并判断循环终止条件是否成立</li>
</ul>
</li>
</ul>
<ol start="4">
<li>多重循环程序设计</li>
</ol>
<p>利用标号进行程序的转移</p>
<p><img src="assets/2024-12-04-15-00-16.png" alt="多重循环示意图" /></p>
<h2 id="子程序的调用及返回"><a class="header" href="#子程序的调用及返回">子程序的调用及返回</a></h2>
<h3 id="子程序的调用"><a class="header" href="#子程序的调用">子程序的调用</a></h3>
<ol>
<li>指令格式</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">A</span><span class="mord mathnormal">LL</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">过程名</span></span></span></span></span></p>
<blockquote>
<p>过程名类似与标号，用法类似与JMP</p>
</blockquote>
<ul>
<li>段内调用（仅修改IP值）
<ul>
<li>直接调用: <code>call (near ptr)过程名</code></li>
<li>间接调用: <code>call 寄存器名</code>,<code>call word ptr 字存储单元</code></li>
</ul>
<blockquote>
<p>新IP值在寄存器或存储单元里</p>
</blockquote>
</li>
<li>段间调用（修改CS和IP的值）
<ul>
<li>直接调用: <code>call (far ptrl)过程名</code></li>
<li>间接调用: <code>call dword ptr 双字存储单元</code></li>
</ul>
<blockquote>
<p>新段基值和偏移量在双字存储单元中</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>执行的操作</li>
</ol>
<ul>
<li>先将返回地址入栈(CALL命令后一条命令的逻辑地址)</li>
<li>在转移到子程序的入口地址执行</li>
</ul>
<h3 id="子程序的返回"><a class="header" href="#子程序的返回">子程序的返回</a></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RET</span></span></span></span></span></p>
<ul>
<li>从栈顶处弹出返回地址，并将其赋值给IP或IP、CS，取决于段间转移或段内转移</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RET</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">n</span></span></span></span></span></p>
<ul>
<li>从栈顶处弹出返回地址，并将其赋值给IP或IP、CS，取决于段间转移或段内转移</li>
<li>再用n修改SP的值，即<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">SP</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">SP</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="传递参数"><a class="header" href="#传递参数">传递参数</a></h3>
<ol>
<li>
<p>使用寄存器</p>
</li>
<li>
<p>使用存储单元</p>
</li>
<li>
<p>使用地址表
参量较多时，先把参量所在的地址组成一个地址表，将地址表的首地址传递给子程序</p>
</li>
<li>
<p>使用堆栈</p>
</li>
</ol>
<h3 id="系统功能子程序调用"><a class="header" href="#系统功能子程序调用">系统功能子程序调用</a></h3>
<ol>
<li>系统子程序</li>
</ol>
<p>8086/8088向用户提供了十分有效的输入/输出基本子程序，这些子程序在DOS和BIOS中，用户可以用<strong>软中断INT n</strong>指令调用这些程序</p>
<ul>
<li>10H～1FH BIOS占用的类型码</li>
<li>20H～2FH DOS占用的类型码</li>
</ul>
<ol start="2">
<li>调用方法</li>
</ol>
<ul>
<li>
<p>置入口参数
即传递给系统功能子程序的参数</p>
</li>
<li>
<p>于AH中置功能号
设置将要调用的子程序，不同的功能号对应不同的系统功能子程序</p>
</li>
<li>
<p>INT XXH(中断类型码)
调用子程序</p>
</li>
</ul>
<p>出口参数一般在通用寄存器中，即该子程序进行的操作返回的值</p>
<hr />
<h1 id="debugexe用法"><a class="header" href="#debugexe用法">debug.exe用法</a></h1>
<h2 id="注意"><a class="header" href="#注意">注意：</a></h2>
<ul>
<li><code>-</code>是debug提示符prompt</li>
<li>debug.exe只能对扩展名为<code>.com</code>和<code>.exe</code>的文件进行调试</li>
<li>命令参数不区分大小写</li>
<li>所有的输入和显示的数，均为十六进制数，H隐含</li>
<li><code>&lt;Ctrl&gt;+&lt;Break&gt;</code>停止命令的执行</li>
<li>如果命令产生大量输出，可按下<code>&lt;Ctrl&gt;+_&lt;Num Lock&gt;</code>使显示停止卷动，按下其他任意键可恢复</li>
</ul>
<h2 id="-r"><a class="header" href="#-r">-r</a></h2>
<p>查看，修改寄存器的内容和标志</p>
<pre><code class="language-asm">-r 
# 查看所有寄存器内容

-r register_name
# 修改指定寄存器的值

-rf
# 显示标志寄存器内容
</code></pre>
<p>所有的标志位为</p>
<div class="table-wrapper"><table><thead><tr><th>标志名</th><th>标志为1</th><th>标志为0</th></tr></thead><tbody>
<tr><td>OF 溢出（是/否）</td><td>OV</td><td>NV</td></tr>
<tr><td>DF 方向（增量/减量）</td><td>DN</td><td>UP</td></tr>
<tr><td>IF 中断（允许/关闭）</td><td>EI</td><td>DI</td></tr>
<tr><td>SF 符号（正/负）</td><td>NG</td><td>PL</td></tr>
<tr><td>ZF 零（是/否）</td><td>ZR</td><td>NZ</td></tr>
<tr><td>AF 辅助进位（是/否）</td><td>AC</td><td>NA</td></tr>
<tr><td>PF 奇偶（偶/奇）</td><td>PE</td><td>PO</td></tr>
<tr><td>CF 进位（是/否）</td><td>CY</td><td>NC</td></tr>
</tbody></table>
</div>
<h2 id="-d"><a class="header" href="#-d">-d</a></h2>
<p>查看内存中的内容</p>
<pre><code class="language-asm">-d [起始地址] [结束地址]
</code></pre>
<p>显示两部分内容</p>
<ul>
<li>字节的十六进制数形式</li>
<li>ASCII码形式</li>
</ul>
<blockquote>
<p>ascii码中不可见字符用<code>.</code>表示</p>
</blockquote>
<h2 id="-e"><a class="header" href="#-e">-e</a></h2>
<p>修改内存单元中的内容</p>
<pre><code class="language-asm">-e 地址 [内容表]
</code></pre>
<ul>
<li>如果提供内容表：用内容表的内容替换指定开始地址的一个或多个字节的内容</li>
<li>否则进入交互替换模式
<ul>
<li>输入值后
<ul>
<li>输入enter退出替换模式</li>
<li>输入空格对下一个单元继续编辑</li>
</ul>
</li>
<li>输入空格
<ul>
<li>不修改当前内存单元的值，对下一个单元继续编辑</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如只输入一个地址偏移量，则缺省的段为DS</p>
</blockquote>
<h2 id="-a"><a class="header" href="#-a">-a</a></h2>
<p>让用户可以直接输入汇编语言指令，将其转换为机器码并存入内存中</p>
<pre><code class="language-asm">-a [地址]
</code></pre>
<ul>
<li>键入的汇编语句被汇编到地址指定的相应内存单元中</li>
<li>如没有指定地址，则被汇编到CS:0100内存区内。</li>
<li>键入所有语句后，当再次出现提示符时，按下↙键，返回到DEBUG提示符</li>
</ul>
<h2 id="-t"><a class="header" href="#-t">-t</a></h2>
<p>执行一条或多条指令</p>
<pre><code class="language-asm">-t [=地址] [值]
</code></pre>
<ul>
<li>执行自指定地址开始的一条或给定值条指令</li>
<li>每条指令执行完都会显示出所有寄存器和标志位的内容</li>
<li>未给定地址则以CS:IP开始执行</li>
</ul>
<h2 id="-u"><a class="header" href="#-u">-u</a></h2>
<p>反汇编命令：将指定内存地址中的机器码转换为可读的汇编指令</p>
<pre><code class="language-asm">-u [起始地址] [结束地址]
</code></pre>
<ul>
<li>从指定的地址反汇编32字节的汇编语句，显示出他们的
<ul>
<li>地址</li>
<li>十六进制值</li>
<li>对应的汇编语句。</li>
</ul>
</li>
<li>起始地址，结束地址均缺省时
<ul>
<li>则以上一条条u命令反汇编的最后一条命令后的单元作为起始地址</li>
<li>若以前未用过的U命令则以CS：100作为起始地址。</li>
</ul>
</li>
</ul>
<h2 id="-g"><a class="header" href="#-g">-g</a></h2>
<p>执行程序命令功能：执行正在调试的程序，当执行到指定断点时，停止执行，并显示寄存器、标志和下一条要执行的指令。</p>
<pre><code>-g [=地址] [地址 [地址 …]]
</code></pre>
<ul>
<li>[=地址]规定了执行的起始地址，缺省时则以CS：IP当前内容为开始地址，输入时要特别注意加 “=” 号</li>
<li>第二、第三参数的地址为断点地址，最多可设10个断点，每当程序执行遇到断点时都会停下来，键入G继续执行</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<p>第六章、存储系统</p>
<p>在传统的CPU中，为数不多的寄存器只能暂存少量信息，绝大部分程序与数据需要存放在专门的存储器中。计算机系统结构的发展要求多层次的存储能力，这就构成了具有层次结构的存储子系统。</p>
<p>在物理构成上，存储系统通常分为3层</p>
<ul>
<li>高速缓冲存储器Cache</li>
<li>主存</li>
<li>外存<br />
Cache与主存常由半导体存储器构成；外存常由磁盘及光盘构成，也可以看作是I/O设备</li>
</ul>
<p>在本章中</p>
<ul>
<li>首先介绍各种存储器存储信息的原理</li>
<li>接着介绍芯片级以上的存储器逻辑设计方法</li>
<li>然后介绍高速缓存、外部存储器的工作原理</li>
<li>最后从整个存储系统组织的角度，介绍有关技术，如物理存储系统组织、虚拟存储技术等</li>
</ul>
<ul>
<li><a href="6.storage_system.html#%E6%A6%82%E8%BF%B0">概述</a>
<ul>
<li><a href="6.storage_system.html#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB">存储器的分类</a>
<ul>
<li><a href="6.storage_system.html#%E6%8C%89%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB">按存储器在计算机系统中的作用分类</a></li>
<li><a href="6.storage_system.html#%E6%8C%89%E5%AD%98%E5%8F%96%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB">按存取方式分类</a></li>
<li><a href="6.storage_system.html#%E6%8C%89%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB">按存储介质分类</a></li>
</ul>
</li>
<li><a href="6.storage_system.html#%E4%B8%BB%E5%AD%98%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87">主存的主要技术指标</a></li>
</ul>
</li>
<li><a href="6.storage_system.html#%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86">存储原理</a>
<ul>
<li><a href="6.storage_system.html#%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86">半导体存储器的存储原理</a>
<ul>
<li><a href="6.storage_system.html#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8sram">静态存储器SRAM</a></li>
<li><a href="6.storage_system.html#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8dram">动态存储器DRAM</a></li>
</ul>
</li>
<li><a href="6.storage_system.html#%E7%A3%81%E8%A1%A8%E9%9D%A2%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86">磁表面存储器的存储原理</a></li>
<li><a href="6.storage_system.html#%E5%85%89%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86">光存储器的存储原理</a></li>
</ul>
</li>
<li><a href="6.storage_system.html#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87">主存储器的组织</a>
<ul>
<li><a href="6.storage_system.html#%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95">存储器容量扩展</a>
<ul>
<li><a href="6.storage_system.html#%E4%BD%8D%E6%89%A9%E5%B1%95">位扩展</a></li>
<li><a href="6.storage_system.html#%E5%AD%97%E6%95%B0%E7%BC%96%E5%9D%80%E7%A9%BA%E9%97%B4%E6%89%A9%E5%B1%95">字数（编址空间）扩展</a></li>
</ul>
</li>
<li><a href="6.storage_system.html#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%B7%E6%96%B0">动态存储器的刷新</a>
<ul>
<li><a href="6.storage_system.html#%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0">集中刷新</a></li>
<li><a href="6.storage_system.html#%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F">分散刷新方式</a></li>
<li><a href="6.storage_system.html#%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F">异步刷新方式</a></li>
</ul>
</li>
<li><a href="6.storage_system.html#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8Ecpu%E7%9A%84%E8%BF%9E%E6%8E%A5">主存储器与CPU的连接</a>
<ul>
<li><a href="6.storage_system.html#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F">系统模式</a></li>
<li><a href="6.storage_system.html#%E9%80%9F%E5%BA%A6%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6">速度匹配与时序控制</a></li>
<li><a href="6.storage_system.html#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%8C%B9%E9%85%8D">数据通路匹配</a></li>
<li><a href="6.storage_system.html#%E6%9C%89%E5%85%B3%E4%B8%BB%E5%AD%98%E7%9A%84%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7">有关主存的控制信号</a></li>
</ul>
</li>
<li><a href="6.storage_system.html#dram%E7%9A%84%E5%8F%91%E5%B1%95">DRAM的发展</a></li>
</ul>
</li>
<li><a href="6.storage_system.html#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8cache">高速缓冲存储器Cache</a>
<ul>
<li><a href="6.storage_system.html#cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Cache的工作原理</a>
<ul>
<li><a href="6.storage_system.html#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="6.storage_system.html#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a></li>
<li><a href="6.storage_system.html#%E6%8B%A5%E6%9C%89cache%E5%90%8E%E7%9A%84%E8%AE%BF%E5%AD%98%E8%BF%87%E7%A8%8B">拥有Cache后的访存过程</a></li>
<li><a href="6.storage_system.html#%E5%91%BD%E4%B8%AD%E7%8E%87">命中率</a></li>
</ul>
</li>
<li><a href="6.storage_system.html#cache%E7%9A%84%E7%BB%84%E7%BB%87">Cache的组织</a>
<ul>
<li><a href="6.storage_system.html#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%83%8F">地址映像</a></li>
<li><a href="6.storage_system.html#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95">替换算法</a></li>
<li><a href="6.storage_system.html#cache%E7%9A%84%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B">Cache的读/写过程</a></li>
<li><a href="6.storage_system.html#%E5%A4%9A%E5%B1%82%E6%AC%A1cache%E5%AD%98%E5%82%A8%E5%99%A8">多层次Cache存储器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="6.storage_system.html#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF">虚拟存储技术</a>
<ul>
<li><a href="6.storage_system.html#%E6%A6%82%E8%BF%B0-1">概述</a></li>
<li><a href="6.storage_system.html#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F">虚拟存储器的组织方式</a>
<ul>
<li><a href="6.storage_system.html#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">页式虚拟存储器</a></li>
<li><a href="6.storage_system.html#%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">段式虚拟存储器</a></li>
<li><a href="6.storage_system.html#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">段页式虚拟存储器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>简单地讲，存储器用于存放计算机程序和指令、待处理的数据、运算结果以及各种需要计算机保存的信息</p>
<p>存储器由一些能够表示为二进制数中0、1两种状态的物理器件组成，这些器件本身具有记忆功能，如电容、双稳态电路等。</p>
<p>通常一个存储单元由8个存储元构成，可存放8位二进制信息（即1字节，1 Byte）。许多存储单元组织在一起就构成了存储器。</p>
<p>一个高性能的计算机系统要求存储器的存储容量大，存取速度快，成本低廉，能支持复杂系统结构。这些要求往往相互矛盾，彼此形成制约，为了适应不同层次的需要，形成了多级存储体系</p>
<p>从用户的角度看，存储器还可以形成另一种层次结构，即</p>
<ul>
<li>物理存储器: 物理存储器是指系统的物理组成中实际存在的主存，主存容量决定了实存空间的大小</li>
<li>虚拟存储器: 依靠操作系统的软件支持及部分硬件的支持，可使用户访问的编程空间远比实际主存空间大，这个存储器称为虚拟存储器。</li>
</ul>
<h2 id="存储器的分类"><a class="header" href="#存储器的分类">存储器的分类</a></h2>
<h3 id="按存储器在计算机系统中的作用分类"><a class="header" href="#按存储器在计算机系统中的作用分类">按存储器在计算机系统中的作用分类</a></h3>
<ol>
<li>内存存储器</li>
</ol>
<ul>
<li>用来存储当前运行所需要的程序和数据</li>
<li>CPU可以直接访问内存并与其交换信息</li>
<li>相对外部存储器而言，内存的容量小、存取速度快</li>
</ul>
<ol start="2">
<li>外存存储器</li>
</ol>
<ul>
<li>用于存放当前不参加运行的程序和数据，以及一些需要永久保存的信息</li>
<li>外存设在主机外部，其容量大</li>
<li>存取速度相对较慢，CPU不能直接访问它，而必须通过专门的设备才能对它进行读写（如磁盘驱动器等）</li>
</ul>
<ol start="3">
<li>高速缓存存储器</li>
</ol>
<ul>
<li>位于主存和CPU之间，用来存放正在执行的程序和数据，以便CPU能高速地访问它们</li>
<li>Cache的存取速度可以与CPU的速度相匹配，但其价格昂贵，存储容量较小</li>
<li>目前的微处理器通常将Cache或Cache的一部分制作在CPU芯片中。</li>
</ul>
<h3 id="按存取方式分类"><a class="header" href="#按存取方式分类">按存取方式分类</a></h3>
<ol>
<li>随机存取存储器RAM(Random Access Memory)</li>
</ol>
<ul>
<li>CPU可以对RAM单元的内容随机地读/写访问</li>
<li>对存取时间相同: 任一单元的读出和写入的花费的时间是一样，</li>
<li>RAM读/写方便，但断电后信息会丢失</li>
</ul>
<ol start="2">
<li>只读存储器ROM(Read Only Memory)</li>
</ol>
<ul>
<li>只读存储器可以看作RAM的一种特殊形式</li>
<li>只能随机读出而不能写入</li>
<li>断电信息也不会丢失</li>
</ul>
<blockquote>
<p>有些ROM在特定条件下用特殊的装置或程序可以重新写入。</p>
</blockquote>
<ol start="3">
<li>顺序存取存储器SAM(Sequential Access Memory)</li>
</ol>
<ul>
<li>内容只能按某种顺序存取</li>
<li>存取时间的长短与信息在存储器上的物理位置有关</li>
</ul>
<blockquote>
<p>磁带机就是典型的顺序存取存储器。</p>
</blockquote>
<ol start="4">
<li>直接存取存储器DAM(Direct Access Memory)</li>
</ol>
<ul>
<li>介于RAM的随机地访问和SAM的顺序存取之间</li>
<li>存取信息时
<ul>
<li>第1步直接指向存储器的某个小区域（如磁盘上的磁道）</li>
<li>第2步在小区域内顺序检索或等待，直到找到目的地后再进行读/写操作</li>
</ul>
</li>
<li>存取时间也与信息所在的物理位置有关，但比SAM的存取时间要短</li>
</ul>
<blockquote>
<p>磁盘是最常见的直接存取存储器。</p>
</blockquote>
<h3 id="按存储介质分类"><a class="header" href="#按存储介质分类">按存储介质分类</a></h3>
<ol>
<li>磁芯存储器</li>
</ol>
<p>通过小型铁氧体环（磁芯）存储数据，每个磁芯的磁化方向表示1或0。</p>
<ul>
<li>写入数据：通过电流改变磁化方向设定为1或0。</li>
<li>读取数据：检测磁化方向以判断状态，破坏性读出</li>
</ul>
<blockquote>
<p>破坏性读出，不管磁芯原存的信息是1或0，读出之后磁芯内容都变成0</p>
</blockquote>
<ol start="2">
<li>半导体存储器</li>
</ol>
<p>采用半导体器件制造的存储器</p>
<ol start="3">
<li>磁表面存储器</li>
</ol>
<p>在金属或塑料基体上涂敷一层磁性材料，利用磁层的磁化状态来存储信息</p>
<ul>
<li>写入数据：磁头在磁性表面通过电流改变局部磁化方向以表示1或0。</li>
<li>读取数据：磁头检测磁场变化，转换为电信号输出。</li>
</ul>
<ol start="4">
<li>光盘存储器</li>
</ol>
<p>利用激光技术控制访问的存储器</p>
<ul>
<li>写入数据：激光束烧蚀光盘表面的有机层或改变反射率，形成“坑”和“平面”表示1和0。</li>
<li>读取数据：通过激光反射强度的差异检测数据。</li>
</ul>
<h2 id="主存的主要技术指标"><a class="header" href="#主存的主要技术指标">主存的主要技术指标</a></h2>
<p>从理论上讲，只要具有两个明显可区分的物理状态且容易进行状态转换的器件和介质都可用来存储二进制信息</p>
<ol>
<li>存储容量</li>
</ol>
<p>存储容量是指主存所能容纳的二进制信息总量</p>
<ol start="2">
<li>存取速度</li>
</ol>
<p>存取速度通常由存取时间和存取周期来表示。</p>
<ul>
<li>存取时间: 指从启动一次存储器操作到完成该操作所经历的时间</li>
<li>存取周期: 指存储器进行一次完整的读/写操作所需的全部时间，即连续两次访问存储器操作之间所需的最短时间(上次存取结束到下次存取开始间的最短时间)</li>
</ul>
<ol start="3">
<li>可靠性</li>
</ol>
<p>指规定时间内，存储器无故障读/写的概率，通常用平均无故障时间MTBF（Mean Time Between Failures）来衡量可靠性，MTBF可理解为两次故障之间的平均时间间隔</p>
<ol start="4">
<li>存取宽度</li>
</ol>
<p>也称为存储总线宽度，即CPU一次可以存取的数据位数或字节数。</p>
<h1 id="存储原理"><a class="header" href="#存储原理">存储原理</a></h1>
<h2 id="半导体存储器的存储原理"><a class="header" href="#半导体存储器的存储原理">半导体存储器的存储原理</a></h2>
<h3 id="静态存储器sram"><a class="header" href="#静态存储器sram">静态存储器SRAM</a></h3>
<p>SRAM原理：利用双稳态触发器保存信息</p>
<p><img src="assets/2024-12-05-14-48-53.png" alt="SRAM组成原理图(存一位信息)" /></p>
<ol>
<li>组成</li>
</ol>
<ul>
<li>mos管
<ul>
<li>T1,T2: 工作管</li>
<li>T3,T4: 负载管</li>
<li>T5,T6: 门控管</li>
</ul>
</li>
<li>W: 位线</li>
<li>Z: 字线</li>
</ul>
<ol start="2">
<li>定义</li>
</ol>
<ul>
<li>存0： T1导通，T2截止</li>
<li>存1： T2导通，T1截止</li>
</ul>
<ol start="3">
<li>存取操作</li>
</ol>
<ul>
<li>写入: z接高电平，T5,T6导通
<ul>
<li>写0：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>加低，W加高， T6 对 B 充 电 ， 使 T1导通，T2截止；</li>
<li>写1：相反，T5对A充电，使T2导通</li>
</ul>
</li>
</ul>
<h3 id="动态存储器dram"><a class="header" href="#动态存储器dram">动态存储器DRAM</a></h3>
<h2 id="磁表面存储器的存储原理"><a class="header" href="#磁表面存储器的存储原理">磁表面存储器的存储原理</a></h2>
<ol>
<li>记录介质与磁头</li>
</ol>
<ul>
<li>介质: 磁层（矩磁薄膜），依附在基体上</li>
<li>磁头: 读写部件</li>
</ul>
<ol start="2">
<li>读写原理、特点</li>
</ol>
<ul>
<li>
<p>写入(电磁转换)</p>
<p>磁头线圈中加入磁化电流（写电流），并使磁层移动，在磁层上形成连续的小段磁化区域（位单元）</p>
</li>
<li>
<p>读出（磁电转换）</p>
<p>磁头线圈中不加电流，磁层移动。当位单元的转变区经过磁头下方时，在线圈两端产生感应电势</p>
</li>
</ul>
<h2 id="光存储器的存储原理"><a class="header" href="#光存储器的存储原理">光存储器的存储原理</a></h2>
<ol>
<li>环变形光盘</li>
</ol>
<p>形变不可逆，不可改写</p>
<ul>
<li>定义: 有空为1，无孔为0</li>
<li>写入:
<ul>
<li>写1，⾼功率激光照射介质，形成凹坑；</li>
<li>写0，不发射激光束，介质不变</li>
</ul>
</li>
<li>读出: 低功率激光扫描光道，根据反射光强弱判断是1或0</li>
</ul>
<ol start="2">
<li>相变形光盘</li>
</ol>
<p>相变可逆，可改写</p>
<ul>
<li>写入:
<ul>
<li>写1，⾼功率激光照射介质，晶粒直径变⼤；</li>
<li>写0，不发射激光束，晶粒不变</li>
</ul>
</li>
<li>读出: 低功率激光扫描光道，根据反射率的差别判断是1或0</li>
</ul>
<ol start="3">
<li>磁光形光盘</li>
</ol>
<p>磁化方向，可恢复可改写</p>
<ul>
<li>写入前：外加磁场，使介质呈某种磁化⽅向</li>
<li>写入:
<ul>
<li>写1，激光照射并外加磁场改变磁化⽅向；</li>
<li>写0，未被照射区域，磁化⽅向不变</li>
</ul>
</li>
<li>读出: 低功率激光扫描光道，根据反射光的偏转角度判断是1或0 （通过检偏器为1）</li>
</ul>
<h1 id="主存储器的组织"><a class="header" href="#主存储器的组织">主存储器的组织</a></h1>
<p>本节考虑如何用存储芯片组成一个实际的存储器。</p>
<ol>
<li>容量的表示</li>
</ol>
<p>设计存储器时，首先要确定所要求的总容量，即字数×位数</p>
<blockquote>
<p>为了便于处理字符型数据，在微型计算机中，一般都采取按字节编址</p>
</blockquote>
<p>容量为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>的存储器</p>
<ul>
<li>拥有<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>个存储单元,需要N位地址线</li>
<li>每单元存放<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>位数据，需要M根数据线</li>
</ul>
<ol start="2">
<li>变址单位</li>
</ol>
<p>在大、中、小型计算机中，往往允许主存选取两种编址单位之一</p>
<ul>
<li>按字节编址</li>
<li>按字编址: 每个编址单元存放一个字，字长多为字节位数的整数倍</li>
</ul>
<p>确定了存储器的总容量之后，即可确定可供选用的存储芯片是什么类型、什么型号、每片容量多大等</p>
<h2 id="存储器容量扩展"><a class="header" href="#存储器容量扩展">存储器容量扩展</a></h2>
<p><img src="assets/2024-12-17-18-44-42.png" alt="子扩展和位扩展连接示意图" /></p>
<h3 id="位扩展"><a class="header" href="#位扩展">位扩展</a></h3>
<p>如果各个存储芯片的位数小于存储器所要求的位数，就需要进行位扩展</p>
<p>位扩展是指用多个存储芯片对字长进行扩展</p>
<p>其连接方式是</p>
<ul>
<li>将各个存储芯片的地址线、片选线和读写控制线相应地并联</li>
<li>而各个存储芯片的数据线单独列出</li>
</ul>
<h3 id="字数编址空间扩展"><a class="header" href="#字数编址空间扩展">字数（编址空间）扩展</a></h3>
<p>如果每片的字数不够，需用若干芯片组成总容量更大的存储器，称为字数扩展</p>
<ul>
<li>高位地址译码产生若干不同的片选信号(用于选取用于读写的目标芯片)</li>
<li>低位地址线直接送往各个芯片，以选择目标芯片内的某个单元</li>
<li>而各个芯片的数据线，按位并联于数据总线。</li>
</ul>
<p>向存储器送出某个地址码时</p>
<ul>
<li>只有一个片选信号有效，选中某个芯片</li>
<li>而低位地址在芯片内译码选中某个单元</li>
</ul>
<h2 id="动态存储器的刷新"><a class="header" href="#动态存储器的刷新">动态存储器的刷新</a></h2>
<p>如果采用DRAM芯片构成主存储器，除前述逻辑设计外，还需考虑动态刷新问题</p>
<ul>
<li>若芯片采用的是四管动态存储单元，则读出时能自动补充电荷</li>
<li>若采用单管存储单元，则属于破坏性读出，但存储芯片本身具有读出后重写的再生功能</li>
</ul>
<p>因此对所有DRAM芯片都采用逐行刷新的方法。为此</p>
<ul>
<li>应设置一个刷新地址计数器，提供刷新地址，即刷新行的行号</li>
<li>然后发送行选信号给读命令，即可刷新一行
<ul>
<li>此时列选信号为高（无效），数据输出为高阻</li>
</ul>
</li>
<li>每刷新一行后，刷新地址计数器加1，每个计数循环对芯片各行刷新一遍</li>
</ul>
<blockquote>
<p>目前工艺水平，将全部刷新一遍所允许的最大时间间隔约为2ms</p>
</blockquote>
<p>于是主存储器需要两种工作状态：</p>
<ul>
<li>一种是读/写/保持状态
<ul>
<li>由CPU（或其他控制器）提供地址进行读写</li>
<li>或是不访问主存（保持信息），其访存地址是根据程序需要随机产生的，有些行可能长期不被访问</li>
</ul>
</li>
<li>另一种是刷新状态
<ul>
<li>由刷新地址计数器逐行地提供行地址</li>
<li>在2ms周期中不能遗漏任何一行</li>
</ul>
</li>
</ul>
<p>因此实现动态刷新的一个重要问题是：如何安排刷新周期？一般可归纳为下述3种典型的刷新方式。</p>
<p><img src="assets/2024-12-17-18-54-42.png" alt="动态刷新安排方式示意图" /></p>
<h3 id="集中刷新"><a class="header" href="#集中刷新">集中刷新</a></h3>
<ol>
<li>概念</li>
</ol>
<p>在2ms的最大刷新周期内</p>
<ul>
<li>集中安排若干刷新周期，使全部芯片刷新一遍，这时刷新周期数等于最大容量芯片的行数</li>
<li>其余时间可用于正常工作，即读/写/保持状态</li>
</ul>
<p>在逻辑实现上，可由一个定时器每2 ms请求一次，进入集中刷新状态，然后由刷新计数器控制一个计数循环，逐行刷新一遍。</p>
<ol start="2">
<li>评价</li>
</ol>
<p>集中刷新方式</p>
<ul>
<li>优点是：主存利用率高，控制简单</li>
<li>缺点是：在集中刷新状态中不能使用存储器，因而形成一段死区。如果系统工作方式不允许有死区，则不能采用集中刷新方式</li>
</ul>
<h3 id="分散刷新方式"><a class="header" href="#分散刷新方式">分散刷新方式</a></h3>
<ol>
<li>概念</li>
</ol>
<p>将每个存取周期分为两部分</p>
<ul>
<li>前半期可用于正常读/写/保持</li>
<li>后半期用于刷新</li>
</ul>
<p>换句话说，将各个刷新周期分散地安排于各读写周期之后</p>
<ol start="2">
<li>评价</li>
</ol>
<p>分散刷新</p>
<ul>
<li>优点是：控制简单，主存工作没有长的死区</li>
<li>缺点是：主存利用率低，工作速度约降低一半。因为每个存取周期中都包含一个刷新周期，所需时间约增加一倍</li>
</ul>
<h3 id="异步刷新方式"><a class="header" href="#异步刷新方式">异步刷新方式</a></h3>
<p>按芯片行数决定所需刷新周期数，并分散安排在2ms的最大刷新周期中</p>
<p>例如，芯片的最大行数为128，可每隔15.6 μs提出一次刷新请求，响应后就安排一个刷新周期</p>
<ul>
<li>提出刷新请求时有可能CPU访存尚未结束</li>
<li>则稍事等待至主存有空时</li>
<li>再安排刷新周期进行刷新，所以称为异步刷新方式</li>
</ul>
<p>可将动态刷新请求作为一种DMA(直接存储器访问)请求</p>
<ul>
<li>CPU响应后放弃系统总线控制权，暂停访存</li>
<li>由DMA控制器接管系统总线，送出刷新地址进行一次动态刷新</li>
</ul>
<ol start="2">
<li>评价</li>
</ol>
<p>异步刷新方式兼有前两种方式的优点：</p>
<ul>
<li>对主存利用率和工作速度影响最小</li>
<li>而且没有死区</li>
</ul>
<p>虽然控制上复杂一些，但可利用系统已有的DMA功能去实现。因此大多数计算机系统采用异步刷新方式</p>
<p>在说明了3种刷新方式之后，再归纳一下硬件实现的4种可能方案：</p>
<ul>
<li>利用DMA功能</li>
<li>用通用芯片构成动态刷新计数器、地址切换等刷新控制逻辑</li>
<li>利用专用芯片（如Intel 8203）动态RAM系统控制器</li>
<li>利用准静态RAM芯片，这种存储芯片内部采用单管动态存储单元，本质上属于动态存储器。但芯片内部还集成了动态刷新逻辑，从使用者角度看，不再需要另外设置外部刷新电路，其使用特性如同SRAM，因而称为准静态RAM</li>
</ul>
<h2 id="主存储器与cpu的连接"><a class="header" href="#主存储器与cpu的连接">主存储器与CPU的连接</a></h2>
<p>主存储器与CPU的连接在具体逻辑上可能有多种变化，从原理上大致需要考虑以下几个方面</p>
<h3 id="系统模式"><a class="header" href="#系统模式">系统模式</a></h3>
<ol>
<li>最小系统模式</li>
</ol>
<p>将CPU芯片与存储芯片直接连接，即</p>
<ul>
<li>CPU输出地址线、数据线直接送往存储芯片</li>
<li>并发出读写命令R/ 送往芯片<br />
这种模式被称为最小系统模式</li>
</ul>
<p>由于这种小系统所需存储器容量不大，往往采用SRAM芯片，省去刷新逻辑。</p>
<p><img src="assets/2024-12-17-19-08-05.png" alt="CPU与主存的连接方式" /></p>
<ol start="2">
<li>较大系统模式</li>
</ol>
<p>在稍具规模的计算机系统中，往往通过系统总线连接主存储器与外围设备</p>
<ul>
<li>CPU芯片的引脚常常不直接与系统总线相连
<ul>
<li>而是通过数据收发缓冲器、地址锁存器、总线控制器等接口芯片与系统总线相连</li>
</ul>
</li>
<li>主存储器模块就挂接在系统总线上
<ul>
<li>通过总线完成一次存储器读/写，需占用一个总线周期。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>专用存储总线模式</li>
</ol>
<p>如果系统规模较大（所带外围设备较多），而且要求访存速度较高，则可在CPU与主存储器之间建立一组专用的高速存储总线，其中包括地址线与数据线及少量控制信号</p>
<p>在这种系统模式中，CPU通过存储总线访问主存储器，通过I/O总线访问I/O设备</p>
<h3 id="速度匹配与时序控制"><a class="header" href="#速度匹配与时序控制">速度匹配与时序控制</a></h3>
<ol>
<li>早期的统一时钟周期</li>
</ol>
<p>在早期的计算机中，常为CPU内部操作与访存操作设置统一的时钟周期，又称为节拍，以进行一次访存所需时间作为一拍的宽度</p>
<p>CPU内部操作也是每拍执行一步，由于CPU速度往往远高于主存存取速度，即完成一步CPU内部操作所需的时间远小于主存的一个存取周期，因此CPU利用率低</p>
<ol start="2">
<li>现在的分开时钟周期</li>
</ol>
<p>现在，大多数计算机为这两类操作分别设置周期</p>
<ul>
<li>
<p>CPU内部操作的时钟周期</p>
<ul>
<li>一般按CPU内部操作的需要划分时钟周期，每个时钟周期完成一步CPU内部操作，如一次传送或一次加减</li>
<li>可选取较高的时钟频率，即较短的时钟周期，以适应CPU的高速操作</li>
</ul>
</li>
<li>
<p>访存操作的总线周期</p>
<ul>
<li>通过系统总线的一次访存操作，占用一个总线周期</li>
<li>同步控制方式: 一个总线周期由若干时钟周期组成，大多数主存的存取周期是固定的，因此一个总线周期包含的时钟周期可以预知
<ul>
<li>在扩展同步控制方式中，允许延长总线周期，即增加时钟周期数</li>
</ul>
</li>
<li>异步控制方式: 总线周期与CPU时钟周期无直接关系，由异步应答确定，当存储器完成操作时往往发出一个就绪信号READY</li>
</ul>
</li>
</ul>
<p>在高速系统中，常采取一种覆盖并行地址传送技术，即在现行总线周期结束之前，提前送出下一总线周期的地址与操作命令，以提高总线传送速度。</p>
<h3 id="数据通路匹配"><a class="header" href="#数据通路匹配">数据通路匹配</a></h3>
<ol>
<li>介绍</li>
</ol>
<p>解决主存与数据总线之间的宽度匹配</p>
<p>数据总线一次能并行传送的位数，称为总线的数据通路宽度，常见的有8、16、32、64位几种。但大多数主存储器采取按字节编址，每次访存读/写8位，以适应对字符类信息的处理。这就存在一个主存与数据总线之间的宽度匹配问题。</p>
<ol start="2">
<li>举例说明</li>
</ol>
<p>Intel 8086是16位CPU，它的标准方式是</p>
<ul>
<li>在一个总线周期内可存/取2字节</li>
<li>即先送出偶单元地址（地址编码为偶数）</li>
<li>然后同时读/写偶单元及随后的奇单元</li>
<li>用低8位数据总线传送偶单元的数据，用高8位数据总线传送奇单元数据</li>
</ul>
<blockquote>
<p>这样读/写的字（16位）被称为规则字。如果传送的是非规则字，即从奇单元开始的字，就需要安排两个总线周期才能实现</p>
</blockquote>
<p>为了实现这样的传送，需将存储器分为两个存储体</p>
<ul>
<li>一个存储体的地址编码均为偶数，称为偶地址（低字节）存储体，它与低8位数据线相连</li>
<li>另一个存储体的地址编码均为奇数，称为奇地址（高字节）存储体，与高8位数据线相连。</li>
</ul>
<p><img src="assets/2024-12-17-19-23-32.png" alt="8086存储器匹配方式" /></p>
<p>这种匹配方式可推广到数据通路宽度位数更多的系统中，如32位系统。</p>
<h3 id="有关主存的控制信号"><a class="header" href="#有关主存的控制信号">有关主存的控制信号</a></h3>
<p>存储芯片本身只需要最基本的控制命令，如</p>
<ul>
<li>读/写命令</li>
<li>行/列选信号</li>
</ul>
<p>但为了实现对存储器的选择、容 量的扩展、速度匹配，系统总线可能引申出一些控制与应答信号。不同的系统总线有其自身的约定标准</p>
<blockquote>
<p>树上在此介绍了Pentium CPU与主存储器的组织，掠过</p>
</blockquote>
<h2 id="dram的发展"><a class="header" href="#dram的发展">DRAM的发展</a></h2>
<p>主存储器的基本结构仍是DRAM芯片</p>
<ul>
<li>DRAM 访问存储单元时，先送行地址，后送列地址</li>
<li>FPM DRAM 先送行，后连续送列地址</li>
<li>EDO DRAM 不必等待当前读写完毕就可启动下一个读写操作，性能比FPM DRAM提高了15％－30％</li>
<li>SDRAM 与CPU的外频同步。基于双存储体结构，CPU在访问一个的同时，另一个已准备好</li>
<li>DDR SDRAM 与SDRAM的区别是在时钟脉冲的上升沿和下降沿都可读出数据</li>
<li>Rambus DRAM 主要解决存储器带宽问题</li>
<li>RamLink 主要对处理器与存储器的接口进行改革</li>
</ul>
<h1 id="高速缓冲存储器cache"><a class="header" href="#高速缓冲存储器cache">高速缓冲存储器Cache</a></h1>
<p>为了减小CPU与主存之间的速度差异，现代微机中通常在慢速的DRAM和快速的CPU之间插入一个速度较快、容量较小的SRAM，起到缓冲作用，使CPU既能以较快速度存取SRAM中的数据，又不使系统成本上升过高，这就是Cache技术。</p>
<h2 id="cache的工作原理"><a class="header" href="#cache的工作原理">Cache的工作原理</a></h2>
<h3 id="介绍"><a class="header" href="#介绍">介绍</a></h3>
<p>Cache中存放着最近要使用的程序与数据，作为主存中当前最急需执行信息的副本</p>
<p>Cache容量较小(约为数KB到数百KB)，可以选用高速半导体存储器，提高CPU访存速度</p>
<p>有了Cache，系统在工作时</p>
<ul>
<li>总是不断地将与当前指令集相关联的一个不太大的后继指令集从主存读到Cache</li>
<li>然后再向CPU高速传送</li>
<li>从而达到速度匹配</li>
</ul>
<h3 id="工作原理"><a class="header" href="#工作原理">工作原理</a></h3>
<p>Cache的工作原理基于程序和数据访问的局部性，对大量典型程序运行情况的分析结果表明:</p>
<ul>
<li>在一个较短的时间间隔内，地址往往集中在存储器逻辑地址空间的很小范围里
<ul>
<li>程序地址的分布本来就是连续的</li>
<li>再加上循环程序段和子程序段要重复执行多次</li>
<li>因此对程序地址的访问就自然地具有相对集中的倾向</li>
</ul>
</li>
<li>数据分布的这种集中倾向不如指令明显
<ul>
<li>但对数组的存储和访问</li>
<li>及对工作单元的选择都可以使存储器地址相对集中<br />
这种对局部范围的存储器地址频繁访问，而对此范围以外的地址访问很少的现象称为程序访问的局部性</li>
</ul>
</li>
</ul>
<p>由此可以想到</p>
<ul>
<li>如果把一段时间内在一定地址范围中被频繁访问的信息成批地从主存读到一个能高速存取的小容量存储器中存放起来</li>
<li>供程序在这段时间内随时使用</li>
<li>从而尽量减少访问速度较慢的主存的次数，可以加快程序的运行速度</li>
</ul>
<p>这就是Cache的设计思想，即在CPU和主存之间设置一个小容量的高速缓冲存储器Cache</p>
<p><img src="assets/2024-12-17-19-38-02.png" alt="Cache与CPU及主存的关系" /></p>
<h3 id="拥有cache后的访存过程"><a class="header" href="#拥有cache后的访存过程">拥有Cache后的访存过程</a></h3>
<p>当CPU需要访存时</p>
<ul>
<li>同时将地址送往主存与Cache</li>
<li>若所需访问的内容已经在Cache中，则可直接从Cache中快速读取信息，这称为访问Cache命中</li>
<li>若访问的内容不在Cache中，即未命中，则从主存中读取信息，并考虑更新Cache，使其成为当前最急需部分</li>
</ul>
<p>为此需要实现访存地址与Cache物理地址间的映像变换，并采用某种算法进行Cache内容的更新，这将在后面做进一步的介绍</p>
<h3 id="命中率"><a class="header" href="#命中率">命中率</a></h3>
<p>所谓命中率，就是在CPU访问Cache时，所需信息恰好在Cache中的概率</p>
<blockquote>
<p>目前Cache的访问命中率可达到90%以上</p>
</blockquote>
<p>因此只要合理组织三级存储体系，从整体上讲，CPU就能以接近Cache的速度访问存储器，而总存储容量相当于联机外存的总容量</p>
<p>一般来说，Cache的存储容量比主存的容量小得多</p>
<ul>
<li>但不能太小，太小会使命中率太低</li>
<li>但也没有必要过大，过大不仅会增加成本，而且当Cache容量超过一定值后，命中率随容量的增加将不会有明显增长</li>
</ul>
<h2 id="cache的组织"><a class="header" href="#cache的组织">Cache的组织</a></h2>
<h3 id="地址映像"><a class="header" href="#地址映像">地址映像</a></h3>
<p>为了把主存中当前最急需执行的信息放到Cache中，必须应用某种函数把主存地址映像到Cache，这称为地址映像</p>
<p>在信息按照这种映像关系装入Cache并执行程序时，应将主存地址变换成Cache地址，这个变换过程称为地址变换</p>
<p>一般将主存与Cache的存储空间划分为若干大小相同的块</p>
<ol>
<li>直接映像</li>
</ol>
<ul>
<li>将主存中的块分组，每组包含的块和Cache中的块数一致</li>
<li>每组中的每一块只能映像到固定的Cache块中</li>
</ul>
<p><img src="assets/2024-12-17-19-56-35.png" alt="直接映像的Cache组织" /></p>
<p>访存时</p>
<ul>
<li>给出20位主存地址，其中
<ul>
<li>高11位为主存块号</li>
<li>低9位为块内地址</li>
</ul>
</li>
<li>为了实现与Cache间的地址映像与变换，将高11位进一步分为两部分
<ul>
<li>高7位给出主存的组号，称为主存标记，选择第0～127组中的某一组</li>
<li>低4位给出Cache块号，选择组内16块中的某一块</li>
</ul>
</li>
<li>于是，20位主存地址中的低13位也就是转换后的Cache地址</li>
</ul>
<p>在Cache方面</p>
<ul>
<li>为每一块设立一个7位的Cache标记，标志其所对应的组号</li>
</ul>
<p>因此在访存时</p>
<ul>
<li>只需比较主存地址中高7位的标记段与对应Cache块的7位标记</li>
<li>如果两者相同，表明所需访问主存块的内容现在已复制于对应Cache块之中</li>
</ul>
<p>直接映像方式比较容易实现，但不够灵活，有可能使Cache的存储空间得不到充分利用</p>
<ol start="2">
<li>全相联映像</li>
</ol>
<p>主存中每一块可以映像到任一Cache 块中</p>
<p><img src="assets/2024-12-17-19-57-18.png" alt="全相联映像的Cache组织" /></p>
<p>访存时，给出的20位地址分为两部分:</p>
<ul>
<li>高11位为主存块号</li>
<li>低9位为块内地址（与直接映像方式相同）</li>
</ul>
<p>但Cache中每块的标记为11位，表示它现在所映像的主存块号。</p>
<p>采用全相联映像方式的优点是：映像关系比较灵活，主存的各块可映像到Cache的任一块。但不能直接从主存地址码中提取Cache块号，需将主存块标记与Cache各块的标记<em><strong>逐个比较</strong></em>，直到找到标记符合的块为止，或不命中</p>
<p>因此全相联映像方式速度很慢，有失高速缓存的作用，因而不太适用。</p>
<ol start="3">
<li>组相联映像</li>
</ol>
<!-- TODO: 还是有点抽象：组相联映像 -->
<p>主存和Cache 都分组,主存每组内块数与Cache 的组数相同，主存中同一组的各块可按顺序映像到对应的Cache组中的任何一块</p>
<ul>
<li>如果Cache只有一组，就是全相联映像方式</li>
<li>如果Cache分为16组，每组只有一块，就是直接映像方式</li>
</ul>
<p><img src="assets/2024-12-17-19-57-41.png" alt="组相联映像的Cache组织" /></p>
<p>访存时，给出20位主存地址，它分为4部分</p>
<ul>
<li>高7位连同1位Cache组内块号，共8位，称为主存块标记，也就是主存的组号</li>
<li>Cache组号共3位，可选择8组之一</li>
<li>低9位为块内地址</li>
</ul>
<p>Cache中每一块设有8位标记，填写所复制的主存块的组号，如果Cache第0块复制了主存第8块（属第1组）内容，则在Cache第0块的标记中写入1。访存时，根据主存地址的中间两段共4位，找到Cache块，并将该块标记与主存地址中的主存块标记进行比较，判断是否是主存块的副本，即访问是否命中。Cache中每组有若干可供选择的块，因而较直接映像方式灵活。每组块数有限，因而代价比全相联映像方式小。</p>
<h3 id="替换算法"><a class="header" href="#替换算法">替换算法</a></h3>
<p>Cache内容需要随着程序的运行，使用程序目前访问频繁区进行更新</p>
<ol>
<li>先进先出算法(FIFO)</li>
</ol>
<p>按块调入Cache的先后次序决定淘汰的顺序，即在需要更新时，将最先调入Cache的块内容予以淘汰</p>
<p>这种方法简单，容易实现，不需要随时记录各个块的使用情况，系统开销少。但这种方法不一定合理，因为有些内容虽然调入较早，但可能仍需使用。</p>
<ol start="2">
<li>近期最少使用算法(LRU)</li>
</ol>
<p>为Cache的各个块建立一个调用情况记录表，称为LRU目录。当需要替换时，将在最近一段时间内使用最少的块内容予以淘汰</p>
<p>它按调用频繁程度决定淘汰算法，访问命中率较高，相对合理，因而使用较多</p>
<p>但它较前一种算法复杂，系统开销较大，通常是为每个块设置计数器，以记录该块的使用情况。</p>
<h3 id="cache的读写过程"><a class="header" href="#cache的读写过程">Cache的读/写过程</a></h3>
<ol>
<li>读</li>
</ol>
<ul>
<li>一方面将主存地址送往主存，启动主存读</li>
<li>同时将主存地址也送往Cache，按所用的映像方式从中提取Cache地址</li>
<li>从Cache中读取内容，并将相应的Cache标记与主存地址中的主存块标记进行比较
<ul>
<li>如果两者相同，访问Cache命中，将读出数据送往访存源，不等主存的读操作结束，就可以继续下一次访存操作</li>
<li>如果标记不符合，表明本次访问Cache失败，则从主存中读出，并考虑 是否需要更新该Cache块内容</li>
</ul>
</li>
</ul>
<p>这种方法的优点是没有时间延迟，缺点是每次CPU都要访问主存， 这样就占用了部分总线时间。</p>
<ol start="2">
<li>写</li>
</ol>
<p>写回法:</p>
<ul>
<li>当需将信息写入主存时，暂时先只写入Cache的有关单元，并用标志注明</li>
<li>直到该块内容需从Cache中替换出来时，再一次性地写入主存</li>
<li>如果CPU写Cache未命中，则为欲写的主存块在Cache中分配一行，将此块整个复制到Cache后再对其进行修改</li>
</ul>
<p><img src="assets/2024-12-18-10-10-09.png" alt="写回法示意图" /></p>
<p>优点</p>
<ul>
<li>写操作速度快</li>
<li>可以显著地减少写主存的次数</li>
<li>使得Cache真正在读/写两方面都在CPU和主存之间起到了高速缓存的作用</li>
</ul>
<p>缺点</p>
<ul>
<li>但在写回主存之前，主存中的块未经随时修改而可能失效</li>
</ul>
<p>写直达法</p>
<ul>
<li>每次写入Cache时，也同时写入主存，使主存与Cache相关块内容始终保持一致</li>
<li>如果写Cache没有命中，则只能直接向主存写入，随后可采取两种方式
<ul>
<li>一种是取主存块到Cache，并为它分配一个行位置</li>
<li>另一种方法则不取主存块到Cache</li>
</ul>
</li>
</ul>
<p><img src="assets/2024-12-18-10-12-16.png" alt="写直达法示意图" /></p>
<p>优点</p>
<ul>
<li>比较简单</li>
<li>能保持主存与Cache的一致性</li>
<li>并且无需为Cache中的每一行设置标志位</li>
</ul>
<p>缺点</p>
<ul>
<li>插入慢速的访主存操作，影响工作速度</li>
<li>并且有可能增加多次不必要的向主存的写操作，降低了Cache的功效</li>
</ul>
<h3 id="多层次cache存储器"><a class="header" href="#多层次cache存储器">多层次Cache存储器</a></h3>
<ol>
<li>单级与多级Cache</li>
</ol>
<p>由于集成度的提高，使Cache与处理器置于同一芯片（即片内Cache）成为可能</p>
<p>与通用的外部总线连接的Cache相比</p>
<ul>
<li>当所要的指令或数据能在片内Cache中找到时，就减少了对总线的访问</li>
<li>与总线长度相比，处理器内部的数据通路较短，所以存取片内Cache甚至比零等待状态的总线周期还要快</li>
<li>而且，在这段时间内，若总线空闲，可用于其他传送</li>
</ul>
<p>目前大多数的设计包含了片内Cache和外部Cache两种，构成两级Cache，其中</p>
<ul>
<li>第1级Cache(L1)集成在CPU芯片中，它速度更高，但容量较小，一般仅为几十KB</li>
<li>第2级Cache(L2)安装在主板上，它可以有较大的容量，从256 KB到2 MB不等</li>
<li>Pentium ΙΙ以后的CPU将L2Cache与CPU内核一起封装在一只金属盒内，或者直接把L2 Cache也集成到CPU芯片内，以进一步提高速度。这样，主板上的Cache就称为3级Cache（L3 Cache）。</li>
</ul>
<ol start="2">
<li>统一和分离Cache</li>
</ol>
<p>当片内Cache首次出现时，许多设计采用单个Cache同时存放数据和指令，这也称为统一Cache</p>
<p>后来随着计算机技术的发展和处理速度的加快，存取数据的操作经常会与读取指令的操作发生冲突，从而延迟了指令的读取</p>
<p>近年来，分离Cache通常把Cache分离成两部分</p>
<ul>
<li>一个专用于指令(指令Cache)</li>
<li>一个专用于数据(数据Cache)</li>
</ul>
<p>对于给定的Cache容量，统一Cache比分离Cache有较高的命中率，因为它在获取指令和数据的负载之间自动进行平衡</p>
<ul>
<li>即如果执行方式中取指令比取数据多得多，则Cache就被指令填满</li>
<li>如果执行方式中有相对较多的数据要读取，则会出现相反的情况</li>
</ul>
<p>尽管统一Cache有这些优点，但分离Cache是一种发展趋势，特别适用于如PentiumⅡ和PowerPC的超标量机器，它们强调并行指令执行和预取指令</p>
<p>分离Cache设计的主要优点是取消了Cache在指令预取器和执行单元间的竞争，它在任何基于指令流水线的设计中都是重要的。通常处理器会提前获取指令，并把要执行的指令装入缓冲器或流水线</p>
<p>假设现在有统一指令/数据Cache，当执行单元执行数据存取操作时，这一请求提交给统一Cache。如果同时指令预取器为取指令向Cache发读请求，则后一请求会暂时阻塞。这种对Cache的竞争会降低性能，因为它干扰了指令流水线的有效使用。分离的Cache结构解决了这一问题。</p>
<blockquote>
<p>书上6.4.3PentiumII CPU的Cache组织，6.5外部存储器，6.6物理存储系统的组织跳过</p>
</blockquote>
<h1 id="虚拟存储技术"><a class="header" href="#虚拟存储技术">虚拟存储技术</a></h1>
<p>虚拟存储系统建立在主存-辅存层次上，是由附加硬件装置及存储管理软件组成的存储体系</p>
<ul>
<li>使计算机具有接近主存的存取速度</li>
<li>并具有辅存的容量和位成本</li>
</ul>
<p><img src="assets/2024-12-18-12-11-33.png" alt="虚拟存储器的地位" /></p>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<ol>
<li>术语</li>
</ol>
<p>在存储管理部件和操作系统存储管理软件的支持下，将主存和辅存的地址空间统一编址，使用户获得一个很大的编程空间，其容量大大超过实际的主存储器。这个在用户界面上看到的存储器，被称为虚拟存储器（Virtual Memory，VM）</p>
<p>从用户界面看，用户可使用位数较长的编程地址进行编程，这种地址面向程序的需要，不必考虑程序将来在主存储器中的实际位置，因而称为逻辑地址。它是面向虚拟存储器的，所以又称为虚地址</p>
<p>在用户看来，CPU可按虚地址访问一个很大的存储器，其容量甚至可达整个辅存容量，显然这是一种虚拟层次</p>
<ol start="2">
<li>内部操作</li>
</ol>
<p>在实际的物理存储层次上，所编程序和数据在操作系统管理下</p>
<ul>
<li>先送入磁盘</li>
<li>然后操作系统将当前急需运行的部分调入主存，供CPU操作</li>
<li>其余暂不运行部分留在磁盘中</li>
</ul>
<p>随程序执行的需要，操作系统自动地按一定替换算法进行调度</p>
<ul>
<li>将当前暂不运行部分调回磁盘</li>
<li>将新的模块由磁盘调入主存</li>
</ul>
<p>这一层次上的工作，对用户是透明的</p>
<p>CPU执行程序时，需将程序提供的虚地址变换为主存的实际地址（实地址、物理地址）</p>
<ul>
<li>一般是先由存储管理部件判断该地址的内容是否在主存中
<ul>
<li>若已调入主存，则通过地址变换机制将虚地址转换为实地址，然后访问主存单元</li>
<li>若尚未调入主存，则通过缺页中断程序，以页为单位调入或实现主存内容调换</li>
</ul>
</li>
</ul>
<ol start="3">
<li>虚拟存储器和Cache的比较</li>
</ol>
<p>从原理上看，虚拟存储器与Cache-主存层次有很多相似之处，如地址映像方式和替换策略。</p>
<p>但是</p>
<ul>
<li>Cache-主存层次的控制完全由硬件实现
<ul>
<li>它对各类程序员都是透明的</li>
</ul>
</li>
<li>而虚拟存储器的控制是由硬件与软件结合实现
<ul>
<li>对应用程序员来说是透明的</li>
<li>但对于设计存储器管理软件的系统程序员来说是不透明的。</li>
</ul>
</li>
</ul>
<h2 id="虚拟存储器的组织方式"><a class="header" href="#虚拟存储器的组织方式">虚拟存储器的组织方式</a></h2>
<h3 id="页式虚拟存储器"><a class="header" href="#页式虚拟存储器">页式虚拟存储器</a></h3>
<ol>
<li>分页</li>
</ol>
<p>将虚存空间与主存空间都划分为若干大小相同的页，每页大小固定</p>
<ul>
<li>虚存的页称为虚页</li>
<li>主存（实存）的页称为实页</li>
</ul>
<p>这种划分是面向存储器物理结构的，因而有利于主存与辅存之间的调度管理。</p>
<p>用户编程时，将程序的逻辑空间分为若干虚页。相应地，虚地址包含两部分</p>
<ul>
<li>高位段是虚页号</li>
<li>低位段是页内地址</li>
</ul>
<ol start="2">
<li>页表机制</li>
</ol>
<p>在主存中建立一种页表，提供虚实地址变换依据，并登记一些有关页面的控制信息。若计算机采用多道程序工作方式，则可为每个用户程序建立一个页表，硬件中设置一个页表基址寄存器，存放当前所运行程序的页表的起始地址。</p>
<p>表6-3给出了一种页表示例，每一行记录了与某个虚页对应的若干信息
<img src="assets/2024-12-18-12-20-19.png" alt="页表示例" /></p>
<ul>
<li>虚页号在编程时由虚地址给出</li>
<li>盘页(块)号是该页在磁盘中的起始地址，即该虚页在磁盘中的位置</li>
<li>控制位一般包含
<ul>
<li>装入位（有效位），为1表示该虚页已调入主存</li>
<li>修改位，指出对应的主存页是否被修改过</li>
<li>替换控制位，为1表示对应的主存页需要替换</li>
<li>读/写保护位，指明该页的读/写允许权限</li>
<li>实页号，如果该虚页在主存中，则该项登记对应的主存页号。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>地址转换过程</li>
</ol>
<p>访问页式虚拟存储器的虚实地址转换过程，如图6-34所示。当CPU根据虚地址访存时</p>
<ul>
<li>首先将虚页号与页表起始地址合成，形成访问页表对应行的地址</li>
<li>根据页表该行内容判断该虚页是否在主存中</li>
<li>若已调入主存
<ul>
<li>可从页表中读得对应的实页号</li>
<li>再将实页号与虚地址中的页内地址合成，得到对应的主存实地址</li>
<li>据此可以访问实际的主存单元。</li>
</ul>
</li>
<li>若该虚页尚未调入主存
<ul>
<li>则产生缺页中断，以中断方式将所需页内容调入主存</li>
<li>如果主存空间已满，则需执行替换算法(FIFO、LRU)，将可淘汰的主存页内容调出，写入磁盘</li>
<li>再将所需页从磁盘调入主存。
<img src="assets/2024-12-18-12-22-16.png" alt="页式虚拟存储器地址转换示意图" /></li>
</ul>
</li>
</ul>
<ol start="4">
<li>快、慢页表</li>
</ol>
<p>当CPU按虚地址访存时，首先访问存放于主存之中的页表，以进行虚实地址转换，这就增加了访问主存的次数，降低了有效工作速度</p>
<p>为了将访问页表的时间降低到最低限度，许多计算机将页表分为快表与慢表两种。将当前最常用的页表信息存放在快表中，作为慢表局部内容的副本</p>
<p>快表很小，存储在一个快速小容量存储器中，该存储器是一种按内容查找的联想存储器，可按虚页号名字并行查询，迅速找到对应的实页号</p>
<p>如果计算机采用多道程序工作方式，则慢表可有多个，但全机只有一个快表</p>
<p>采用快、慢表结构后，访问页表的过程与Cache工作原理很相似，即根据虚页号同时访问快表与慢表，若该页号在快表中，就能迅速找到实页号并形成实地址</p>
<h3 id="段式虚拟存储器"><a class="header" href="#段式虚拟存储器">段式虚拟存储器</a></h3>
<ol>
<li>分段</li>
</ol>
<p>将用户程序按其逻辑结构（如模块）划分为若干段，各段大小可变</p>
<ul>
<li>段式虚拟存储器也随程序的需要动态地分段，并将各段的起始地址与段的长度写入段表中</li>
<li>编程使用的虚地址包含两部分
<ul>
<li>高位是段号</li>
<li>低位是段内地址</li>
</ul>
</li>
</ul>
<ol start="2">
<li>段表</li>
</ol>
<p>表6-4给出了一种段表示例，其中包含
<img src="assets/2024-12-18-12-27-09.png" alt="段表示例" /></p>
<ul>
<li>段号</li>
<li>装入位，为1表示该段已调入主存</li>
<li>段起点，如该段已在主存中，则该项登记其在主存中的起始地址</li>
<li>段长（与页不同，段长可变）</li>
<li>其他控制位，如读、写、执行权限等</li>
</ul>
<ol start="3">
<li>访存过程</li>
</ol>
<p>段式虚拟存储器的虚实地址变换与页式虚拟存储器相似，CPU根据虚地址访存时</p>
<ul>
<li>首先将段号与段表本身的地址合成，形成访问段表对应行的地址</li>
<li>根据段表内装入位判断该段是否已调入主存</li>
<li>若已调入主存
<ul>
<li>从段表读出该段在主存中的起始地址，与段内的地址相加，得到对应的主存实地址。</li>
</ul>
</li>
</ul>
<p><img src="assets/2024-12-18-12-28-43.png" alt="段式虚拟存储器地址转换示意图" /></p>
<h3 id="段页式虚拟存储器"><a class="header" href="#段页式虚拟存储器">段页式虚拟存储器</a></h3>
<p>如前所述</p>
<p>页式虚拟存储器采取面向存储器本身物理结构分页的策略，有利于存储空间的利用与调度，存储空间的零头小于一个页面。但是页的大小固定，这种划分不能反映程序的逻辑结构，这给程序的执行、保护与共享带来不便</p>
<p>段式虚拟存储器则是面向用户程序逻辑结构，以段为单位进行调度、传送、定位，这有利于对程序的编译处理、执行、共享与保护。但段的大小可变，不利于存储空间的管理与调度，它比页式虚拟存储器复杂；存储空间的零头可能较大，存储空间利用率低</p>
<p>为了综合页式虚拟存储器与段式虚拟存储器两种方式的优点，许多计算机采用段页式虚拟存储器。它</p>
<ul>
<li>将程序按其逻辑结构分段，每段再分为若干大小相同的页</li>
<li>主存空间也划分为若干同样大小的页。相应地
<ul>
<li>建立段表与页表</li>
<li>分两级查表实现虚实地址转换</li>
</ul>
</li>
<li>以页为单位调进或调出主存，按段共享与保护程序和数据</li>
</ul>
<p>若计算机采用单道程序工作方式，则虚地址包含3部分：</p>
<ul>
<li>段号</li>
<li>段内页号</li>
<li>页内地址</li>
</ul>
<p>若计算机采用多道程序工作方式，则虚地址包含4部分：</p>
<ul>
<li>基号</li>
<li>段号</li>
<li>段内页号</li>
<li>页内地址</li>
</ul>
<p>如图6-36所示，每道程序有自己的段表，这些段表的起始地址存放在段表基址寄存器组中。相应地，虚地址中有</p>
<ul>
<li>各用户程序的基号，又称为用户标志号，根据它选取相应的段表基址寄存器，从中获得自己的段表起始地址</li>
<li>将段表起始地址与虚地址中的段号合成，得到访问段表对应行的地址</li>
<li>从段表中取出该段的页表起始地址，与段内页号合成，形成访问页表对应行的地址</li>
<li>从页表中取出实页号，与页内地址拼装，形成访问主存单元的实地址。</li>
</ul>
<p><img src="assets/2024-12-18-12-36-24.png" alt="段页式虚拟存储器地址转换示意图" /></p>
<p>段页式虚拟存储器兼有页式与段式的优点，但要经两级查表才能完成地址转换，费时较多。</p>
<blockquote>
<p>掠过6.7.3 Pentium CPU支持的虚拟存储器</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<p>第七章、IO系统</p>
<ul>
<li><a href="7.IO_system.html#%E6%A6%82%E8%BF%B0">概述</a>
<ul>
<li><a href="7.IO_system.html#%E4%B8%BB%E6%9C%BA%E4%B8%8E%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">主机与外围设备间的连接方式</a></li>
<li><a href="7.IO_system.html#io%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%88%86%E7%B1%BB">I/O接口的功能与分类</a></li>
<li><a href="7.IO_system.html#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BC%96%E5%9D%80%E5%92%8Cio%E6%8C%87%E4%BB%A4">接口的编址和I/O指令</a>
<ul>
<li><a href="7.IO_system.html#io%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%BB%87">I/O接口编织</a></li>
<li><a href="7.IO_system.html#io%E5%91%BD%E4%BB%A4">I/O命令</a></li>
<li><a href="7.IO_system.html#%E9%80%9A%E9%81%93%E6%8C%87%E4%BB%A4">通道指令</a></li>
<li><a href="7.IO_system.html#iop%E6%8C%87%E4%BB%A4">IOP指令</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="7.IO_system.html#%E7%9B%B4%E6%8E%A5%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">直接程序控制方式</a>
<ul>
<li><a href="7.IO_system.html#%E7%AB%8B%E5%8D%B3%E7%A8%8B%E5%BA%8F%E4%BC%A0%E9%80%81%E6%96%B9%E5%BC%8F">立即程序传送方式</a></li>
<li><a href="7.IO_system.html#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F">程序查询方式</a></li>
</ul>
</li>
<li><a href="7.IO_system.html#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F">程序中断方式</a>
<ul>
<li><a href="7.IO_system.html#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a>
<ul>
<li><a href="7.IO_system.html#%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8">中断方式及其应用</a></li>
<li><a href="7.IO_system.html#%E4%B8%AD%E6%96%AD%E6%BA%90">中断源</a></li>
<li><a href="7.IO_system.html#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F">中断向量</a></li>
</ul>
</li>
<li><a href="7.IO_system.html#%E4%B8%AD%E6%96%AD%E7%9A%84%E8%BF%87%E7%A8%8B">中断的过程</a></li>
<li><a href="7.IO_system.html#%E4%B8%AD%E6%96%AD%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%9E%8B">中断接口模型</a></li>
<li><a href="7.IO_system.html#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%BC%98%E5%85%88%E7%BA%A7">中断请求优先级</a>
<ul>
<li><a href="7.IO_system.html#%E5%B9%B6%E8%A1%8C%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E9%98%9F">并行优先级排队</a></li>
<li><a href="7.IO_system.html#%E4%B8%B2%E8%A1%8C%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E9%98%9F">串行优先级排队</a></li>
<li><a href="7.IO_system.html#%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD">多重中断</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="7.IO_system.html#dma%E6%96%B9%E5%BC%8F">DMA方式</a>
<ul>
<li><a href="7.IO_system.html#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="7.IO_system.html#dma%E8%BF%87%E7%A8%8B">DMA过程</a>
<ul>
<li><a href="7.IO_system.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
<li><a href="7.IO_system.html#dma%E8%AF%B7%E6%B1%82">DMA请求</a></li>
<li><a href="7.IO_system.html#dma%E5%93%8D%E5%BA%94">DMA响应</a></li>
<li><a href="7.IO_system.html#dma%E4%BC%A0%E9%80%81">DMA传送</a></li>
<li><a href="7.IO_system.html#%E7%BB%93%E6%9D%9F%E5%A4%84%E7%90%86">结束处理</a></li>
</ul>
</li>
<li><a href="7.IO_system.html#dma%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90">DMA接口组成</a>
<ul>
<li><a href="7.IO_system.html#%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B">概念模型</a></li>
<li><a href="7.IO_system.html#%E5%8D%95%E5%AD%97%E4%BC%A0%E9%80%81%E5%92%8C%E6%88%90%E7%BB%84%E4%BC%A0%E9%80%81">单字传送和成组传送</a></li>
<li><a href="7.IO_system.html#%E5%A4%9A%E4%B8%AAdma%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%BF%9E%E6%8E%A5">多个DMA控制器的连接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="7.IO_system.html#%E9%80%9A%E9%81%93%E4%B8%8Eiop">通道与IOP</a>
<ul>
<li><a href="7.IO_system.html#%E9%80%9A%E9%81%93">通道</a></li>
<li><a href="7.IO_system.html#iop%E4%B8%8E%E5%A4%96%E5%9B%B4%E5%A4%84%E7%90%86%E6%9C%BA">IOP与外围处理机</a>
<ul>
<li><a href="7.IO_system.html#%E6%9C%AC%E5%9C%B0%E6%96%B9%E5%BC%8Flocal">本地方式(LOCAL)</a></li>
<li><a href="7.IO_system.html#%E8%BF%9C%E7%A8%8B%E6%96%B9%E5%BC%8Fremote">远程方式(REMOTE)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="7.IO_system.html#%E6%80%BB%E7%BA%BF">总线</a>
<ul>
<li><a href="7.IO_system.html#%E4%BB%8B%E7%BB%8D">介绍</a>
<ul>
<li><a href="7.IO_system.html#%E5%8A%9F%E8%83%BD%E5%92%8C%E5%AE%9A%E4%B9%89">功能和定义</a></li>
<li><a href="7.IO_system.html#%E7%BB%84%E6%88%90">组成</a></li>
<li><a href="7.IO_system.html#%E5%88%86%E7%B1%BB">分类</a></li>
</ul>
</li>
<li><a href="7.IO_system.html#%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F">总线操作时序</a></li>
</ul>
</li>
</ul>
<h1 id="概述-2"><a class="header" href="#概述-2">概述</a></h1>
<p>如前所述，我们可将计算机系统划分为</p>
<ul>
<li>CPU子系统</li>
<li>存储子系统</li>
<li>输入/输出子系统（简称I/O系统）三大部分</li>
</ul>
<p>其中输入/输出子系统的输入/输出就是外部设备与CPU或主存系统之间信息交换的过程</p>
<p>为了实现数据的传输，通常的做法：</p>
<ul>
<li>以总线作为传送信息的枢纽</li>
<li>并在主机与I/O设备之间设置输入/输出接口(简称I/O接口)</li>
</ul>
<p>本章将着重讨论I/O接口的几种控制方式：</p>
<ul>
<li>直接程序控制方式</li>
<li>中断方式及DMA方式<br />
还包括它们的基本结构、工作过程和程序设计方法等内容</li>
</ul>
<p>在这一章中，我们还要讨论I/O接口与主机的连接方式，重点介绍最常用的方式，即总线连接方式，包括</p>
<ul>
<li>总线的组成</li>
<li>控制和操作方式</li>
</ul>
<p>最后，将简介几种最常用的I/O设备：键盘、鼠标器、打印机和液晶显示器，并以键盘为例阐述其驱动程序的设计。</p>
<h2 id="主机与外围设备间的连接方式"><a class="header" href="#主机与外围设备间的连接方式">主机与外围设备间的连接方式</a></h2>
<ol>
<li>总线连接方式</li>
</ol>
<p>总线连接方式：CPU通过系统总线与存储器和各种I/O设备相连</p>
<p><img src="assets/2024-12-18-15-12-22.png" alt="总线连接方式图解" /></p>
<p>系统总线一半包括三组：</p>
<ul>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线，控制总线上的控制信号一般包括
<ul>
<li>同步时序信号或应答信号</li>
<li>数据传送控制信号（如地址有效、读写控制、M/IO选择）</li>
<li>中断请求及批准信号</li>
<li>DMA请求及批准信号等。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>双总线连接方式</li>
</ol>
<p>为了提高信息传送率，有些系统中设置多组总线:</p>
<ul>
<li>其中一条高速的局部总线用来连接存储器和高速I/O设备</li>
<li>另一条常规系统总线用来连接相对较慢的I/O设备<br />
目前微机中的PCI总线体系与此类似。</li>
</ul>
<p><img src="assets/2024-12-18-15-14-35.png" alt="双总线方式示意图" /></p>
<ol start="3">
<li>局部总线连接方式</li>
</ol>
<p>还有些系统</p>
<ul>
<li>除了有功能完善的系统总线与局部总线之外</li>
<li>还提供多条局部I/O总线。这种局部I/O总线一般是专用的，信号比较简单。</li>
</ul>
<p><img src="assets/2024-12-18-15-15-54.png" alt="Pentium系列CPU系统总线结构(带局部总线)" /></p>
<p>总线连接方式具有结构简单、标准化、易于扩展等优点，对传输速度的限制则可通过增设局部总线或设置多组总线方法来解决。</p>
<h2 id="io接口的功能与分类"><a class="header" href="#io接口的功能与分类">I/O接口的功能与分类</a></h2>
<p>从广义上讲，接口是指两个相对独立子系统之间的相连部分，本章主要讨论主机与I/O设备之间的硬件接口，即I/O接口。</p>
<ol>
<li>I/O接口的定义</li>
</ol>
<p><img src="assets/2024-12-18-15-19-41.png" alt="主机、I/O接口、I/O设备的关系" /></p>
<p>由于主机与各种I/O设备的相对独立性（即CPU和各种I/O设备在信息格式、信号电平、工作速度、时序上的差异），它们一般是无法直接相连的，而必须经过一个“转换”机构---I/O接口电路，简称I/O接口</p>
<p>在具体的机器中，常将I/O接口设计成独立的电路板插入主机，一般称为I/O接口卡或I/O适配卡</p>
<p>一般而言，我们把直接针对设备具体工作过程进行控制的那部分功能电路，称为该设备的“设备控制器”</p>
<ol start="2">
<li>I/O接口的功能</li>
</ol>
<p>I/O接口并非仅仅完成物理上的连接，一般讲它应具有下述主要功能：</p>
<ul>
<li>
<p>寻址功能
一台计算机系统中包含多台I/O设备，相应地就有不止一个I/O 接口
I/O接口电路通过地址译码产生的片选信号实现主机访问不同I/O接口
一个包含多个寄存器的I/O接口需要占用多个地址码</p>
</li>
<li>
<p>输入/输出功能
即在主机与I/O设备间交换数据、控制命令及状态信息等</p>
</li>
<li>
<p>支持主机采取程序查询、中断、DMA等访问方式
一个I/O接口往往具有多种访问方式</p>
</li>
<li>
<p>提供主机和I/O设备所需的缓冲、暂存和驱动能力，满足一定的负载要求和时序要求</p>
<p>为了协调主机和I/O设备间的信息交换，接口往往需要进行缓存、暂存，并满足各自的时序要求
I/O接口的一侧通常与系统总线相连接，由于总线上连有许多的电路，且有一定传输距离，从而要求接口必须能提供足够的驱动能力，并且接口自身的负荷也应限制在一定的水平上。在I/O设备方面也有类似的要求。</p>
</li>
<li>
<p>进行数据类型、格式等方面的转换</p>
<p>由于外设支持的数据格式与主机CPU的并行数据格式往往不同，I/O接口应</p>
<ul>
<li>具有把CPU输出的并行数据转换成所接外设可接收的格式</li>
<li>把从外设输入的数据信息转换成CPU可以接收的并行数据</li>
</ul>
</li>
<li>
<p>联络功能
I/O接口和CPU，或者I/O接口和外设完成一次数据传送后</p>
<ul>
<li>接口应以适当的信号（如就绪信号）的方式通知CPU或外设</li>
<li>以准备进行下一次传送</li>
</ul>
</li>
<li>
<p>复位功能
接口应能接收复位信号，使接口本身以及所连的外设进行重新启动</p>
</li>
<li>
<p>可编程功能
为了实现对接口的灵活控制，需要用软件来对接口进行设置和控制，所以一个接口应该具有可编程功能。</p>
</li>
<li>
<p>错误检测功能</p>
<p>在接口设计中，常常要考虑对错误的检测问题，需要对两类错误进行检测</p>
<ul>
<li>
<p>一类是传输错误</p>
<ul>
<li>这是由于接口和设备之间的连线受噪声干扰而引起的</li>
<li>接口对传输错误大都采用奇/偶校验或冗余校验来进行检测</li>
</ul>
</li>
<li>
<p>另一类是覆盖错误</p>
<ul>
<li>这是由于在输入时</li>
<li>接口的输入缓冲寄存器中的数据在没有被CPU取走前，由于某种原因又被装上了新的数据</li>
<li>或者在输出时，输出缓冲寄存器中的数据在被外设取走以前又被CPU写入了一个新数据，则原来的数据就被覆盖了</li>
<li>对覆盖错误，接口采用设置相应的状态寄存器标志位来标记。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>I/O接口的类型</li>
</ol>
<ul>
<li>
<p>按数据传送的格式可分为串行接口和并行接口</p>
<ul>
<li>并行接口
<ul>
<li>主机与I/O接口、接口与I/O设备间均以并行方式传送数据</li>
<li>适宜于传输距离较近、传输速度较高的场合，其接口电路相对简单</li>
</ul>
</li>
<li>串行接口:
<ul>
<li>接口与I/O设备间采用串行方式传送数据，而串行接口与主机间的数据传送一般仍为并行方式</li>
<li>适于传输距离较远、速度相对较低的场合，其传输线路成本较低，而接口电路较前者复杂</li>
</ul>
</li>
</ul>
</li>
<li>
<p>按主机访问I/O设备的控制方式，可分为</p>
<ul>
<li>程序查询接口: CPU通过程序来查询接口的状态寄存器，并执行相应动作</li>
<li>中断接口: 接口向主机提出中断请求，主机响应后执行中断处理程序</li>
<li>DMA接口: 接口与主存间采用DMA方式进行数据交换，比一般的接口更为复杂，可为CPU分担管理I/O功能</li>
<li>通道控制器: 通过执行通道程序控制I/O操作的控制器</li>
<li>I/O处理机: 通道的进一步发展<br />
事实上，一个实际的接口往往具有多种控制方式</li>
</ul>
</li>
<li>
<p>按时序控制方式可分为</p>
<ul>
<li>同步接口: 与同步总线相连的接口，其信息传送由统一的时序信号同步控制</li>
<li>异步接口: 与异步总线相连的接口，其信息传送采用异步应答方式控制</li>
</ul>
</li>
</ul>
<p>还需指出一点，一个完整的I/O接口不仅</p>
<ul>
<li>包括一些硬件电路</li>
<li>还可能包括相关的软件驱动程序模块。这些软件模块
<ul>
<li>有的放在接口上的ROM中</li>
<li>有的放在主机系统板上的ROM中</li>
<li>也有的放在磁盘上<br />
当需要时才装入内存</li>
</ul>
</li>
</ul>
<blockquote>
<p>在微机系统中的ROM中，这些软件称为基本输入/输出系统（BIOS）</p>
</blockquote>
<h2 id="接口的编址和io指令"><a class="header" href="#接口的编址和io指令">接口的编址和I/O指令</a></h2>
<h3 id="io接口编织"><a class="header" href="#io接口编织">I/O接口编织</a></h3>
<ol>
<li>与存储器统一编址</li>
</ol>
<p>将I/O接口中寄存器级部件看作存储器单元，与主存储器单元统一编址，给接口中各寄存器分配一些总线地址。这样，对I/O接口的访问就如同对主存单元的访问一样</p>
<p>这种编址方法的优点是</p>
<ul>
<li>操作方式灵活</li>
<li>不一定使用专门的I/O指令，使用通用的MOV指令或访存指令也可访问I/O接口</li>
</ul>
<p>其缺点是需占用小部分存储地址</p>
<ol start="2">
<li>I/O端口单独编织</li>
</ol>
<p>设置单独的I/O地址空间，为I/O接口中的寄存器级部件分配I/O端口地址，使用专门的I/O指令去访问</p>
<p>一般来说，I/O地址线与存储器地址线公用，即分时共享地址总线，并设置专门的信号线来区分当前是存储器访问周期还是I/O访问周期</p>
<ul>
<li>如果是存储器访问周期，则地址总线送出存储器地址</li>
<li>如果是I/O访问周期，则地址总线（通常是低位段）送出I/O端口地址</li>
</ul>
<p>采用I/O端口单独编址方式的优点是不占用存储地址；缺点是需使用专门的I/O指令，其寻址方式较简单，所以编程灵活性稍差。</p>
<h3 id="io命令"><a class="header" href="#io命令">I/O命令</a></h3>
<p>不同的CPU，其I/O指令的格式与功能差异较大，主要体现在寻址方式方面</p>
<p>Intel 80x86 CPU采用I/O端口单独寻址方式寻址外设，其中所用到的专用指令只有两个：IN和OUT。这两个指令的</p>
<ul>
<li>目标寄存器（对IN指令）和源寄存器（对OUT指令）必须是AL（8位端口）、AX（16位端口）或EAX（32位端口）</li>
<li>对端口地址在8位以下（即端口地址&lt;FFH）的，可以使用直接寻址方式寻址外设</li>
<li>对端口地址是16位的，要用DX进行间接寻址，16位端口地址方式下可寻址216=64K个端口地址。</li>
</ul>
<h3 id="通道指令"><a class="header" href="#通道指令">通道指令</a></h3>
<p>前面所说的I/O指令是CPU用来直接访问I/O端口的，而在具有通道的计算机系统中，用于I/O方面的指令格式一般包括</p>
<ul>
<li>操作码</li>
<li>数据传输内存地址</li>
<li>特征位</li>
<li>计数器</li>
</ul>
<p>它包括两个层次：</p>
<ol>
<li>供主CPU执行的I/O指令</li>
</ol>
<p>用来访问通道。一般有</p>
<ul>
<li>通道启动</li>
<li>通道道查询</li>
<li>以及其他一些对通道进行特定操作的控制命令</li>
</ul>
<ol start="2">
<li>供通道执行的通道指令</li>
</ol>
<p>用来编写通道程序，在主CPU启动指令通道后，由通道执行通道程序执行以实现I/O操作。在通道指令中，除了</p>
<ul>
<li>与CPU的I/O指令类似的输入、输出指令外</li>
<li>还包括一些与设备特性有关的控制命令<br />
与CPU指令相比，通道指令格式简单，功能专一，有很强的面向I/O设备的特征</li>
</ul>
<h3 id="iop指令"><a class="header" href="#iop指令">IOP指令</a></h3>
<p>IOP</p>
<ul>
<li>在硬、软两方面都非常接近于普通的CPU</li>
<li>但它是专用于I/O控制的处理器，因而在硬、软两方面增加了许多面向I/O的功能</li>
<li>与通道相比，它的功能更强、更通用，一般不在指令级直接反映I/O设备的特征</li>
</ul>
<p>采用IOP后，有关I/O指令也分成两级：</p>
<ul>
<li>CPU执行与IOP联络的I/O指令</li>
<li>IOP执行自身的IOP指令，具体控制I/O操作</li>
</ul>
<h1 id="直接程序控制方式"><a class="header" href="#直接程序控制方式">直接程序控制方式</a></h1>
<p>直接程序控制方式的主要特点是：</p>
<ul>
<li>CPU直接通过I/O指令对I/O接口进行访问</li>
<li>主机与外设交换信息的每一过程均在程序中表示出来</li>
</ul>
<h2 id="立即程序传送方式"><a class="header" href="#立即程序传送方式">立即程序传送方式</a></h2>
<p>I/O接口</p>
<ul>
<li>总是准备好接收主机输出数据</li>
<li>或总是准备好输入主机的数据</li>
</ul>
<p>因而CPU无需询问接口的状态，就可以直接利用I/O指令访问相应的I/O端口，输入或输出数据</p>
<p>这种方式的局限性很大，它只有在无需了解外设的实时状态时才能有效地工作</p>
<p><img src="assets/2024-12-18-16-07-49.png" alt="立即程序传送方式接口原理" /></p>
<h2 id="程序查询方式"><a class="header" href="#程序查询方式">程序查询方式</a></h2>
<p>许多外设的工作状态是很难事先预知的，这就要求CPU在程序中进行查询</p>
<ul>
<li>如果接口尚未准备好，CPU就等待</li>
<li>如果已做好准备，CPU才能执行I/O指令<br />
这就是程序查询方式</li>
</ul>
<p>首先</p>
<ul>
<li>在I/O接口中要设置状态位以表示外设的工作状态，可由CPU用输入指令读取
<ul>
<li>有些设备的状态信息较多，可组成一个或多个状态字，占用一个或多个I/O端口地址</li>
</ul>
</li>
</ul>
<p><img src="assets/2024-12-18-16-09-01.png" alt="程序查询方式模型" /></p>
<p>在相应的I/O程序中必须进行下列3步操作：</p>
<ul>
<li>读取外设状态信息</li>
<li>判断是否可进行新的操作
<ul>
<li>如果设备尚未准备好，则返回第1步</li>
<li>若已准备好，就进行下一步。</li>
</ul>
</li>
<li>执行所需的I/O操作</li>
</ul>
<h1 id="程序中断方式"><a class="header" href="#程序中断方式">程序中断方式</a></h1>
<p>在程序查询方式中，CPU的利用率不高，这是因为CPU会对外设执行大量无效的查询，长期处于等待状态</p>
<p>为此，在现代计算机系统中广泛采用了中断控制方式</p>
<h2 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h2>
<h3 id="中断方式及其应用"><a class="header" href="#中断方式及其应用">中断方式及其应用</a></h3>
<p>在接到随机请求后</p>
<ul>
<li>CPU响应该申请，暂停执行原来的程序
<ul>
<li>保存程序的当前位置（断点）</li>
<li>保存被中断程序的寄存器内容</li>
</ul>
</li>
<li>转去执行中断处理程序，为响应的随机事件服务</li>
<li>处理完毕后CPU恢复原程序的继续执行
<ul>
<li>先恢复被保存的主程序的寄存器内容</li>
<li>然后回到主程序的中断处</li>
<li>继续执行原程序
这种控制方式称为“程序中断控制方式”，简称为中断</li>
</ul>
</li>
</ul>
<p><img src="assets/2024-12-18-16-16-25.png" alt="生活中的中断" /></p>
<p>中断有两个重要的特征：</p>
<ul>
<li>程序切换（控制权的转移）</li>
<li>随机性（所谓随机性是相对于具体发生时刻而言的）</li>
</ul>
<p>中断过程的程序转移类似于子程序调用，但它们在实质上存在重大区别</p>
<ul>
<li>子程序调用是由主程序安排在特定位置上的，通常是完成主程序要求的功能</li>
<li>而中断发生在随机的时刻，可以从主程序的任一位置进行程序切换，而且中断处理程序的功能往往与被打断的主程序没有直接关联</li>
</ul>
<p>中断方式不仅用于I/O设备的管理控制，还广泛地应用于各种带随机性质的事件处理上</p>
<h3 id="中断源"><a class="header" href="#中断源">中断源</a></h3>
<p>引起中断的原因或来源称为中断源</p>
<ul>
<li>内部中断(源): 中断原因来自CPU内部
<ul>
<li>软中断: 一类较特殊的内部中断源</li>
</ul>
<blockquote>
<p>例如：除法出错、溢出，单步中断标志位，中断指令(INT n)等</p>
</blockquote>
</li>
<li>外部中断(源): 中断原因赖在CPU外部</li>
</ul>
<ol>
<li>非屏蔽中断和可屏蔽中断</li>
</ol>
<p>在CPU内部往往有一个“中断允许标志位”IF，相应地将中断源分为两类：</p>
<ul>
<li>非屏蔽中断: 不受IF控制 ，只要有非屏蔽中断产生，CPU可立即响应</li>
<li>可屏蔽中断: 中断源受IF控制
<ul>
<li>IF=1，开中断状态，即CPU允许中断，若有可屏蔽中断产生，则CPU能够响应</li>
<li>IF=0，关中断状态，对于可屏蔽中断请求CPU不响应</li>
</ul>
<blockquote>
<p>对IF的设置分为显式（使用专门的开/关中断命令）和隐式设置两种方式</p>
</blockquote>
</li>
</ul>
<p>中断屏蔽保证CPU在执行一些重要程序段时不被打断，该特性称为操作的“原子性”，在执行操作系统的原语时就要求如此</p>
<h3 id="中断向量"><a class="header" href="#中断向量">中断向量</a></h3>
<p>一个系统往往具有多个中断源，每个中断源所需的中断处理程序各不相同，它们在主存中的位置也不一定连续，该存储位置称为中断处理程序的入口地址</p>
<p>中断处理程序入口地址称为中断向量</p>
<ol>
<li>查询法</li>
</ol>
<p>CPU响应中断后</p>
<ul>
<li>转向某个固定的入口地址，执行公共服务程序（查询程序）</li>
<li>依次查询各个中断源的中断请求标志“IRF”</li>
<li>若遇到某个中断源的IRF=1，就转入该中断源的处理程序入口</li>
</ul>
<p><img src="assets/2024-12-19-14-37-04.png" alt="查询中断源程序框图" /></p>
<p>软件查询法</p>
<ul>
<li>只需在中断接口中设置IRF标志，硬件要求最低</li>
<li>实现最简单，易于动态改变各中断源的优先级（即改变查询顺序）</li>
<li>但在执行查询程序时，如果中断源优先级低则响应速度较慢</li>
</ul>
<p>因此这种方法</p>
<ul>
<li>适用于低速、中断源较少的场合</li>
<li>或作为一种辅助手段</li>
</ul>
<p>软件查询法又称为非向量中断法。</p>
<ol start="2">
<li>单独请求线编码法</li>
</ol>
<p>每个中断源有自己的中断请求信号线，在CPU内采用某种优先编码逻辑形成它们各自的入口地址</p>
<p>这种方法</p>
<ul>
<li>响应速度快</li>
<li>但连线多，硬件代价高</li>
<li>而且不易于扩展</li>
</ul>
<p>仅适于中断源极少且固定的场合，如某些单片机中的集成I/O口中断请求。</p>
<ol start="3">
<li>向量中断法</li>
</ol>
<p>中断源</p>
<ul>
<li>通过有关控制逻辑给出一个相应的向量码</li>
<li>CPU据此通过一系列变换得到中断处理程序的入口地址，无需软件查询</li>
</ul>
<p>早期的一些简单系统中，采用一级向量方式，即直接由中断源产生中断向量，但由于缺乏灵活性，对中断源的向量产生机构要求较高，现已较少采用</p>
<p>现在常用的是二级向量或多级向量方式</p>
<ul>
<li>中断源向CPU提供一个中断类型码，可视为第一级向量编码</li>
<li>其中内中断占用固定的类型码</li>
<li>还有一部分是留待系统扩展时用的保留部分</li>
<li>其余是用户可自由使用的类型码</li>
</ul>
<p><img src="assets/2024-12-19-14-41-17.png" alt="8086中断类型码分配表" /></p>
<p>将各个中断处理程序的入口地址组织成一个中断向量表</p>
<ul>
<li>存放在地址0～3FFH区间</li>
<li>每个中断源的处理程序入口地址在向量表中占4字节单元
<ul>
<li>其中2字节为偏移量IP</li>
<li>2字节为段基值CS</li>
</ul>
</li>
<li>设中断源提供的类型码为N ，则入口地址为
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span></li>
</ul>
<blockquote>
<p>在实际系统中，常将几种方法综合使用，此时称为综合法</p>
</blockquote>
<h2 id="中断的过程"><a class="header" href="#中断的过程">中断的过程</a></h2>
<p>中断的过程一般可划分为几个阶段</p>
<ul>
<li>中断请求</li>
<li>中断排优</li>
<li>中断响应</li>
<li>中断处理</li>
<li>中断返回</li>
</ul>
<p>现以8086 CPU的向量中断为例介绍中断的过程</p>
<ol>
<li>中断请求</li>
</ol>
<p>如前所述，各种中断源提出中断请求的原因各不相同。有些是完全随机产生的；有些是程序有意安排的，它们通过各自的路径送往CPU，而内中断请求则通过内部逻辑电路提出。</p>
<ol start="2">
<li>中断排忧</li>
</ol>
<p>如果有几个请求同时提出，优先排队的一般原则是：</p>
<ul>
<li>由故障引起的中断优先于由I/O操作需要引起的中断</li>
<li>非屏蔽中断优先于可屏蔽中断</li>
<li>高速事件中断优先于低速事件中断</li>
<li>输入信息所需的中断优先于输出信息所需的中断</li>
</ul>
<p>排优逻辑的实现方法将在后面介绍</p>
<ol start="3">
<li>中断响应</li>
</ol>
<ul>
<li>
<p>CPU每执行完一条指令后，通过有关控制逻辑判别是否有中断请求</p>
</li>
<li>
<p>进入中断响应周期</p>
<ul>
<li>如果有中断请求，而CPU刚执行的不是停机指令，且无优先级更高的DMA请求</li>
<li>则CPU在执行完一条指令后可以响应中断请求</li>
<li>于是CPU进入一个过渡周期(位于原程序与中断处理程序之间)，称为“中断响应周期”，简称INTA周期</li>
<li>除INTR以外的其他中断请求均属于非屏蔽中断，一旦它们提出中断请求，CPU将立即响应并得到其类型码</li>
<li>如果在INTR线上发生请求，CPU首先要根据其内部的“中断允许位”IF状态，判别是否响应</li>
<li>若IF=1，则响应中断请求
<ul>
<li>一方面进入INTA周期</li>
<li>另一方面向外发出应答信号INTA</li>
<li>外部的中断控制器收到该信号后，将发出请求的中断源的类型码送到CPU数据总线上</li>
<li>CPU在撤销INTA信号前取走中断类型码</li>
</ul>
</li>
<li>CPU在响应周期中由硬件自动完成以下操作
<ul>
<li>首先是保护断点，将代码段寄存器CS和指令指针IP的内容依次压入堆栈，此外还将标志位寄存器FLAG内容压栈</li>
<li>中断允许标志清零，即IF=0（又称为关中断）</li>
<li>单步中断标志TF清零，即TF=0</li>
<li>然后CPU通过中断类型码在中断向量表中获得向量地址，读出中断服务程序入口地址，分别送入CS和IP寄存器</li>
<li>转入取指周期，CPU开始执行中断处理程序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="assets/2024-12-19-15-16-50.png" alt="8086 CPU中断响应时序" /></p>
<ol start="4">
<li>中断处理</li>
</ol>
<p>中断处理程序一般采用三段式结构：</p>
<ul>
<li>开头是保护现场: 将中断处理程序需要使用的CPU寄存器内容压栈保存</li>
<li>中间是实质性中断处理: 功能因中断源的不同而不同</li>
<li>结尾是恢复现场</li>
</ul>
<ol start="5">
<li>中断返回</li>
</ol>
<p>在返回主程序前需要先恢复现场，即</p>
<ul>
<li>将保存现场时压入堆栈的寄存器内容从堆栈中弹出，送回原寄存器</li>
<li>然后使用中断返回指令IRET，以恢复断点，返回被中断的主程序，继续执行</li>
</ul>
<p>在8086 CPU中，IRET完成下列功能</p>
<ul>
<li>IP出栈</li>
<li>CS出栈</li>
<li>FLAG出栈</li>
</ul>
<blockquote>
<p>其弹出顺序正好与中断响应时压栈的顺序相反，即先进后出</p>
</blockquote>
<p>与普通RET指令相比，它仅仅多了一个FLAG出栈操作</p>
<p>软中断形式实现的系统调用中</p>
<ul>
<li>常利用FLAG寄存器中的某些位来返回状态信息</li>
<li>这可以通过修改堆栈中FLAG内容来实现，也可采用其他手段</li>
<li>不采用IRET指令返回</li>
</ul>
<p>注意，此时软中断调用已失去一般中断“随机插入”的意义，仅相当于普通子程序调用，只是借用了软中断这一形式而已</p>
<p>借用软中断形式实现功能调用，其优点是形式简单，不必知道程序的入口地址，因而当具体功能子程序发生变动后，主程序无需修改</p>
<p>如果采用非向量中断形式，如查询式中断系统，中断响应和处理过程与向量中断方式稍有不同。在响应过程中，没有进行读取中断类型码以及查向量表这些操作，而是软件查询中断源，以得到具体处理程序的入口地址。</p>
<p><img src="assets/2024-12-19-15-21-24.png" alt="中断响应和处理过程粗略图" /></p>
<h2 id="中断接口模型"><a class="header" href="#中断接口模型">中断接口模型</a></h2>
<p>中断接口</p>
<ul>
<li>一侧面向通用而标准化的系统总线</li>
<li>另一侧面向各具特色的I/O设备</li>
</ul>
<ol>
<li>查询式中断接口模型</li>
</ol>
<p>将程序查询接口模型的“状态字”中的状态位信号通过驱动器接到公共的中断请求线INT上即可</p>
<p>当CPU响应中断请求时，可通过软件逐个查询接口的状态位，以确定中断源。</p>
<ol start="3">
<li>向量式中断接口模型</li>
</ol>
<p>当设备需要提出中断请求时</p>
<ul>
<li>其状态信息经过一定的逻辑综合，形成中断请求信号INTRQ</li>
<li>该信号经过中断控制逻辑送入公共请求线INTR<br />
CPU响应中断请求后</li>
<li>发出中断应答信号INTA给中断控制逻辑</li>
<li>然后，中断控制逻辑向量寄存器VR的内容通过缓冲器送入CPU数据总线</li>
<li>CPU据此访问中断向量表，读出中断处理程序入口地址</li>
<li>从而转向中断服务</li>
</ul>
<p>向量寄存器VR的内容可以是</p>
<ul>
<li>中断向量</li>
<li>或是其他向量编码，如中断类型码</li>
</ul>
<p>这些内容可由主程序在进行中断接口初始化时写入。在某些早期的系统中，VR内容则由硬件逻辑产生，且固定不变。</p>
<h2 id="中断请求优先级"><a class="header" href="#中断请求优先级">中断请求优先级</a></h2>
<p>中断控制逻辑中一般采用优先排队逻辑</p>
<h3 id="并行优先级排队"><a class="header" href="#并行优先级排队">并行优先级排队</a></h3>
<p>中断请求信号并行输入</p>
<p><img src="assets/2024-12-19-15-52-01.png" alt="并行中断排队逻辑" /></p>
<ul>
<li>当INTRi = 1时</li>
<li>不论INTR(i+1)～INTR(i+n)为何值，74LS148的输出为i ，即按优先级高的决定输出值</li>
<li>当INTA=1时，74LS138被选通，输出INTAi=0，以此打开对应的向量寄存器VRi</li>
</ul>
<p>并行优先排队的</p>
<ul>
<li>优点是响应速度很快，能满足高速CPU要求</li>
<li>但扩展性稍差，在设计时须先考虑到最大的中断请求数目。</li>
</ul>
<h3 id="串行优先级排队"><a class="header" href="#串行优先级排队">串行优先级排队</a></h3>
<ol>
<li>介绍</li>
</ol>
<p>下图优先顺序为0→n</p>
<ul>
<li>第0级的排队输入信号INTI固定为1</li>
<li>当INTR0=1时，0号门输出为0
<ul>
<li>一方面依次传递到CPU，使<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.00773em;">NTR</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>=0，向CPU提出中断请求</li>
<li>同时还依次封锁所有各级</li>
</ul>
</li>
<li>当CPU发出应答信号INTA时
<ul>
<li>仅有优先级最高的输出<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">NT</span><span class="mord mathnormal">A</span><span class="mord">0</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，输出有效</li>
<li>而其他低级别即使也有INTRi请求，但应答信号INTAi 将被封锁而不能发出</li>
</ul>
</li>
<li>若INTR0～INTR（i −1）无请求而INTRi 有请求</li>
<li>则CPU发出应答信号INTA时，INTAi 有效</li>
<li>比第i 级优先的各级，因未请求而INTR0～INTR（i −1）无效</li>
<li>比第i 级优先级低的各级，因排队链上相应的门被封锁，所以INTA（i +1）～INTAn 无效。</li>
</ul>
<p><img src="assets/2024-12-20-09-36-05.png" alt="串行中断排队示意图" /></p>
<ol start="2">
<li>评价</li>
</ol>
<p>串行排队的优点是</p>
<ul>
<li>信号简单，易于扩展，因各级逻辑一致</li>
<li>前级门的输出INTOi 就是后级门的输入INTI（i +1），可方便连接</li>
</ul>
<p>这种方式的缺点是</p>
<ul>
<li>当连接的级数很多时，由于时延增大使响应速度变慢</li>
</ul>
<p>串行排优和并行排优是优先级排队逻辑中的两种基本模式。当中断源数目很多时，也可以分组处理，如构成“组内并行、组间串行”、“组内并行、组间并行”等排队逻辑。</p>
<h3 id="多重中断"><a class="header" href="#多重中断">多重中断</a></h3>
<p>有时在同一时间会产生多个中断请求，有时正在处理一个中断时又发生了另一个中断请求</p>
<p>如果在中断处理程序中允许再响应其他中断请求，就会出现多重中断嵌套</p>
<p><img src="assets/2024-12-20-09-44-32.png" alt="中断嵌套和递归过程" /></p>
<p>一般来说，当正在进行某个中断处理时</p>
<ul>
<li>与它同级或比它优先级低的中断请求不能被响应</li>
<li>而比它优先级高的中断请求才可能被响应</li>
</ul>
<p>为实现中断嵌套，在中断处理程序中可以这样安排</p>
<ul>
<li>保护现场后，先做一些紧迫事件处理，如将接口中的数据取回主机</li>
<li>然后开中断（使IF=1），允许响应其他中断</li>
<li>若有其他优先级更高的请求发生，则保存原中断处理程序的断点和现场，转去处理新的请求</li>
<li>若无其他优先级更高的请求，则继续执行处理程序，最后恢复现场、返回</li>
</ul>
<p>在许多中断系统中，都为每个中断请求设置了一个屏蔽字。在允许多重中断的方式中</p>
<ul>
<li>每当响应中断请求时，就在处理程序中先保存原屏蔽字，送出新的屏蔽字</li>
<li>将与该请求同级的及优先级更低的请求屏蔽掉，并在中断处理程序结束时恢复原屏蔽字</li>
</ul>
<p>这样，在多重中断嵌套中，嵌入的只能是优先级更高的中断。还可由软件修改屏蔽字，暂时屏蔽某些请求，以便可以动态地修改各中断源的优先级</p>
<p>总之，在中断优先顺序的控制上，有多种方法可用，也常采取软硬结合的策略</p>
<h1 id="dma方式"><a class="header" href="#dma方式">DMA方式</a></h1>
<p>如前所述，中断方式</p>
<ul>
<li>能提高CPU利用率，可处理随机性事件与实时性任务</li>
<li>但一次中断处理过程一般只能传送一个字符
<ul>
<li>且需要经历保存现场、处理、恢复现场等阶段</li>
<li>并需要执行若干条指令才能处理一次中断事件</li>
</ul>
</li>
</ul>
<p>所以对于高速的批量数据传输，程序中断方式就很难满足要求，又引入了“直接存储器传送”控制方式，简称DMA方式。</p>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<p>DMA方式是为在主存储器与I/O设备间进行高速批量数据交换而设置的</p>
<p>它的基本思想是</p>
<ul>
<li>通过硬件控制实现主存与I/O设备间的直接数据传送</li>
<li>在传送过程中无需CPU程序干预</li>
</ul>
<p>由于每次DMA传送的工作很简单，如从主存中读取一个字送到I/O口，或从I/O口读一个字送入主存，所以一次DMA传送过程是很快的，一般只占一个存储器读写周期。因此DMA方式适合于高速数据传送</p>
<p>但是DMA方式主要是直接依靠硬件实现数据传送，它不执行程序，不能处理较复杂的事件。因此DMA方式并不能完全取代中断方式，如果某种事件处理已不只是单纯的数据传送时，还必须采用中断方式</p>
<p>事实上，在以DMA方式传送一批数据后，往往采用中断方式通知CPU进行结束处理</p>
<p>在不同的计算机系统中，DMA功能可能有所不同。最简单的系统仅能实现I/O口与主存之间的数据传送。较复杂的还可以实现I/O与I/O之间、主存单元与主存单元之间的数据传送，有的还能在传送时附加简单运算，如加1、减1、移位等</p>
<p>典型的DMA方式是由DMA控制器进行控制的。在DMA控制电路中，一般需设置下列部件：</p>
<ul>
<li>数据源指针</li>
<li>目的指针</li>
<li>数据块计数器</li>
<li>以及相应的控制逻辑</li>
</ul>
<p>如果DMA系统仅需完成I/O口与存储器之间的数据传送，则可以简化控制电路，只设置一个存储器指针，而对于I/O口的访问可通过单独的信号线实现</p>
<p>在执行一次DMA传送时，CPU放弃对系统总线的控制，它对数据、地址、控制总线的输出端均呈高阻态，称为与总线脱钩。这时系统总线由DMA控制器进行控制（驱动），占用一个或几个CPU外部访问周期，完成一次DMA操作，这种方式又称为“周期窃取”方式。</p>
<p>DMA的特点</p>
<ul>
<li>可在I/O设备与主存之间直接传送数据，以“周期窃取”方式暂停CPU对系统总线的控制，占用时间很少。</li>
<li>传送时，源与目的均直接由硬件逻辑指定。</li>
<li>主存中要开辟相应的数据缓冲区，指定数据块长，计数由硬件完成。</li>
<li>在一批数据传送结束后，一般通过中断方式通知CPU进行后处理。</li>
<li>CPU与I/O设备在一定程度上并行工作，效率很高。</li>
<li>一般用于高速、批量数据的简单传送。</li>
</ul>
<p>在DMA控制器接管总线期间，CPU与总线脱钩因而不能访问主存。但是8086等CPU中采用了“指令预取”等缓冲技术，在80486、P5等CPU中更是采用了片内Cache技术，只要CPU内的指令预取队列或Cache中有可供执行的指令，它仍能继续工作，仅当需要进行外部访问时才会暂停，因而CPU工作与DMA传送间具有更高的并行度。鉴于DMA方式的特点，它一般用于主存与高速I/O设备之间的数据交换，例如与磁盘、磁带等设备的数据传送，以及高速通信口等。</p>
<h2 id="dma过程"><a class="header" href="#dma过程">DMA过程</a></h2>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<ol>
<li>数据准备</li>
</ol>
<ul>
<li>欲将主存中某数据块送往外围接口，则需先准备好数据</li>
<li>欲从接口读数据块送入主存，则需在主存中设置相应的缓冲区。</li>
</ul>
<ol start="2">
<li>初始化DMA接口的有关控制逻辑</li>
</ol>
<ul>
<li>将主存缓冲区或数据块的首址送入“存储器指针</li>
<li>将数据块长度送往“块长计数器”</li>
<li>并送出有关命令字以确定传送方向等控制信息及I/O设备有关寻址信息等</li>
</ul>
<ol start="3">
<li>结束准备</li>
</ol>
<ul>
<li>由于在DMA传送结束后常以中断方式请求CPU进行后处理</li>
<li>所以在DMA初始化阶段还应进行这方面的有关初始化工作。</li>
</ul>
<h3 id="dma请求"><a class="header" href="#dma请求">DMA请求</a></h3>
<p>当接口已准备好输入数据可送入主存或已作好准备可从主存接收新的数据时（如接口中的缓冲存储器已空）</p>
<ul>
<li>接口通过有关逻辑向CPU发出DMA请求信号</li>
<li>同中断信号一样，DMA请求也有单独请求、公共请求及排优等问题，我们将在后面章节讨论。</li>
</ul>
<h3 id="dma响应"><a class="header" href="#dma响应">DMA响应</a></h3>
<p>CPU接到DMA请求，在当前总线周期操作结束后</p>
<ul>
<li>暂停CPU对系统总线的控制与使用</li>
<li>发出DMA应答信号</li>
<li>并将其对地址总线、数据总线、控制总线的输出端置成高阻态</li>
<li>将总线控制权交给DMA控制器。</li>
</ul>
<h3 id="dma传送"><a class="header" href="#dma传送">DMA传送</a></h3>
<p>DMA控制器接到应答信号后</p>
<ul>
<li>向I/O接口发出DMA请求的确认</li>
<li>根据初始化布置的传送功能命令，发出相应的信号驱动总线</li>
<li>将“地址指针”内容送上地址总线</li>
<li>将存储器读/写与I/O读/写信号等送上控制总线，并与其他信号配合，完成一次总线传送
<ul>
<li>如一次主存单元与I/O接口寄存器间的数据传送。每次DMA传送后，“地址指针”拨动一次（加或减），块长 计数器减1</li>
</ul>
</li>
<li>每完成一次DMA传送后，可以暂时清除DMA请求信号，接口再次具备传送条件时重新发出请求信号。如此重复进行，直至完成整个数据块的传送。</li>
</ul>
<h3 id="结束处理"><a class="header" href="#结束处理">结束处理</a></h3>
<p>当数据块传送完毕后</p>
<ul>
<li>一般可由块长计数器的回零信号，或由接口产生中断请求，通知CPU进行后处理</li>
<li>例如重新初始化，准备下一个数据块，或处理刚收到的数据块等。</li>
</ul>
<h2 id="dma接口组成"><a class="header" href="#dma接口组成">DMA接口组成</a></h2>
<h3 id="概念模型"><a class="header" href="#概念模型">概念模型</a></h3>
<p>在不同的系统中，DMA接口的功能和组织可能有所不同，主要涉及下述几个问题</p>
<ul>
<li>DMA控制逻辑与I/O接口是分离的，还是合并的</li>
<li>DMA传送范围是局限于主存与I/O设备之间，还是更为广泛一些。</li>
<li>DMA传送的数据是否需要经过DMA控制器。</li>
<li>一个DMA控制器与多台设备之间的连接方式。</li>
<li>多个DMA控制器的请求方式与判优方式。</li>
</ul>
<ol>
<li>单通道合并型DMA接口</li>
</ol>
<p>DMA控制逻辑与I/O接口合并为一个整体，称为DMA接口</p>
<ul>
<li>一个DMA接口对应一台设备，称为单通道</li>
<li>设备通过DMA接口与主存进行数据交换</li>
</ul>
<p><img src="assets/2024-12-20-10-24-38.png" alt="单通道合并型DMA接口模型图" /></p>
<ul>
<li>
<p>地址寄存器/计数器
主存缓冲区的地址指针</p>
<ul>
<li>初始化时由CPU程序设置，指向主存缓冲区首址</li>
<li>每进行一次DMA传送后，指针拨动一次，加/减的增量取决于编址方法和每次传送的字长，一般可编程设定。</li>
</ul>
</li>
<li>
<p>块长计数器(交换量计数器)</p>
<ul>
<li>初始化时由CPU程序设置，装入数据块长度的初值</li>
<li>每进行一次DMA传送后，计数器内容减1</li>
<li>当数据块传送完毕，计数器回零并发出信号，可用来向CPU申请中断。</li>
</ul>
</li>
<li>
<p>控制字寄存器</p>
<ul>
<li>初始化时由CPU程序设置，决定将来的</li>
<li>数据传送方向（主存→接口、 接口→主存）</li>
<li>地址指针增量（如加1、减1、加2、减2等）</li>
<li>以及DMA控制逻辑的有关工作方式等</li>
</ul>
</li>
<li>
<p>DMA控制与状态逻辑</p>
<ul>
<li>决定是否发出DMA请求</li>
<li>参与各接口之间的排优</li>
<li>获得响应后产生相应的时序信号以完成DMA传送</li>
</ul>
</li>
<li>
<p>数据缓冲寄存器</p>
<p>提供传送数据的缓冲、锁存及总线的驱动能力。</p>
</li>
<li>
<p>中断机构</p>
<p>由于在数据块传送完毕后常以中断方式请求CPU进行后处理，所以DMA接口中常包含其他普通中断接口的功能。</p>
</li>
</ul>
<ol start="2">
<li>选择型DMA接口</li>
</ol>
<p>选择型DMA接口结构中</p>
<ul>
<li>DMA控制逻辑与I/O接口仍采取合并型结构</li>
<li>但通过一个局部总线（I/O总线）连接多台I/O设备，使多个I/O设备可共享一个DMA控制器</li>
</ul>
<p>在工作的某一时段</p>
<ul>
<li>DMA接口只能选择其中的一台设备</li>
<li>使它可通过I/O总线、接口与主存进行DMA传送</li>
<li>在传送完一个数据块后才能重新设置，以选择另一台I/O设备</li>
</ul>
<p>在数据块传送过程中不允许切换设备，所以这种结构仅适于各设备分时工作的方式，而接口中的选择逻辑就像是一个切换开关。</p>
<p><img src="assets/2024-12-20-11-43-14.png" alt="选择型DMA接口图示" /></p>
<blockquote>
<p>从逻辑组成看，选择型DMA接口可以看作是单通道型接口增加了I/O设备选择逻辑后，扩展而成</p>
</blockquote>
<ol start="3">
<li>集中多路型DMA控制器</li>
</ol>
<p>如同集中型中断控制器一样</p>
<ul>
<li>我们可以将DMA控制逻辑中的公用部分从设备接口中分离出来</li>
<li>利用集成电路技术将多个通道的DMA控制逻辑集成到一块芯片上，成为一种通用的集中多路型DMA控制器
<ul>
<li>DMA控制器部分与I/O设备的具体特性无关</li>
<li>负责接受I/O设备提出的DMA请求</li>
<li>然后向CPU申请控制系统总线</li>
<li>以实现DMA传送</li>
</ul>
</li>
</ul>
<p>与I/O设备具体特性相关的部分留在I/O接口中，而与DMA有关的逻辑则尽可能地得到简化</p>
<ul>
<li>一般只负责向DMA控制器发出DMA请求</li>
<li>以及在DMA控制器发回响应信号后进行数据传送</li>
</ul>
<p>由于采取DMA方式传送数据，这种I/O接口常被称为DMA接口</p>
<p>数据可在I/O设备、接口、系统总线、主存之间直接传送，并不经过DMA控制器</p>
<p>请注意</p>
<ul>
<li>在前述两种合并型结构模式中，DMA控制器与DMA接口是同一个实体</li>
<li>在分离型结构模式中，DMA控制器是通用的、可公用的部分，而接口是针对某个具体设备的</li>
</ul>
<h3 id="单字传送和成组传送"><a class="header" href="#单字传送和成组传送">单字传送和成组传送</a></h3>
<ol>
<li>单字传送方式</li>
</ol>
<p>每次DMA请求得到响应后</p>
<ul>
<li>DMA控制器占用一个总线周期进行一次传送(按总线的数据通路宽度传送一个字)</li>
<li>然后释放总线，将总线控制权交还给CPU，以进行新的一次总线控制权判别</li>
</ul>
<ol start="2">
<li>成组传送</li>
</ol>
<p>每次DMA请求得到响应后</p>
<ul>
<li>DMA控制器连续占用多个总线周期，进行多次DMA传送</li>
<li>直到一个数据块传送完毕，才将总线控制权交回给CPU</li>
</ul>
<p>在进行成组传送时</p>
<ul>
<li>由于CPU无法访问主存而可能暂停执行程序</li>
<li>如果CPU具有指令Cache和数据Cache，而且当前所需执行的指令和数据都在Cache中，则CPU可以与DMA传送并行地工作</li>
</ul>
<p>在一般情况下，I/O设备的数据传输率比主存速度低，因此在DMA控制器连续占用总线期间，必然会有一些浪费，使系统的工作效率降低</p>
<p>因此，实用的成组传送是这样工作的：</p>
<ul>
<li>当I/O设备需进行DMA传送时，就保持DMA请求信号，DMA控制器也就保持总线连续不断地进行DMA传送</li>
<li>直到I/O设备暂不需传送时才撤销DMA请求，释放总线，允许CPU使用总线</li>
</ul>
<p>这样，DMA请求对于CPU来说具有更高的优先权，可以根据需要按成组传送方式或单字传送方式工作。这种方式也被称为请求方式。</p>
<h3 id="多个dma控制器的连接"><a class="header" href="#多个dma控制器的连接">多个DMA控制器的连接</a></h3>
<p>为了扩展通道数，稍具规模的系统往往需要多个DMA控制器</p>
<p><img src="assets/2024-12-20-11-54-07.png" alt="几种DMA扩展方式" /></p>
<ol>
<li>独立请求方式</li>
</ol>
<p>每个DMA控制器与CPU间单独连接，即有独立的请求线与批准线</p>
<p>在CPU内部通过硬件逻辑进行优先级判别，决定先响应哪一路请求</p>
<p>显然，独立请求方式的扩展能力较差</p>
<ol start="2">
<li>公共请求方式</li>
</ol>
<p>CPU对外只有一根DMA请求线和一根DMA应答线</p>
<p>各DMA控制器挂接在公共请求线与公共应答线之上，并另有判优逻辑来确定优先响应谁的请求</p>
<p>判优逻辑与中断系统中的判优逻辑非常相似，也可分为</p>
<ul>
<li>串行判优</li>
<li>并行判优</li>
</ul>
<p>有些DMA控制器芯片自身带有判优逻辑电路，可以很方便地连接成判优链。</p>
<ol start="3">
<li>级联方式</li>
</ol>
<p>从片将它的DMA请求信号输出送到主片的一个通道上(主片的一个请求信号输入端)，在初始化时编程设定为级联方式。</p>
<h1 id="通道与iop"><a class="header" href="#通道与iop">通道与IOP</a></h1>
<p>DMA控制器的出现已经减轻了CPU对数据输入/输出的控制，但DMA传送中对外围设备的管理和某些操作的控制仍需由CPU承担</p>
<p>在大型计算机系统中，所连接的I/O设备数量多，输入/输出频繁，单纯依靠主CPU采取中断和DMA等管理方式已不能满足需要，于是通道和IOP方式被引入计算机系统</p>
<ul>
<li>其中通道的概念最早是由IBM公司提出的</li>
<li>以后发展为输入/输出处理机IOP</li>
<li>现在以协处理器形式应用于高档微型计算机系统中</li>
</ul>
<h2 id="通道"><a class="header" href="#通道">通道</a></h2>
<p>通道是一种专用控制器，它</p>
<ul>
<li>通过执行通道程序进行I/O操作的管理</li>
<li>为主机与I/O设备提供一种数据传输通道</li>
</ul>
<ol>
<li>特点</li>
</ol>
<p>主机通过系统总线或其他方式连接多个通道，每个通道又通过局部I/O总线连接多台I/O设备</p>
<ul>
<li>通道间可以并行工作，各自管理其I/O设备</li>
<li>但当通道需与主机交换数据时，每次只能连接一个通道</li>
<li>通道有自己的通道指令，可用来编成通道程序，存放在存储器中</li>
<li>当需要进行I/O操作时
<ul>
<li>CPU只要按约定格式准备好命令和数据，然后启动通道即可</li>
<li>通道则执行相应的通道程序，完成所要求的操作</li>
</ul>
</li>
</ul>
<ol start="2">
<li>评价</li>
</ol>
<p>由于通道具有通道程序，可完成较复杂的I/O管理和预处理，从而在很大程度上将主CPU从繁重的I/O管理工作中解脱出来，提高了系统效率</p>
<p>与中断方式相比</p>
<ul>
<li>两者都以程序方式进行I/O管理，因而功能强、灵活性高</li>
<li>但通道方式无需CPU执行中断处理程序，几乎完全取代主CPU去管理I/O操作，使主CPU效率大大提高</li>
</ul>
<p>与DMA方式相比</p>
<ul>
<li>相同之处是两者在进行数据传送时都可直接访问主存，不需CPU程序干预</li>
<li>不同之处是
<ul>
<li>DMA方式依靠纯硬件控制传送，只能实现简单的传送</li>
<li>而通道则可通过通道程序实现复杂的操作<br />
因此可以认为：通道方式是在DMA方式的基础上发展起来的、功能更强的一种I/O管理方式，它常常覆盖DMA方式。</li>
</ul>
</li>
</ul>
<h2 id="iop与外围处理机"><a class="header" href="#iop与外围处理机">IOP与外围处理机</a></h2>
<p>随着通道的进一步发展，其结构越来越复杂，功能逐渐变得通用，发展为现在广泛使用的输入/输出处理机IOP</p>
<p>现在一般认为，IOP是通道的进一步发展</p>
<ul>
<li>与传统意义上的通道相比，IOP的指令系统更丰富、更通用，因而功能更强；</li>
<li>IOP的结构更接近于常规CPU，更具独立性，可有独立的局部存储器</li>
<li>除了能够完成传统通道的数据输入/输出功能外，还能进行一些较复杂的预处理，如码制转换、格式变换、搜索、错误检测与纠错、字与字节的拼装/拆卸等</li>
</ul>
<p><img src="assets/2024-12-20-12-05-48.png" alt="8089 IOP内部结构" /></p>
<p>如上图所示是8089IOP的内部结构框图。它</p>
<ul>
<li>结构与8086CPU非常相似，但稍稍简化些</li>
<li>具有两个I/O通道，可执行各自的通道程序</li>
<li>每个通道都有自己的寄存器组，可分别进行DMA传送</li>
<li>指令系统也与8086 CPU非常相似，但
<ul>
<li>为实现I/O操作和通道管理，增加了一些面向I/O的指令</li>
<li>而较复杂的数据处理指令则被省略</li>
</ul>
</li>
</ul>
<p>8089 IOP可访问1 MB的存储器空间和64 KB的I/O空间。它与系统的连接方式可分为两类：本地方式和远程方式。</p>
<h3 id="本地方式local"><a class="header" href="#本地方式local">本地方式(LOCAL)</a></h3>
<ol>
<li>概念</li>
</ol>
<p>8089 IOP与主CPU共享系统总线和主存储器</p>
<ul>
<li>将IOP的地址线、数据线和一些控制信号线，直接与主CPU 8088并联</li>
<li>CPU与IOP之间的通信，数据交换是通过共享主存来实现的</li>
<li>CPU将通道程序存放在主存中，由硬件电路产生控制信号“通道注意”
<ul>
<li>通知8089 IOP去执行通道程序</li>
<li>也可以在必要时终止8089 IOP的执行</li>
</ul>
</li>
<li>当IOP需要使用总线访问主存或访问I/O接口时，向CPU提出申请
<ul>
<li>如果CPU不需占用总线，可将总线控制权让给IOP</li>
<li>待8089 IOP使用完总线后，交回总线权</li>
</ul>
<blockquote>
<p>在本地方式中，主CPU是总线的主控者</p>
</blockquote>
</li>
</ul>
<p><img src="assets/2024-12-20-14-01-22.png" alt="8089 IOP本地方式示意图" /></p>
<ol start="2">
<li>评价</li>
</ol>
<p>本地方式的优点是：</p>
<ul>
<li>IOP能与主CPU共享存储空间和I/O空间</li>
<li>因而结构简单、编程方便<br />
其缺点是：</li>
<li>IOP与CPU之间可能存在较严重的总线使用冲突</li>
<li>并行程度不高，使系统性能受到很大的制约</li>
</ul>
<h3 id="远程方式remote"><a class="header" href="#远程方式remote">远程方式(REMOTE)</a></h3>
<p>远程方式是IOP与主CPU共享系统总线，但IOP另有自己的局部I/O总线，即</p>
<ul>
<li>IOP通过独立的局部总线连接其局部存储器与局部I/O设备</li>
<li>并通过总线接口与CPU系统总线相连接</li>
</ul>
<p><img src="assets/2024-12-20-14-05-44.png" alt="8089 IOP远程方式示意图" /></p>
<p>在远程方式中</p>
<ul>
<li>IOP与主CPU之间的通信仍通过共享主存（属于系统空间）来实现</li>
<li>但IOP的程序存放在自己的局部存储器中，因此
<ul>
<li>IOP可通过自己的局部总线读取IOP程序或访问局部I/O设备</li>
<li>仅当需要与共享主存交换数据时，IOP才使用系统总线</li>
</ul>
</li>
<li>系统总线的使用冲突被减小到最低程度，并行程度大为提高</li>
</ul>
<h1 id="总线"><a class="header" href="#总线">总线</a></h1>
<h2 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h2>
<h3 id="功能和定义"><a class="header" href="#功能和定义">功能和定义</a></h3>
<p>总线是一组能为多个部件分时共享的信息传送线</p>
<ul>
<li>用来连接多个部件并为之提供信息交换通路</li>
<li>共享性，即总线所连接的部件都可通过它传送信息</li>
<li>分时性，即在某一时刻总线只允许有一个部件送出数据到总线上</li>
<li>共享是分时实现的</li>
</ul>
<p>总线不仅是一组信号线，从广义上讲，总线是</p>
<ul>
<li>一组传送线路</li>
<li>及相关的总线协议</li>
</ul>
<p>因为要实现分时共享，必须定义相应的规则，称为总线协议，各个连到总线上的部件必须遵守这些协议，才能有序地分时共享该总线</p>
<p>总线协议一般包括：</p>
<ul>
<li>信号线定义</li>
<li>数据格式</li>
<li>时序关系</li>
<li>信号电平</li>
<li>控制逻辑等<br />
它确定了一个系统使用总线的方法。</li>
</ul>
<h3 id="组成"><a class="header" href="#组成">组成</a></h3>
<p>总线包括一组物理信号线，按其功能可分为4组：数据线、地址线、控制信号线和电源线。</p>
<ol>
<li>数据线</li>
</ol>
<p>数据线用来实现数据传送，常称为数据总线</p>
<ul>
<li>双向传送</li>
<li>分时共享</li>
<li>数据总线的宽度即为数据通路宽度</li>
</ul>
<ol start="2">
<li>地址总线</li>
</ol>
<p>地址线又称地址总线，用于</p>
<ul>
<li>传送地址信号</li>
<li>以确定所访问的存储单元或某个I/O端口</li>
</ul>
<p>挂接在总线上的各部件都能从地址线上接收地址信号，并配合控制信号进行地址译码</p>
<ul>
<li>只有能掌管总线控制权的主控部件(如CPU、DMA控制器等)才能向地址线上发送地址码</li>
<li>而不能掌管总线控制权的部件(如存储器)，不能发送地址码</li>
</ul>
<p>在微处理器中，由于一块芯片的引脚数有限，常采用复用技术以减少专用地址线的数目，例如在总线周期开始部分</p>
<ul>
<li>先用数据线传送地址码的高位部分，将它送入一个地址锁存器</li>
<li>同时用地址线传送地址码的低位部分，两部分合成为完整的地址码</li>
<li>然后再用数据线传送数据</li>
</ul>
<ol start="3">
<li>控制总线</li>
</ol>
<p>用来传送各类控制/状态信号，控制总线的组成情况体现了不同总线的各自特点、运行方式及应用场合。</p>
<p>按照各种控制信号的功用，我们将常见控制信号再细分为几组:</p>
<ul>
<li>数据传输控制信号</li>
<li>总线请求与控制权交换信号</li>
<li>其他控制信号</li>
<li>电源线</li>
</ul>
<h3 id="分类"><a class="header" href="#分类">分类</a></h3>
<ol>
<li>内总线</li>
</ol>
<p>连接CPU内部各部件</p>
<ol start="2">
<li>系统总线</li>
</ol>
<p>连接计算机内各部件(CPU、主存、I/O接口)</p>
<ul>
<li>一般包括地址、数据和控制信号三类传输线，以及电源线</li>
<li>内总线的连接距离较短，传输速度较快</li>
</ul>
<ol start="2">
<li>外总线</li>
</ol>
<p>多台计算机系统之间的连接总线</p>
<ul>
<li>一般仅有数据线及少量简单的控制信号线，数据线的数据通路宽度较窄</li>
<li>外总线的传输距离一般较远，速度较慢</li>
</ul>
<h2 id="总线操作时序"><a class="header" href="#总线操作时序">总线操作时序</a></h2>
<ol>
<li>同步控制方式</li>
</ol>
<p>采用同步控制方式的总线，称为同步总线</p>
<p>在同步控制方式中，数据传输过程完全在主控部件的控制下进行，有着统一的时钟同步信号</p>
<ul>
<li>读数据的整个过程都是在时钟CLK的同步控制下进行的</li>
<li>所有控制信号的产生与结束也是受CLK的同步控制。</li>
</ul>
<p>总线上各模块的工作速度往往是不一致的，采用统一的同步时序，在设计数据传送周期时需以总线上最慢的那个模块为依据。这样，在速度较快的模块间传送数据时，效率就被迫降低了，这是同步控制方式的不足。</p>
<ol start="2">
<li>扩展同步方式</li>
</ol>
<p>为了解决纯同步方式适应性差的问题，人们在同步方式中引入了异步控制的思想，称为扩展同步方式。此处，仍以PC总线为例，说明这种改进方式。</p>
<p>如果从模块的速度较慢，不能在基本总线周期内完成操作</p>
<ul>
<li>就发出READY=0信号，表示尚未准备好</li>
<li>主模块在脉冲的上升沿采样READY信号，决定是否加入“等待时钟周期”Tw</li>
<li>在Tw脉冲的上升沿，再次采样READY，看是否需要插入更多的Tw
<ul>
<li>如果READY为低，于是插入Tw以延长操作时间</li>
<li>如果从模块已准备好，READY=1，撤销等待请求
<ul>
<li>于是总线结束本次总线周期操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>扩展同步方式能灵活改变总线周期的长短，满足高速设备和低速设备的需要，既能提高效率，又保持了同步方式的优点</p>
<ol start="3">
<li>异步控制方式</li>
</ol>
<p>在异步控制方式中，没有固定的时钟周期，完全采用异步应答方式工作，总线周期的长短根据实际需要而定</p>
<p>在以应答方式相关联的信号之间就存在一种互锁关系，相应地总线时序有全互锁、半互锁、不互锁之分</p>
<p>一个典型的全互锁异步应答过程如下：</p>
<ul>
<li>主设备发送地址及“读/写”命令；</li>
<li>从设备收到读命令后，执行相应操作；</li>
<li>当从设备完成后，发出“应答”信号；</li>
<li>主设备收到应答信号后，撤销读/写命令；</li>
<li>从设备发现主设备撤销“读/写”命令后，撤销其应答信号。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
