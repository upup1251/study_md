<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Computer composition principles and assembly</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Computer composition principles and assembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="1计算机的基本概念"><a class="header" href="#1计算机的基本概念">1.计算机的基本概念</a></h1>
<p>计算机的概念：计算机是一种能够存储程序，能够自动连续地执行程序，对各种数字化信息进行算术运算或逻辑运算的快速工具。</p>
<ul>
<li>冯诺依曼体制的核心要点
<ul>
<li>采用<code>二进制</code>代表数据和指令，及信息（护具和指令）的数字化</li>
<li>采用<code>存储程序</code>工作方式，即事先编制程序，事先存储程序，自动、连续地执行程序</li>
<li>由<code>存储器</code>、<code>运算器</code>、<code>控制器</code>、<code>输入设备</code>、<code>输出设备</code>等五大件组成计算机硬件结构</li>
</ul>
<blockquote>
<p>冯诺依曼机的工作方式称为<code>控制流驱动方式</code>：依照指令的执行序列一次读取指令，依据指令所含的控制信息调用数据，进行运算处理。
这一过程中逐步发出的控制信息成为一种控制信息流，简称<code>控制流</code>，一次处理的数据信息称为一种数据信息流，简称<code>数据流</code></p>
</blockquote>
</li>
</ul>
<h1 id="12信息的数字化表示"><a class="header" href="#12信息的数字化表示">1.2.信息的数字化表示</a></h1>
<ul>
<li>计算机中各种信息用数字代码表示</li>
<li>用数字型电信号表示数字代码</li>
</ul>
<h1 id="2-计算机系统的硬软件组成"><a class="header" href="#2-计算机系统的硬软件组成">2. 计算机系统的硬、软件组成</a></h1>
<h2 id="21-计算机硬件系统"><a class="header" href="#21-计算机硬件系统">2.1 计算机硬件系统</a></h2>
<p>随着计算机硬件系统的发展，当代计算机的组成：</p>
<ul>
<li>中央处理器(CPU)=运算器+控制器
<blockquote>
<p>随着大规模集成电路的发展，可将运算器和控制器集成到一块芯片上，合称CPU</p>
</blockquote>
</li>
<li>存储器
<blockquote>
<p>可分为高速缓存、主存储器、外存储器三部分。中高速缓存常集成在CPU内部，作为CPU的一个部分，也可以在CPU之外再设置一级高速缓存。通常将CPU与主存储器合在一起称为主机，主存储器（简称主存）就是因为位于主机之内而得名，有的书中又称它为内存储器（内存）。</p>
</blockquote>
</li>
<li>输入设备</li>
<li>输出设备</li>
</ul>
<p><img src="assets/computerStruct.png" alt="" /></p>
<p>各组成部件的功能和相应特性</p>
<ol>
<li>
<p>CPU(Central Processing Unit)<br />
CPU即中央处理器，是硬件系统的核心部件，负责读取并执行指令，也就是执行程序。</p>
<ul>
<li>程序计数器PC(Program Counter)：存放当前指令所在存储单元的地址
<blockquote>
<p>PC就像一个指针，指引着程序的执行顺序。</p>
</blockquote>
</li>
<li>算术逻辑部件ALU(Arithmetic Logic Unit)
<blockquote>
<p>CPU内有一个或多个ALU，按照指令要求将有关数据送入ALU，进行指定的算数或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器内</p>
</blockquote>
</li>
<li>控制器
<blockquote>
<p>控制整个系统的工作</p>
<blockquote>
<p>控制器产生的微命令可分为一下两种：</p>
<ul>
<li>组合逻辑控制器：组合逻辑控制器完全靠若干组合逻辑电路（即硬件）产生微命令序列，将指令代码、状态信息、时序信号等输入到这些组合逻辑电路，电路将分时产生相应的微操作命令。</li>
<li>微程序控制器：是将微命令序列以代码形式编制成微程序,以用于执行</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>
<p>主存储器</p>
</li>
</ol>
<p>主存储器存放着需要执行的程序及需要处理的数据，能由CPU直接读出或写入。</p>
<p>主存储器划分为许多单元，通常每个单元存放8位二进制数，称为1字节。每个单元都有一个唯一的编号，称为存储单元地址，简称地址。向主存储器送出某个地址编码，就能根据地址选中对应的一个单元。</p>
<blockquote>
<p>。程序的最终（可执行）形态是指令序列，通常它们按照执行顺序依次存放在连续的存储单元中，通过程序计数器PC提供的指令地址，就可以逐条地读取指令。一条指令按其长度不同可存放在一个或相邻的几个单元中。有的指令需要处理的数据（又称为操作数）存放在主存的一个或相邻的几个单元中，指
令执行时，就提供地址去寻找对应单元，从中读取操作数。</p>
</blockquote>
<p>可见主存储器的一项重要特性是：能按地址（单元编号）存放或读取内容，也就是允许CPU直接编址访问，通常以字节为编址单位。对主存储器来说，寻找存储单元（寻址）的依据是地址码，所存取的内容是指令或数据。</p>
<ol start="3">
<li>外存储器</li>
</ol>
<p>外存储器用来存放那些需要联机存放，但暂不执行的程序和数据，当需要运行它们时再由外存调入主存。</p>
<blockquote>
<p>由于外存储器不由CPU直接编址访问，也就是说不需要按字节地从外存储器读取或写入，因此外存储器中的内容一般都按文件的形式进行组织，一个文件常分解为若干数据块，可以包含许多字节的信息。用户按文件名进行调用，CPU找到该文件在外存中的存放位置，以数据块为单位进行读写</p>
</blockquote>
<ol start="4">
<li>
<p>输入输出设备</p>
</li>
<li>
<p>总线</p>
</li>
</ol>
<p>总线是指一组能为多个部件分时共享的信息传输线。</p>
<blockquote>
<p>某个时刻只能有一个部件或设备向总线发送数据，如果有两个或两个以上的部件同时向总线发送数据，就会产生冲突，使数据混乱，这就是分时共享的含义。</p>
</blockquote>
<ul>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ul>
<ol start="6">
<li>接口</li>
</ol>
<p>用于连接系统总线与I/O设备之间的一些逻辑部件</p>
<hr />
<p>概括的说，计算机硬件系统是由三大子系统组成：</p>
<ul>
<li>CPU</li>
<li>存储系统（包括高速缓存、主存和外存）</li>
<li>输入/输出系统（输入/输出设备和接口）</li>
</ul>
<h2 id="22-计算机软件组成"><a class="header" href="#22-计算机软件组成">2.2 计算机软件组成</a></h2>
<h3 id="系统软件"><a class="header" href="#系统软件">系统软件</a></h3>
<p>系统软件是负责计算机系统的调度管理，提供程序的运行环境和开发环境，向用户提供各种服务的一类软件。</p>
<ul>
<li>操作系统</li>
</ul>
<p>操作系统负责管理和控制计算机系统硬、软件资源及运行的程序，它合理地组织计算机的工作流程，是用户与计算机之间的接口，为用户提供软件的开发环境和运行环境。</p>
<ul>
<li>编译程序和解释程序</li>
</ul>
<p>大多数情况下，用户采用高级程序设计语言编写程序，个别情况采用汇编语言编写程序。言编写出的程序叫做源程序。将源程序输入计算机后，计算机先执行一种语言处理程序，将源程序转换为机器语言代码序列，即机器语言程序，然后由计算机硬件执行这些用机器语言代码表示的指令序列，从而完成用户程序的执行过程。</p>
<pre><code>- 解释方式：边解释边执行
- 编译方式：先将源程序全部翻译成目标程序（目标代码）的机器语言指令序列再执行
</code></pre>
<ul>
<li>各类软件平台</li>
</ul>
<p>将开发及运行过程中所需的各种软件集成为一个综合的软件系统，称为软件平台</p>
<h3 id="应用软件"><a class="header" href="#应用软件">应用软件</a></h3>
<p>应用软件是指用户在各自应用领域中为解决各类问题而编写的程序，也就是直接面向用户需要的一类软件。</p>
<blockquote>
<p>从功能角度看，系统软件是负责系统调度管理，提供开发环境和运行环境，向用户提供各种服务的一类软件；而应用软件是用户在各自应用领域中为解决各类问题所编写的程序。从配置角度看，系统软件是用户购置的系统资源之一；而应用软件是用户自身开发的，直接面向应用需要的程序。</p>
</blockquote>
<h1 id="3-层次结构模型"><a class="header" href="#3-层次结构模型">3. 层次结构模型</a></h1>
<h2 id="31-从计算机系统组成角度划分层次结构"><a class="header" href="#31-从计算机系统组成角度划分层次结构">3.1 从计算机系统组成角度划分层次结构</a></h2>
<p><img src="assets/layer_composition.png" alt="" /></p>
<ul>
<li>微体系结构</li>
</ul>
<p>微体系结构层主要从寄存器级观察CPU的结构，分析CPU执行指令的详细过程。</p>
<pre><code>- 微程序控制器：由微程序产生的控制信号控制的，相应的控制部件称为微程序控制器；
- 组合逻辑控制器：直接由硬件产生的控制信号来控制的，相应的控制部件称为组合逻辑控制器。
</code></pre>
<blockquote>
<p>从硬件组成的角度进一步分析微体系结构层中寄存器、ALU、控制电路等部件的构成就可以看到，几种数字逻辑单元（与、或、非门）组合成了这一层的部件。</p>
</blockquote>
<ul>
<li>指令系统层</li>
</ul>
<p>指令系统（又称指令集）是指一台计算机所能执行的全部指令的集合。其指令是由微体系结构层的微程序解释执行或硬件电路直接执行的。</p>
<ul>
<li>操作系统层</li>
</ul>
<p>操作系统是一个在指令系统层提供的指令和特性之上又增加了新指令（系统调用）和特性的程序。这一层有新的指令集，有不同的存储器结构，有同时运行两个或多个程序的能力，以及其他一些特性。</p>
<ul>
<li>
<p>汇编语言层</p>
</li>
<li>
<p>面向问题（高级）语言层</p>
</li>
</ul>
<h2 id="从语言功能角度划分层次结构"><a class="header" href="#从语言功能角度划分层次结构">从语言功能角度划分层次结构</a></h2>
<p>计算机硬件的物理功能是执行机器语言，称为机器语言物理机，从这一级看到的是一台实际的机器。而用户看到的是能执行某种语言程序的虚拟机，即通过配置某种语言处理程序后所形成的一台计算机。</p>
<p><img src="assets/layer_languageFunction.png" alt="" /></p>
<h2 id="软硬件在逻辑上的等价"><a class="header" href="#软硬件在逻辑上的等价">软、硬件在逻辑上的等价</a></h2>
<p>有许多功能既可以直接由硬件实现，也可以在硬件支持下靠软件实现，对用户来说在功能上是等价的，我们称为软、硬件在功能上的逻辑等价。</p>
<h1 id="计算机的工作过程"><a class="header" href="#计算机的工作过程">计算机的工作过程</a></h1>
<h2 id="处理问题的步骤"><a class="header" href="#处理问题的步骤">处理问题的步骤</a></h2>
<ul>
<li>系统分析</li>
</ul>
<p>如果要构造一个比较复杂的应用系统，首先要进行需求分析；确定该系统应具备哪些功能并据此划分功能模块；了解需存储、处理哪些数据、数据量、调用数据时的流向等。然后根据需求分析结果选择硬件平台和软件平台。如果准备购置的平台不能完全满足需要，可能需要自己设计一些硬件部件和系统软件模块。总体设计中的这些分析工作常称为系统分析。</p>
<ul>
<li>建立数学模型和设计算法</li>
</ul>
<p>应用计算机求解、处理问题的方法，被泛称为算法。</p>
<ul>
<li>编写应用程序</li>
</ul>
<p>在建立数学模型与设计算法之后，关键的技术问题已基本解决，这时就可以选择合适的程序设计语言和开发工具，着手编写应用程序。</p>
<ul>
<li>
<p>编译为目标代码</p>
</li>
<li>
<p>由硬件执行目标程序</p>
</li>
</ul>
<p>通常先将目标程序存储在磁盘中，用户需执行时给出文件名，操作系统按文件名调出目标程序并送入主存，然后将它在主存中的首址送入程序计数器PC之中，从该地址开始依序执行目标程序。</p>
<h2 id="指令执行过程"><a class="header" href="#指令执行过程">指令执行过程</a></h2>
<ul>
<li>取指令与指令分析</li>
</ul>
<p>CPU中有一个程序计数器PC，它存放着当前指令（取指时）所在主存单元的地址码。因此每当读取指令时，就先将PC的内容送入主存储器的地址寄存器中，据此访问主存单元，从中读出指令，送入指令寄存器IR。一条指令代码可能要分别存放在几个地址连续的主存单元中，每读出一个单元的指令代码，PC内容就相应地加1，如果这条指令占n 个主存单元，那么在该指令代码都读取后，PC内容就加了n ，这时PC指示的就是下一条指令在主存的位置。</p>
<p>当指令代码读入到IR之后，相应的逻辑电路（可称为指令译码器）就自动地分析</p>
<ul>
<li>
<p>读取操作数</p>
<ul>
<li>源操作数：从主存中读出的信息具有复制性质，不影响原来的内容。这种操作数称为源操作数。</li>
<li>目的操作数：既是一个操作数的来源地，又是存放运算结果的目的地，所以它提供的操作数叫做目的操作数</li>
</ul>
</li>
<li>
<p>运算</p>
</li>
</ul>
<p>对操作数进行指定的操作</p>
<ul>
<li>后继指令地址</li>
</ul>
<p>在读取指令时PC的内容已自动修改，本例不需要转移指令地址，所以PC修改后的内容就是后继指令地址，即下一条待执行指令所在存储单元的地址。</p>
<h1 id="数字计算机的特点与性能指标"><a class="header" href="#数字计算机的特点与性能指标">数字计算机的特点与性能指标</a></h1>
<h2 id="特点"><a class="header" href="#特点">特点</a></h2>
<ul>
<li>能在程序控制下自动连续的工作：储存程序工作方式</li>
<li>运算速度快：采用高速电子线路组成硬件</li>
<li>运算精度高：采用数字代码表示信息</li>
<li>具有很强的信息存储能力：二进制易保存</li>
<li>通用性强，应用领域广：基于信息表示的数字化</li>
</ul>
<h2 id="性能指标"><a class="header" href="#性能指标">性能指标</a></h2>
<ul>
<li>基本字长：指参与一次运算的二进制数的位数。</li>
<li>数据通路宽度：数据总线一次所能并行传送的二进制数的位数</li>
<li>运算速度
<ul>
<li>CPU时钟频率与主频
计算机的操作需要分步执行，一个时钟周期完成一步操作
<blockquote>
<p>计算机中有一个振荡器，它的输出经整形后形成全机最基本的脉冲序列，其频率称为主频。主频脉冲经分频后形成时钟脉冲序列，一个时钟脉冲前沿到下一个时钟脉冲前沿就形成一个时钟周期。所以主频是时钟频率的整数倍。</p>
</blockquote>
</li>
<li>每秒平均执行指令的条数(/MIPS)</li>
<li>分别标明几种典型四则运算所需的时间</li>
</ul>
</li>
<li>主存储器容量
<blockquote>
<p>两种表示方法</p>
<ul>
<li>字节数</li>
<li>单元数（字数）X 位数</li>
</ul>
</blockquote>
</li>
<li>外存容量</li>
<li>配置的外围设备机器性能</li>
<li>系统软件配置</li>
</ul>
<h1 id="计算机的发展与应用"><a class="header" href="#计算机的发展与应用">计算机的发展与应用</a></h1>
<h2 id="发展历程"><a class="header" href="#发展历程">发展历程</a></h2>
<h2 id="提高性能的若干技术"><a class="header" href="#提高性能的若干技术">提高性能的若干技术</a></h2>
<h2 id="计算机应用举例"><a class="header" href="#计算机应用举例">计算机应用举例</a></h2>
<div style="break-before: page; page-break-before: always;"></div><p>第二章、计算机中的信息表示</p>
<p>[toc]</p>
<p>计算机内部所处理的信息必须是数字化信息，可分为两大类：</p>
<ul>
<li>数据：
<ul>
<li>数值型数据：数值型数据有确定的值并在数轴上有对应的点</li>
<li>非数值型数据：非数值型数据没有确定的值，如字符、图像等。</li>
</ul>
</li>
<li>指令：计算机产生各种控制命令的基本依据。</li>
</ul>
<h1 id="数值型数据的表示"><a class="header" href="#数值型数据的表示">数值型数据的表示</a></h1>
<h2 id="带符号数的表示"><a class="header" href="#带符号数的表示">带符号数的表示</a></h2>
<p><strong>真值与机器数</strong></p>
<p>真值：用‘+/-’号加上绝对值的表示方法<br />
机器数：数字实际存储到机器里的形式，正负号需要被“数字化”</p>
<blockquote>
<p>机器数有原码、补码、反码和移码四种表示方法</p>
</blockquote>
<p><strong>BCD码</strong></p>
<p>用四位二进制来表示一位十进制数，可表示0-16，挑出9位来表示十进制数。</p>
<ul>
<li>8421码</li>
</ul>
<p>两位8421码相加若结果大于9，则再加一个6，进行四位二进制数的进位。</p>
<ul>
<li>余3码：8421码+$(0011)_2$</li>
</ul>
<p><strong>原码</strong></p>
<p>用最高位表示符号，符号位为0表示该数为正，为1表示该数为负；有效数值部分则用二进制绝对值表示。</p>
<blockquote>
<p>小数在个位表示符号位</p>
</blockquote>
<blockquote>
<p>若采用原码作乘除运算，可取其绝对值（即尾数）直接运算，并按同号相乘除取正、异号相乘除取负的原则，单独处理符号位，因此较方便</p>
</blockquote>
<p><strong>补码</strong></p>
<ul>
<li>引入</li>
</ul>
<p>56-24=32，56+76=132=32，该加法中，100超出了表示范围，所以这两的运算结果相同，-24的补码（相对模100）是76。在有模运算中，一个负数可以用其补码代替，得到的是相同的结果</p>
<blockquote>
<p>可以把相减变成相加</p>
</blockquote>
<ul>
<li>定义</li>
</ul>
<p>计算机中数的表示及运算受字长限制，其运算都是有模运算。模在机器中是表示不出来的，若运算结果超出能表示的数值范围，则会自动舍去溢出量，只保留小于模的部分。</p>
<p><img src="assets/buma.png" alt="" /></p>
<p><strong>反码</strong></p>
<p>正数不变，负数符号位不变，其余位取反</p>
<p><strong>移码</strong></p>
<p>补码的基础上将符号位取反。只能用于表示整数</p>
<blockquote>
<p>移码相当于把真值映射到正数域(+$2^n$)。若将移码视作无符号数，则移码的大小就反映了真值的大小，这将便于两个浮点数的阶码比较。</p>
</blockquote>
<p><strong>比较与总结</strong></p>
<p><img src="assets/all.png" alt="" /></p>
<hr />
<p><img src="./assets/compare.png" alt="" /></p>
<hr />
<p>原码和补码的关系：将负数用补码表示，实际上是实现了一种从<code>[-128,127]</code>到<code>[0,255]</code>的映射</p>
<p><img src="assets/project.png" alt="" /></p>
<blockquote>
<p>为什么10000000表示-128?
$$(-128)=(-1)=(-127)=[1000 0001]_原+[11111111]_原=[11111111]_补+[10000001]_补=[10000000]_补$$</p>
</blockquote>
<h2 id="定点数与浮点数"><a class="header" href="#定点数与浮点数">定点数与浮点数</a></h2>
<p><strong>定点数</strong></p>
<p>小数点固定的机器数称为定点数，计算机中只采用纯小数或纯整数形式</p>
<blockquote>
<p>小数点只是一个约定，机器硬件中并不存在</p>
</blockquote>
<ul>
<li>定点整数</li>
</ul>
<p>定点整数的小数点位置固定在最低位之后</p>
<ul>
<li>定点小数</li>
</ul>
<p>定点小数的小数点位置固定在符号位（最高位）之后</p>
<blockquote>
<p>对于绝对值小于定点小数分辨率$2^{-n}$的数，当机器数0处理</p>
</blockquote>
<p><em>溢出</em></p>
<p>参加运算的数以及运算的结果必须在该定点数所能表示的数值范围之内。</p>
<ul>
<li>负溢出：机器数小于定点数的最小值（即绝对值最大负数）</li>
<li>正溢出：当超出最大值时，称为“正溢出”；</li>
</ul>
<p>当机器中发生溢出时，将迫使机器转入溢出处理程序或暂停，并将CPU中的状态寄存器的溢出标志位置位。</p>
<blockquote>
<p>定点数的小数点位置约定在固定位置上，因此不需设置专门的硬设备来表示它，显然小数点在机器中并不实际存在。对计算机来说，处理定点整数与处理定点小数在硬件上并无区别，至于选择哪一种定点数格式是在程序中约定的。</p>
</blockquote>
<p><em>比较</em>
<img src="assets/xiaoshu.png" alt="" /></p>
<hr />
<p><strong>浮点数</strong></p>
<p>计算机中也引入了类似于 <em>科学计数法</em> 的方法来表示实数，称为浮点数表示法，即小数点的位置可以根据需要而浮动。</p>
<p>浮点数的代码由两部分组成：阶码E和尾数M。浮点数的真值表示为：
$$N= \pm R^E·M$$</p>
<ul>
<li>R是阶码的底，机器中一般规定为2，8或16（进制），与尾数的基数（进制）相同</li>
<li>E是阶码，即指数，为带符号整数，常用移码或补码表示</li>
<li>$e_s$是阶符，表示指数的符号</li>
<li>M是尾数，通常是纯小数，常用原码或补码表示</li>
<li>$M_s$是尾数的符号位，安排在最高位，也是整个浮点数的符号位
<img src="assets/float.png" alt="" /></li>
</ul>
<blockquote>
<p>非IEEE浮点数格式化形式：规格化尾数应满足1/2&lt;=|M|&lt;1</p>
</blockquote>
<blockquote>
<p>当阶码小于机器能表示的最小阶码（即
该浮点数的值小于最小绝对值）时，称为下溢，此时一般当作机器零
处理，机器可继续运行。当阶码大于机器所能表示的最大阶码时，称
为上溢，即溢出，这时机器必须转入溢出出错中断处理。</p>
</blockquote>
<p><img src="assets/IEEE.png" alt="" /></p>
<blockquote>
<p>IEEE标准：
尾数用原码表示，隐含最高位1，实际尾数为尾数+1(即1.M)
阶码用移码表示，实际阶码需要减去偏移量$2^{|E|-1}-1$</p>
<blockquote>
<p>其中|E|为阶码的长度</p>
</blockquote>
</blockquote>
<h1 id="字符的表示"><a class="header" href="#字符的表示">字符的表示</a></h1>
<h2 id="ascii码"><a class="header" href="#ascii码">ASCII码</a></h2>
<p>一个ASCII码占一个字节，只使用底七位，最高位置0，可表示128个字符</p>
<h2 id="unicode编码"><a class="header" href="#unicode编码">Unicode编码</a></h2>
<p>Unicode最基本的思路是将每个字符和符号赋予一个永久、唯一的16位值，即码点</p>
<h2 id="汉字编码简介"><a class="header" href="#汉字编码简介">汉字编码简介</a></h2>
<ul>
<li>输入码</li>
</ul>
<p>拼音码，字形码等，所产生的输入码需要借助输入码与内部码的对照表（称为输入字典）转换成便于加工处理的内码。</p>
<ul>
<li>汉子交换码</li>
</ul>
<p>纳入整理的汉字排成一个94×94的行列矩阵，矩阵的行称为区，列称为位。用双字节编码表示。前一个字节表示区，后一个字节表示位</p>
<ul>
<li>内部码</li>
</ul>
<p>汉字内部码（简称内码）是计算机内部供存储、处理、传输用的代码。</p>
<p>todo:P107</p>
<h1 id="指令信息的表示"><a class="header" href="#指令信息的表示">指令信息的表示</a></h1>
<p>一台计算机能够直接识别并执行的程序只能是机器语言程序。</p>
<blockquote>
<p>因此，任何问题无论使用哪一种计算机语言（汇编语言或某种高级语言）来编程实现，都必须通过翻译程序转换成对应的机器语言程序后才能执行。</p>
</blockquote>
<p>机器语言程序是由机器指令序列组成的，它们是产生各种控制信息的基础。</p>
<blockquote>
<p>一条机器指令是一组有意义的二进制代码，它指示机器硬件应完成哪种基本操作。</p>
</blockquote>
<p>一台计算机的所有指令的集合构成该机的指令系统。</p>
<blockquote>
<p>指令系统既是为软件设计者提供的最低层次的程序设计语言，也是硬件设计者的最基本的设计依据。因此，指令系统是软件和硬件的接口</p>
</blockquote>
<h2 id="指令格式"><a class="header" href="#指令格式">指令格式</a></h2>
<ol>
<li>指令中的基本信息</li>
</ol>
<p>计算机是通过执行指令来处理各种数据的。为了指出所执行的操作、操作数的来源和操作结果的去向，以及下一条指令从哪里取<br />
一条指令一般应包含以下信息：</p>
<ul>
<li>操作码：表示该指令所要完成的操作</li>
<li>操作数的地址：给出操作数存放处的地址</li>
</ul>
<blockquote>
<p>如主存单元地址或寄存器地址。CPU通过该地址可以获得所需的操作数。</p>
</blockquote>
<ul>
<li>操作结果的地址：对操作数进行处理所产生的结果存放在该地址中，以便再次使用。</li>
<li>下一条指令地址</li>
</ul>
<blockquote>
<p>由于存储在主存储器中的程序（机器指令序列）是按指令执行顺序连续存放的，并且在大多数情况下程序是顺序执行的，因此可以设计一个程序计数器PC专门存放指令地址，每取出一条指令后，PC自动增值指出下一条指令地址，这样就不需在指令中直接给出下一条指令的地址。当需要改变程序执行顺序时，可由转移类指令实现。</p>
</blockquote>
<p>从上述分析可知，一条指令实际上包括两种信息，即操作码和地址码，因此指令的基本格式为：</p>
<p><img src="assets/instr.png" alt="" /></p>
<ul>
<li>操作码(Operation Code): 具体说明该指令操作的性质及功能。</li>
<li>地址码(Address Code): 描述该指令的操作对象，由它给出操作地址或直接给出操作数，并给出操作结果的存放地址。</li>
</ul>
<ol start="2">
<li>地址码结构</li>
</ol>
<p><em><strong>三地址码</strong></em></p>
<p>OP A1 A2 A3</p>
<ul>
<li>
<p>功能：(A1)OP(A2)-&gt;A3</p>
</li>
<li>
<p>说明：</p>
<ul>
<li>OP表示操作码</li>
<li>A1: 表示操作数1的地址</li>
<li>A2: 表示操作数2的地址</li>
<li>A3: 结果存放地址</li>
</ul>
</li>
</ul>
<blockquote>
<p>A1 、A2 和A3 可以是主存单元地址或寄存器地址。</p>
</blockquote>
<p><em><strong>二地址码</strong></em></p>
<p>OP A1 A2</p>
<ul>
<li>功能：(A1)OP(A2)-&gt;A1</li>
<li>说明：
<ul>
<li>A2: 提供的操作数，在运算后仍保存在原处，称它为源操作数，A2 称为源地址</li>
<li>A1: 提供的操作数，在运算后不再保留，该地址改为存放运算结果</li>
</ul>
<blockquote>
<p>因为A1 最终是存放结果的目的地，所以一开始由A1 提供的操作数称为目的操作数</p>
</blockquote>
</li>
</ul>
<p><em><strong>一地址码</strong></em></p>
<p>只有目的操作数的单操作数指令</p>
<p>OP A</p>
<ul>
<li>功能：(OP)A-&gt;A</li>
<li>说明：指令中只给出一个目的地址A，A既是操作数的地址，又是操作结果的存放地址。</li>
</ul>
<p>隐含约定目的地址的双操作数指令</p>
<p>OP A</p>
<ul>
<li>功能：(AC)OP(A)-&gt;AC</li>
<li>说明：
<ul>
<li>源操作数按指令给出的源地址A读取，</li>
<li>另一个操作数（目的操作数）隐含在CPU的累加器AC中，运算结果也将存放在AC中。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在某些微机中，双操作数指令也可采用一地址指令格式。</p>
</blockquote>
<p><em><strong>零地址码</strong></em></p>
<p>不需要操作数</p>
<p>OP</p>
<ul>
<li>说明：例如块操作指令、停机指令</li>
</ul>
<p>所需的操作数是隐含的</p>
<p>OP</p>
<ul>
<li>说明：如计算机中对堆栈操作的运算指令，所需的操作数事先约定在堆栈中，由堆栈指针SP隐含指出，操作结果仍送回堆栈中。</li>
</ul>
<blockquote>
<p>指令和操作数同样是以二进制代码形式存储的，从表面上看二者并无区别。但是，指令地址是由程序计数器PC指定的。而操作数地址则是由指令中的地址码规定的。因此二者绝不可能混淆。</p>
</blockquote>
<ol start="3">
<li>操作码结构</li>
</ol>
<p>指令中的操作码用来指示机器应执行什么性质的操作，每一条指令都有一个含义确定的操作码，不同指令的操作码用不同的二进制编码表示。</p>
<ul>
<li>固定长度地址码</li>
</ul>
<p>操作码的长度固定，且集中放在指令字的一个字段中，指令的其余部分全部用于地址码。</p>
<blockquote>
<p>操作码固定长度有利于简化硬件设计和缩短指令译码时间。</p>
</blockquote>
<ul>
<li>可变长度地址码</li>
</ul>
<p>背景：如果指令长度一定，则地址码与操作码的长度是相互制约的
解决办法：可采用扩展操作码的办法，即操作码和地址码位数不固定，操作码位数允许有几种不同的选择，对地址数少的指令允许操作码长些，对地址数多的指令则操作码就短些。</p>
<ul>
<li>复合型地址码</li>
</ul>
<p>将操作码分为几个部分，它们的组合使操作含义更丰富。</p>
<ol start="4">
<li>指令长度</li>
</ol>
<ul>
<li>变字长地址</li>
</ul>
<p>不同的指令可以有不同的字长。</p>
<blockquote>
<p>但因为主存通常按字节编址，所以指令字长多为字节的整数倍</p>
</blockquote>
<p>功能实现：将操作码放在指令字的第一字节，当CPU读出操作码后可立即判定，这是一条单操作数指令，还是一条双操作数指令，或者是零地址指令，从而知道后面还应读取几字节的指令代码。</p>
<ul>
<li>固定字长地址</li>
</ul>
<p>指令长度固定，方便机器预取后续指令，有利于指令流水线执行。</p>
<blockquote>
<p>现在RISC的微处理器通常采用固定字长指令</p>
</blockquote>
<h2 id="常用寻址方式"><a class="header" href="#常用寻址方式">常用寻址方式</a></h2>
<p>一条指令包括操作码和地址码，指令的功能就是根据操作码对地，址码提供的操作数完成某种操作。指令中以什么方式提供操作数或操作数地址，称为寻址方式。</p>
<p>指令所需要的操作数可能存放在以下几种地方：</p>
<ul>
<li>就包含在该指令之中。</li>
<li>存放在CPU的某个寄存器中。</li>
<li>存放在主存单元中。
<ul>
<li>只需对某个操作数进行处理</li>
<li>需要对一个连续的数组或表进行处理。</li>
</ul>
</li>
<li>存放在堆栈区中。</li>
<li>存放在某个I/O接口的寄存器中。</li>
</ul>
<p>两种地址：
形式地址：指令中的地址码不能直接用来访问主存
有效地址：对形式地址进行一定的计算而得到的存放操作数的主存单元地址</p>
<p>寻址方式的类型</p>
<ul>
<li>立即寻址类: 在读取指令时也立即读出操作数。</li>
</ul>
<blockquote>
<p>通常用于为程序提供常数或某种初始值，提供的是不可变的数据</p>
</blockquote>
<ul>
<li>直接寻址类: 直接给出主存的有效地址或寄存器号，以读取操作数。
<ul>
<li>堆栈寻址: 操作数存放在堆栈中，指令隐含约定由堆栈指针SP寄存器提供堆栈栈顶单元地址，进行读出或写入。</li>
</ul>
</li>
</ul>
<blockquote>
<p>有效地址是指令的一部分，不能随程序需要动态改变，因而该指令只能访问某个固定的主存单元。</p>
</blockquote>
<ul>
<li>间接寻址类: 先从某寄存器或主存单元中读取有效地址，再按这一地址访问主存以读取操作数。</li>
</ul>
<blockquote>
<p>即指向指针的指针
可将间址单元当成一个读取操作数的地址指针，它指示操作数在主存中的位置，只要修改指针（即间址单元的内容），则同一条指令就可以用来在不同时间访问不同的存储单元。</p>
</blockquote>
<ul>
<li>变址类: 指令给出的是形式地址，经过某种计算才获得有效地址，据此访问主存，读取操作数。
<ul>
<li>变址寻址: 指令的地址部分给出一个形式地址（位移量），并指定一个寄存器作为变址寄存器(Rx)；变址寄存器内容（称为变址量）与形式地址相加，得到操作数有效地址；</li>
<li>相对寻址: 以当前指令位置为基准，相对它进行位移（往前或往后）定位</li>
</ul>
<blockquote>
<p>用程序计数器PC的内容作为基准地址，指令中给出的形式地址作为位移量（可正可负），二者相加后形成操作数的有效地址。</p>
</blockquote>
</li>
</ul>
<h2 id="指令类型"><a class="header" href="#指令类型">指令类型</a></h2>
<p><img src="assets/typeInstru.png" alt="" /></p>
<blockquote>
<p>一般所有的计算机都提供表2-4中的前三类指令。指令系统对后四类指令的支持取决于具体机器</p>
</blockquote>
<ol>
<li>算数和逻辑运算类指令</li>
</ol>
<ul>
<li>运算指令: 设置加、减、比较、移位等最基本的定点。</li>
</ul>
<blockquote>
<p>性能稍强一点的机器，还设置定点乘、除运算指令。</p>
</blockquote>
<ul>
<li>逻辑运算: 逻辑与、逻辑或、逻辑非（求反）和异或4种。</li>
</ul>
<blockquote>
<p>有些机器设置有专门的位操作指令，如位测试、位清除、位设置等；而有些机器则通过逻辑运算指令实现位操作。</p>
</blockquote>
<ul>
<li>移位操作: 算术移位、逻辑移位和循环移位</li>
</ul>
<blockquote>
<p>对于未设置某种运算指令的机器，如果要实现这种运算，则可以通过程序方法来实现。也可以增设扩展运算部件。</p>
</blockquote>
<ol start="2">
<li>数据传送类指令</li>
</ol>
<p>这类指令将数据从一个地方传送到另一个地方，可用来实现寄存器与寄存器、寄存器与主存单元，以及主存单元与主存单元之间的数据传送</p>
<blockquote>
<p>而且纯数据传送具有“复制”性质，即数据从源地址传送到目的地址时，源地址中的数据保持不变。</p>
</blockquote>
<p>输入/输出（I/O）类指令完成主机与外围设备之间的信息传送有三种设置方式</p>
<ul>
<li>专用的I/O指令</li>
</ul>
<p>OP R A<br />
OP是操作码，表示它是I/O指令；<br />
R是CPU中寄存器的地址，指定与外设交换数据的寄存器；<br />
A是I/O端口的地址，其长度一般为8～16位，可以表示256～64 K个地址。</p>
<ul>
<li>用通用的数据传送指令实现I/O操作</li>
</ul>
<p>在I/O接口的端口与主存单元<em><strong>统一编址</strong></em>的机器中，因为将I/O端口与存储器单元同等对待，所以任何访问主存单元的指令均可访问I/O接口中的端口，这样就可以用传送类指令实现主机与I/O接口之间的信息传送</p>
<ul>
<li>通过I/O处理执行I/O操作</li>
</ul>
<ol start="3">
<li>程序控制类指令</li>
</ol>
<p>这类指令可以控制程序执行的顺序和选择程序的执行方向</p>
<ul>
<li>
<p>转移指令</p>
<ul>
<li>无条件转移指令: 改变指令的常规执行顺序，不受任何条件约束，直接把程序转移到该指令指向的任何地址（指令地址）开始执行。</li>
</ul>
<blockquote>
<p>这种操作使程序计数器PC的内容改变为转移地址。</p>
</blockquote>
<ul>
<li>条件转移指令; 需先测试某些条件，仅当条件满足时，才执行转移，否则只相当于一条空操作指令，不改变程序执行顺序。</li>
</ul>
<blockquote>
<p>决定转移的条件一般是指上次运算结果的某些待征。<br />
在CPU的状态寄存器中，有一组用来保存最近执行的算术逻辑运算指令、移位指令等的结果标志，它们主要包括</p>
<ul>
<li>进位标志C</li>
<li>结果为零标志Z</li>
<li>结果为负标志N</li>
<li>溢出标志V</li>
<li>奇偶标志P。</li>
</ul>
</blockquote>
</li>
<li>
<p>循环控制指令: 有了条件转移指令就可以实现循环程序设计。但有的机器为了提高指令系统的有效性，还专门设置了循环控制指令，它包括对循环控制变量的操作和脱离循环条件的控制，是一种具有复合功能的指令。</p>
</li>
<li>
<p>子程序调用和返回指令</p>
<ul>
<li>执行子程序调用指令时，首先将下一条指令地址（即断点）压入堆栈保存，然后转入所调用的子程序执行。</li>
<li>子程序执行完毕，由返回指令把调用子程序时压入的返回地址从堆栈中弹出，以返回调用程序。</li>
</ul>
</li>
<li>
<p>程序自中断指令</p>
<ul>
<li>按中断方式将处理机断点与现场保存在堆栈中（这点与一般的转子程序不同），然后转向对应的中断处理子程序入口开始执行</li>
<li>执行完毕后，通过中断返回指令返回到原程序断点继续执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于自中断指令是由软件驱动的，所以又称为软中断。</p>
</blockquote>
<ol start="4">
<li>系统类指令（特权指令）</li>
</ol>
<p>特权指令是指具有特殊权限的指令，它们只能用于操作系统或其他系统软件，一般不直接提供给用户使用。</p>
<ul>
<li>通常在单用户、单任务的计算机系统中不需要设置特权指令</li>
<li>在多用户、多任务计算机系统中，则必须设置特权指令，它主要用于系统资源的分配和管理。如检测用户的访问权限、修改虚拟存储器管理的段表、页表等。</li>
</ul>
<p>在有些多用户计算机系统中，为了统一管理各种外设，输入/输出指令也作为特权指令使用，故用户不能直接访问它们。需输入/输出时，可通过系统调用来实现。</p>
<h2 id="pentium2指令格式"><a class="header" href="#pentium2指令格式">Pentium2指令格式</a></h2>
<h2 id="spaerc指令格式"><a class="header" href="#spaerc指令格式">SPAERC指令格式</a></h2>
<div style="break-before: page; page-break-before: always;"></div><!-- ~/study_md/computer_composition/basic/4.CPU.md -->
<p>第三章 微体系结构层--CPU组成</p>
<p>[toc]</p>
<p>从计算机系统的功能组成角度看，中央处理器CPU（Central Process Unit）是计算机系统的核心部件，它主要由寄存器、算术逻 辑部件ALU、控制器及互连它们的机构组成。</p>
<p>CPU执行一条指令是由控制器产生的一组微命令（即控制信号：控制门电路的开关）序列实现的。按微命令的形成方式不同，控制器有两种组成方式</p>
<ul>
<li>组合逻辑控制方式</li>
<li>微程序控制方式</li>
</ul>
<p>在微体系结构层，我们看到的是一些寄存器和算术逻辑部件ALU 相连构成的数据通路，即中央处理器CPU的数据通路。<br />
数据通路的基本功能是传送和运算数据，如选择一个或两个寄存器的内容作为ALU的操 作数，将它们进行运算（如相加），然后将结果存回某个寄存器中。<br />
在一些机器上，这些功能</p>
<ul>
<li>是由微程序产生的控制信号控制的，相应的控制部件称为微程序控制器；</li>
<li>而有些机器是直接由硬件产生的控制信号来控制的，相应的控制部件称为组合逻辑控制器。</li>
</ul>
<h1 id="1-cpu的组成和功能"><a class="header" href="#1-cpu的组成和功能">1. CPU的组成和功能</a></h1>
<p>中央处理器CPU的主要功能是</p>
<ul>
<li>从主存储器中取出指令</li>
<li>解释指令和执行指令</li>
</ul>
<blockquote>
<p>即按指令控制计算机各部件操作，并对数据进行处理。</p>
</blockquote>
<h2 id="11-cpu的组成"><a class="header" href="#11-cpu的组成">1.1 CPU的组成</a></h2>
<p><img src="assets/cpucom.png" alt="" /></p>
<ul>
<li>控制器：产生一系列控制信号，1️⃣控制计算机中各部件完成操作</li>
<li>算数逻辑单元ALU：实现所指定的各种算数运算和逻辑运算</li>
<li>各种寄存器：存放指令、指令地址、操作数及运算结果</li>
<li>CPU内部总线：连接CPU内部各部件，为信息传送提供通路</li>
</ul>
<h3 id="111-alu部件与寄存器"><a class="header" href="#111-alu部件与寄存器">1.1.1 ALU部件与寄存器</a></h3>
<ol>
<li>ALU部件</li>
</ol>
<p><img src="assets/alucom.png" alt="" /></p>
<p>ALU的功能是实现数据的算术与逻辑运算。常用图3-2中所示的框图表示ALU。可以看出，</p>
<ul>
<li>ALU的输入有两个端口
<ul>
<li>分别接收参加运算的两个操作数</li>
<li>通常它们来自CPU的通用寄存器或ALU总线。</li>
</ul>
</li>
<li>ALU的输出取决于对其功能的控制
<ul>
<li>当控制功能选择加、减、与、或等运算功能之一时</li>
<li>其输出结果将为对应的和、差、与值、或 值等。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>寄存器</li>
</ol>
<p>CPU中的寄存器包括</p>
<ul>
<li>
<p>存放控制信息的寄存器</p>
<ul>
<li>
<p>指令寄存器IR(Instruction Register)</p>
<ul>
<li>存放当前正在执行的一条指令。</li>
<li>执行一条指令时，通常是先将其从主存储器(Memory)读出到主存数据寄存器MDR（Memory Data Register）中，然后再送往指令寄存器IR中。</li>
</ul>
</li>
<li>
<p>程序计数器PC(Program Counter)</p>
<ul>
<li>存放当前或下一条指令在主存中的地址</li>
</ul>
<blockquote>
<p>因此又称为指令计数器或指令指针IP（Instruction Pointer）。</p>
</blockquote>
</li>
<li>
<p>状态字寄存器</p>
<ul>
<li>存放当前程序的运行状态和工作方式，其内容称为程序状态字PSW（Program State Word），PSW是参与控制程序执行的重要依据。</li>
<li>PSW中一部分内容是记录上一条指令执行后的结果标志
<ul>
<li>进位标志C、溢出标志V、结果为零标志Z、结果正负标志N、奇偶标志P等。</li>
</ul>
<blockquote>
<p>每当一条指令执行完，CPU将根据运行结果自动修改这些标志。</p>
</blockquote>
</li>
<li>PSW中另一部分内容由编程设定（也称为控制标志）
<ul>
<li>跟踪标志T，用以编程设定断点；中断允许标志I，指示CPU是否允许响应 外部中断请求。</li>
<li>有的机器还设有工作方式字段，若设定为用户方式， 则禁止用户使用某些特权指令。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>及存放所处理数据的寄存器</p>
<ul>
<li>
<p>通用寄存器</p>
<ul>
<li>每个寄存器都可以提供多种用途</li>
<li>每个通用寄存器都有唯一的编号，称为寄存器地址。</li>
<li>通用寄存器可用D触发器构成。</li>
</ul>
</li>
<li>
<p>暂存器</p>
<ul>
<li>暂存从主存储器读出的数据</li>
</ul>
<blockquote>
<p>这些数据不能存放在通用寄存器中，否则会破坏其原有内容。</p>
</blockquote>
<ul>
<li>暂存器还可用于暂存来自通用寄存器组的数据。</li>
<li>暂存器没有寄存器号，因此不能直接编程访问它们。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="112-总线"><a class="header" href="#112-总线">1.1.2 总线</a></h3>
<p>总线是一组能为多个部件分时共享的公共信息传送线路，它分时接收各部件送来的信息，并发送信息到有关部件。</p>
<blockquote>
<p>会出现多个部件争用总线</p>
</blockquote>
<p>CPU内部总线用来连接CPU内的各寄存器与ALU，主要用于传送数据信息。</p>
<p>系统总线用来连接CPU、主存储器与I/O接口，它通常包括三组：</p>
<ul>
<li>数据总线: 主要传送各大部件间的数据信息，如指令代码、操作数、命令字或状态字等。</li>
<li>地址总线: 传送主存单元地址码或I/O端口地址。</li>
<li>控制总线: 传送控制、状态信息，其中有CPU发出的控制信号，也有送入CPU的状态信号。如CPU输出的对主存的读/写控制信号、外设输入到CPU的中断请求信号。</li>
</ul>
<h3 id="113-cpu内部数据通路"><a class="header" href="#113-cpu内部数据通路">1.1.3 CPU内部数据通路</a></h3>
<ol>
<li>单总线数据通路结构</li>
</ol>
<p><img src="assets/cpuoneline.png" alt="" /></p>
<ul>
<li>CPU数据通路结构只采用一组内总线，它是双向总线。</li>
<li>通用寄存器组、其他寄存器和ALU均连在这组内总线上。</li>
<li>CPU外部的系统总线通过主存数据寄存器MDR和主存地址寄存器MAR（Memory Address Register）与CPU内总线相连。</li>
<li>CPU内各寄存器间的数 据传送必须通过内总线进行，ALU通过内总线得到操作数，其运算结果 也经内总线输出。</li>
</ul>
<blockquote>
<ul>
<li>这种结构要求在ALU输入端设置两个暂存器。主要用于暂存提供给ALU的两个操作数。</li>
<li>暂存器还可作为通用寄存器之间传送的转存部件。</li>
</ul>
</blockquote>
<ol start="2">
<li>多组总线结构</li>
</ol>
<p><img src="assets/cpumutiline.png" alt="" /></p>
<ul>
<li>使几个数据传送操作能够同时进行，即实现部分并行操作。</li>
<li>每组总线连接几个部件的输入端，但只连接一个输出端</li>
</ul>
<blockquote>
<p>通用寄存器之间的数据传送必须经ALU才能完成。</p>
</blockquote>
<h2 id="12-指令执行过程"><a class="header" href="#12-指令执行过程">1.2 指令执行过程</a></h2>
<ol>
<li>指令的分段执行过程</li>
</ol>
<p>任何一条指令的执行都要经过读取指令、分析指令和执行指令三 个阶段。读取与分析指令的操作，对所有指令几乎都一样，而每条指 令的执行阶段的具体操作则有较大差别。</p>
<blockquote>
<p>如有的指令需要从存储器中 取操作数，再进行运算，运算结果还要写回存储器，因此执行阶段还 可细分。</p>
</blockquote>
<ul>
<li>
<p>取指令:</p>
<ul>
<li>根据指令计数器PC提供的地址从主存储器中读取当前指令，送到主存数据缓冲器MDR中，然后再送往CPU内的指令寄存器IR中。</li>
<li>同时改变指令计数器PC的内容，使之指向下一条指令地址或紧跟当前指令的立即数或地址码。</li>
</ul>
</li>
<li>
<p>分析指令</p>
<ul>
<li>如果采用组合逻辑控制器，则通过译码电路译出IR中指令各字段表示什么操作，并在时序系统的配合下产生该指令对应的微操作命令序列。</li>
<li>若采用微程序控制器，则可根据指令的操作码与标志位转向控制存储器取出对应的微程序，由微指令提供微操作命令序列。</li>
</ul>
</li>
<li>
<p>执行过程</p>
<ul>
<li>
<p>取操作数</p>
<ul>
<li>如果当前指令需要从主存取操作数，就需安排时间再次访问存储器。</li>
<li>如果是间址方式或是取双操作数，则访存次数更多。</li>
<li>若是变址方式，在取数之前还需安排时间进行变址计算。</li>
</ul>
</li>
<li>
<p>执行操作</p>
<ul>
<li>如果当前指令需要运算，则需考虑形成稳定运算结果的时间，为此安排专门的节拍。</li>
</ul>
<blockquote>
<p>对乘除、浮点运算则需占用更多的节拍。</p>
</blockquote>
<ul>
<li>若运算结果需送回主存单元，则应安排时间以完成对主存的写操作。</li>
</ul>
</li>
<li>
<p>形成下一条指令地址</p>
<ul>
<li>对于顺序执行的指令，下一条指令地址在取指令、取立即数、取地址码时，就已形成在PC中；</li>
<li>如果是转移类指令，则将形成的转移地址送到PC中。以后再取下一条指令、分析、 执行……，如此循环直至程序执行完毕或外来干预为止。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CPU还应该对运行过程中出现的某些异常情况或输入/输出请求进行如下处理：</p>
<ul>
<li>当机器出现某些异常情况</li>
</ul>
<blockquote>
<p>如算术运算的溢出和数据传送的奇偶错等</p>
</blockquote>
<ul>
<li>或者某些输入/输出请求</li>
</ul>
<blockquote>
<p>如磁盘上的批量数据需送存储器或程序员从键盘送入命令等</p>
</blockquote>
<p>此时由相应的部件或设备发出“中断请求信号”或“DMA请求信号”。 若CPU收到中断请求信号</p>
<ul>
<li>在执行完当前指令后，响应该中断请求，暂停当前执行的程序，转去执行中断处理程序。</li>
<li>当处理完毕后，再返回原程序断点继续执行下去。</li>
</ul>
<p>若CPU收到DMA请求信号</p>
<ul>
<li>在完成当前机器周期操作后，响应该DMA请求，暂停工作，让出总线给DMA控制器</li>
<li>由它控制完成输入/输出设备与存储器之间的数据传送操作后，CPU从暂停的机器周期开始继续执行指令。</li>
</ul>
<blockquote>
<p>注意，DMA操作不会改变CPU中任一寄存器（除DMA专用部件外）的状态，因此CPU可以从暂停处快速恢复程序的正确执行。</p>
</blockquote>
<ol start="2">
<li>指令之间的衔接过程</li>
</ol>
<ul>
<li>串行的顺序安排方式: 在一条指令执行完毕后才开始取下一条指令</li>
<li>并行的重叠处理方式: 在对当前指令执行运算操作时提前从主存取出下一条指令，而不必等当前 指令全部执行完。</li>
</ul>
<blockquote>
<p>但如果程序需要转移，预取下一条指令就要失败。 不过由于大多数情况下程序流程是顺序执行，下一条指令地址并不依赖本次执行结果，所以预取指令还是能有效地提高执行速度。</p>
</blockquote>
<h2 id="13-时序控制方式"><a class="header" href="#13-时序控制方式">1.3 时序控制方式</a></h2>
<h3 id="131-同步控制方式"><a class="header" href="#131-同步控制方式">1.3.1 同步控制方式</a></h3>
<p>指各项操作由统一的时序信号进行同步控制。这就意味着各个微操作必须在规定时间内完成，到达规定时间就自动执行后继的微操作。</p>
<p>基本特征: 将操作时间分为若干长度相同的时钟周期 （也称为节拍），要求在一个或几个时钟周期内完成各个微操作。机器的时钟频率（主频）的选择主要取决于CPU内部的操作。</p>
<blockquote>
<p>通常时钟周期应能完成CPU内部花费时间最长的微操作。显然，对于花费时间少的微操作，就会有时间上的浪费，这是同步控制方式的一个缺点。</p>
</blockquote>
<h3 id="132-同步时序控制的多级时序系统"><a class="header" href="#132-同步时序控制的多级时序系统">1.3.2 同步时序控制的多级时序系统</a></h3>
<ol>
<li>多级时序的概念</li>
</ol>
<p>在同步控制方式中，通常将时序信号划分为几级（其中包括指令 周期），称为多级时序。</p>
<p>指令周期是指从取指令、分析指令到执行完该指令所需的时间。</p>
<blockquote>
<p>在时序系统中，因其执行时间的长短可能不同，通常不为指令周期设置时间标志信号，因而也不将其作为时序的一级。</p>
</blockquote>
<p>在组合逻辑控制器中: 依靠不同的时间标志使CPU分步执行指令，其时序信号常划分为三级：</p>
<ul>
<li>机器周期</li>
<li>节拍</li>
<li>时钟脉冲
而在微程序控制器中， 一条指令对应一段微程序（微指令序列），指令的分 步执行是由执行不同的微指令来实现的，每条微指令的执行时间为一个节拍，故其时序信号划分为两级：</li>
<li>节拍</li>
<li>时钟脉冲。</li>
</ul>
<p>机器周期：</p>
<p>组合逻辑控制器中，通常将指令周期划分为几个不同的阶段，每个阶段所需的时间称为机器周期，又称为CPU工作周期或基本周期。</p>
<blockquote>
<p>例如，取指令周期、存储器读周期、存储器写周期等。在不同的机器周期中完成不同的操作。</p>
</blockquote>
<p>在时序系统中需设置一组周期状态触发器，以标志不同的机器周期，任一时刻只允许有其中的一个触发器为1，表明CPU当前处在哪个机器周期。不同的机器周期的长短可以不同。</p>
<p>节拍（时钟周期）</p>
<p>一个机器周期的操作一般需分几步完成。为此，将一个机器周期划分为若干相等的时间段，每个时间段内完成一步基本操作。这个时间段用一个电平信号宽度对应，称为节拍或时钟周期。</p>
<ul>
<li>节拍长度的确定，一般取决于CPU内部的操作需要。</li>
<li>在时序系统中设置有节拍发生器，用以产生节拍信号。</li>
</ul>
<p>时钟脉冲信号CLK</p>
<p>节拍的宽度确定后，时钟脉冲信号的频率也就随之确定了。<br />
在时序系统中，是将由时钟发生器产生时钟脉冲信号作为时序系统的基本定时信号。</p>
<p>此外，在节拍信号的配合下</p>
<ul>
<li>时钟脉冲CLK信号前沿将运算结果打入寄存器</li>
<li>其后沿实现周期切换等功能。</li>
</ul>
<ol start="2">
<li>多级时序信号之间的关系</li>
</ol>
<p><img src="assets/muticontrol.png" alt="" /></p>
<ol start="3">
<li>时序系统的组成</li>
</ol>
<p><img src="assets/timesys.png" alt="" /></p>
<ul>
<li>主振: 就是一个晶体振荡器，当机器一上电就产生频率稳定的主振信号</li>
<li>主振信号由时钟发生器经过整形分频后得到时钟脉冲信号。</li>
<li>启停控制线路控制时钟脉冲CLK的发与不发。</li>
<li>节拍发生器按先后顺序，循环地发出若干节拍信号，它通常用计数译码电路构成。</li>
</ul>
<h2 id="14-指令流水线"><a class="header" href="#14-指令流水线">1.4 指令流水线</a></h2>
<p>一条指令的执行过程也是分成几个步骤实现的。作为一个简化的方法，考虑将指令处理分成两个阶段：取指令和执行指令。在一条指令执行期间，有主存空闲的时间，这个时间能用于取下一条指令，从而使取下一条指令与当前指令的执行并行工作。</p>
<p><img src="assets/2liushui.png" alt="" /></p>
<p>重叠执行存在的问题</p>
<ul>
<li>执行时间一般要长于取时间。</li>
</ul>
<blockquote>
<p>取指阶段可能必须等待一定的时间才能更新它的缓冲器。</p>
</blockquote>
<ul>
<li>条件转移指令使得待取的下一条指令的地址是未知的。</li>
</ul>
<blockquote>
<p>简单解决：当一条件转移指令通过取指阶段到执行阶段时，新的取指阶段取存储器中此转移指令之后的指令。若转移发生，则要作废已取的指令并再取新的指令。</p>
</blockquote>
<p>为获得进一步的加速，流水线可以分成更多的阶段。</p>
<ul>
<li>取指令(FI): 读取下一个预期的指令到寄存器</li>
<li>译码指令(DI): 分析操作码和操作数寻址方式</li>
<li>计算操作数地址(CO): 计算每个源操作数的有效渎职</li>
<li>取操作数(FO): 根据操作数地址从存储器取操作数，寄存器中的数不用取</li>
<li>执行指令(EI): 完成操作码指定的操作。若有指定的目标操作数为位置，则将结果写入此位置</li>
<li>写操作数(WO): 将结果存入存储器</li>
</ul>
<p>以上分解，使各个阶段几乎用相等的时间。</p>
<p><img src="assets/mutiliushui.png" alt="" /></p>
<blockquote>
<p>此过程不适用与所有计算机</p>
</blockquote>
<p>影响流水线性能的主要因素：</p>
<ul>
<li>
<p>若各个阶段不全是相等的时间，会在各个流水阶段涉及到某种等待。</p>
</li>
<li>
<p>流水线中的相关问题</p>
<ul>
<li>数据相关：第二条指令需要第一条指令的结果
<ul>
<li>发生数据相关时，第2条指令的操作数直接从数据处理部件得到，而不是存入后再读取。</li>
<li>数据流分析技术：分析哪一条指令依赖于其他的结果或数据，依此来优化指令调度。</li>
</ul>
<blockquote>
<p>PentiumⅡ就采用该技术，根据分析结果重排指令，使指令以优化的顺序执行，与原始程序的顺序无关。</p>
</blockquote>
</li>
<li>...</li>
</ul>
</li>
<li>
<p>遇到条件转移指令时，确定转移与否的条件码往往由条件转移指令本身或由它前一条指令形成，只有当它流出流水线时，才能建立转移条件并决定下一条指令地址。</p>
<ul>
<li>猜测法：机器先选定转移分支中的一个，按它继续取指并处理
<ul>
<li>假如条件码生成后，说明猜测是正确的，那么流水线可继续进行下去，时间得到充分利用；</li>
<li>假如猜错了，那么要返回分支点，并要保证在分支点后已进行的工作不能破坏原有现场，否则将产生错误。</li>
</ul>
</li>
</ul>
<blockquote>
<p>更复杂的例子是，不只预测下面一个分支，还要提前预测多条分支，如PentiumⅡ就可以进行多重跳转分支预测。</p>
</blockquote>
</li>
<li>
<p>I/O设备有中断请求或机器有故障，要求中止当前程序的执行而转入中断处理。</p>
</li>
</ul>
<h1 id="2-算数逻辑单元alu和运算方法"><a class="header" href="#2-算数逻辑单元alu和运算方法">2. 算数逻辑单元ALU和运算方法</a></h1>
<h2 id="21-移位"><a class="header" href="#21-移位">2.1 移位</a></h2>
<ul>
<li>
<p>逻辑移位：位置变化，空出位补0</p>
<blockquote>
<p>适用于无数值大小的二进制代码</p>
</blockquote>
</li>
<li>
<p>循环移位</p>
<ul>
<li>最高位左移入最低位</li>
<li>最低位右移入最高位</li>
</ul>
<blockquote>
<p>形成闭合环路</p>
</blockquote>
</li>
<li>
<p>算数移位：带符号数的移位，移位后数的符号不变而数值发生变化。</p>
<blockquote>
<p>左移实现乘2，右移实现除2，各个数字所对应位置的权发生了变化</p>
</blockquote>
<ul>
<li>原码
<ul>
<li>左移：符号位不动，其余各位依次左移，末尾补0</li>
<li>右移：符号位不动，其他位依次右移，最高有效位补0</li>
</ul>
</li>
<li>补码
<ul>
<li>左移：各位依次左移，末尾补0
<blockquote>
<p>若符号位变化，则发生溢出</p>
</blockquote>
</li>
<li>右移：符号位不变，其余位右移，最高有效位复制符号位</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="assets/yiwei.png" alt="" /></p>
<h2 id="22-定点数加减运算"><a class="header" href="#22-定点数加减运算">2.2 定点数加减运算</a></h2>
<h3 id="221-原码加减法"><a class="header" href="#221-原码加减法">2.2.1 原码加减法</a></h3>
<p>和操作码和符号都有关</p>
<ul>
<li>+A+(-B) -&gt; +A-(+B), 结果符号与绝对值大的符号相同</li>
<li>+A-(-B) -&gt; +A+(+B), 结果与被减数符号相同␍</li>
</ul>
<h3 id="222-补码加减法"><a class="header" href="#222-补码加减法">2.2.2 补码加减法</a></h3>
<p>$$[X+Y]_补=[X]_补+[Y]_补$$
$$[X-Y]_补=[X+(-Y)]补=[X]_补+[-Y]_补$$</p>
<blockquote>
<p>已知$[Y]_补$求$[-Y]_补$
将$[Y]_补$的每一位（包括符号位）取反，最低位+1</p>
</blockquote>
<p><em><strong>补码运算规则</strong></em></p>
<ul>
<li>参与运算的操作数用补码表示</li>
<li>符号位页参与运算，所得结果也是补码表示</li>
</ul>
<h3 id="223-溢出"><a class="header" href="#223-溢出">2.2.3 溢出</a></h3>
<p>如果两个操作数都是同符号数</p>
<ul>
<li>相加 可能溢出</li>
<li>相减 不会溢出</li>
</ul>
<ol>
<li>采用单符号判断法</li>
</ol>
<ul>
<li>正+正=负 溢出（正溢）</li>
<li>负+负=正 溢出（负溢）</li>
</ul>
<ol start="2">
<li>双符号位(变形补码)判断法</li>
</ol>
<p>最高位表示正确的符号，存储时一位，计算时两位</p>
<p>变形补码表示的数：</p>
<ul>
<li>不溢出
<ul>
<li>00：结果为正数</li>
<li>11：结果为负数</li>
</ul>
</li>
<li>溢出
<ul>
<li>01：结果正溢</li>
<li>10：结果负溢</li>
</ul>
</li>
</ul>
<ol start="3">
<li>查看进位</li>
</ol>
<h2 id="23-定点数乘除运算"><a class="header" href="#23-定点数乘除运算">2.3 定点数乘除运算</a></h2>
<h3 id="231-乘法"><a class="header" href="#231-乘法">2.3.1 乘法</a></h3>
<ol>
<li>无符号整数一位乘法</li>
</ol>
<p>计算机中，n位乘法 转换为 n次“累加与移位”</p>
<blockquote>
<p>每一步只求一位乘数所对应的新部分积，并与原部分积作一次累加，然后右移一位。</p>
</blockquote>
<p>流程图</p>
<ul>
<li>3个寄存器A、B、C
<ul>
<li>B：被乘数</li>
<li>C：乘数</li>
<li>A：初值为0，然后存放部分积，最后存放乘积高位,C存乘积低位</li>
</ul>
</li>
<li>乘数每乘一位该位代码就不再使用，A和C寄存器联合右移，将$C_0$替换</li>
<li>存放逐次增加的部分积，并且使每次乘数位始终在C的最低位$C_0$。</li>
<li>乘法完成时，A与C存放的是最后乘积。</li>
</ul>
<p><img src="assets/cheng.png" alt="" /></p>
<hr />
<p>硬件原理图</p>
<ul>
<li>初始化：被乘数送入B、乘数送入C，A和Ca置0（进位触发器$C_a$保存每次累加的进位）</li>
<li>由乘数位C0产生“加B/不加”（加0）信号，用以控制被乘数B是否与上次部分积相加产生本次部分积</li>
<li>然后$C_a$、A、C一起右移一位；</li>
<li>重复n个节拍的操作后所得到的乘积存放在A和C中。</li>
<li>终止条件：乘数中的每一位都被替换(寄存器C)</li>
</ul>
<p><img src="assets/chengbasic.png" alt="" /></p>
<hr />
<p>举例</p>
<p><img src="assets/chengexample.png" alt="" /></p>
<ol start="2">
<li>有符号整数一位乘法</li>
</ol>
<ul>
<li>有符号 原码 一位乘法
<ul>
<li>符号位单独处理，做异或操作</li>
<li>乘积为|X|·|Y|</li>
</ul>
</li>
<li>有符号 补码 一位乘法
<ul>
<li>$[X·Y]_补=[X]_补*Y$</li>
</ul>
</li>
</ul>
<h3 id="232-除法"><a class="header" href="#232-除法">2.3.2 除法</a></h3>
<p>关键在于判断够减与否的问题</p>
<ul>
<li>用逻辑线路进行比较判别。硬件代价大。</li>
<li>直接做减法试探。操作不规则，控制时序复杂。
<ul>
<li>判断结果符号
<ul>
<li>为0（即正）表明够减，上商1；</li>
<li>为1（即负）表明不够减，上商0并加上之前减去的除数（即恢复余数）</li>
</ul>
</li>
<li>然后余数左移一位再做下一步。这就是恢复余数法。</li>
</ul>
</li>
</ul>
<p><em><strong>加减交替法(不恢复余数法)</strong></em></p>
<ul>
<li>余数为正，商“1”，余数左移一位，余数减除数</li>
<li>余数为负，商“0”，余数左移一位，余数加除数</li>
</ul>
<p>流程图</p>
<ul>
<li>n位除数存放在B中，2n位被除数存放在A和C中。</li>
<li>除法完成后商放在C中，余数放在A中。</li>
<li>终止条件：被除数的低n位中的值全被商替换后(寄存器C)</li>
</ul>
<p><img src="assets/chufa.png" alt="" /></p>
<blockquote>
<p>在重复n-1次操作后，如果A中的余数为负，需要恢复余数做A+B。最后的寄存器A中应获得正确的正余数。</p>
</blockquote>
<p>举例</p>
<p><img src="assets/chuexample.png" alt="" /></p>
<h2 id="24-浮点数运算"><a class="header" href="#24-浮点数运算">2.4 浮点数运算</a></h2>
<h3 id="241-加减法"><a class="header" href="#241-加减法">2.4.1 加减法</a></h3>
<p>运算规则</p>
<ul>
<li>
<p>对阶：向大阶看齐（为确保精度）</p>
<ul>
<li>求两数阶码之差E</li>
<li>阶码小的数尾数右移E位，结果阶码为大阶数阶码值
<ul>
<li>原码右移，最高位补0</li>
<li>补码右移，复制最高位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>尾数相加减</p>
</li>
<li>
<p>结果规格化</p>
<ul>
<li>原码：最高有效位为1</li>
<li>补码最高位与符号位相反（-0.5除外）</li>
</ul>
<blockquote>
<p>若结果位双符号补码</p>
<ul>
<li>规格化：00.1XXXX或11.0XXXX</li>
<li>左规：00.0XXXX或11.1XXXX(11.10..0除外)
<ul>
<li>左移，同时阶码减小，直至规格化</li>
</ul>
</li>
<li>右规：01.XXXX或10.XXXX
<ul>
<li>右移，复制符号位，同时阶码增大，直至规格化</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>舍入</p>
<ul>
<li>下舍上入法：0舍去，1则在新的尾数末尾加1</li>
<li>恒舍/恒置1，误差大</li>
</ul>
</li>
<li>
<p>判溢：根据阶码判断</p>
<ul>
<li>左规后，阶码减小 -&gt; 判断是否下溢 -&gt; "0"处理</li>
<li>右规后，阶码增大 -&gt; 判断是否上溢 -&gt; 中断处理</li>
</ul>
</li>
</ul>
<h3 id="242-乘除法"><a class="header" href="#242-乘除法">2.4.2 乘除法</a></h3>
<p><em><strong>乘法</strong></em></p>
<ul>
<li>阶码相加并判溢
<ul>
<li>补码相加：$[E_x+E_y]_补=[E_x]_补+[E_y]_补$</li>
<li>移码相加：$[E_x\pm E_y]_移 = (2^n+([E_x]_补\pm [E_y]_移)) mod 2^{n+1}$</li>
</ul>
</li>
<li>尾数相乘</li>
<li>规格化处理
<ul>
<li>顶多左规一次（原来两数已是规格化），阶码减小，可能下溢</li>
</ul>
</li>
<li>判溢</li>
</ul>
<!-- NOTE: 乘除不是重点，加减是 -->
<h2 id="25-alu"><a class="header" href="#25-alu">2.5 ALU</a></h2>
<p>ALU主要完成对二进制代码的定点算术运算和逻辑运算</p>
<ul>
<li>算数：定点加减</li>
<li>逻辑：逻辑与、或、异或、非</li>
</ul>
<blockquote>
<p>组合逻辑电路—多功能函数发生器；核心—加法器</p>
</blockquote>
<p>硬件实现</p>
<ul>
<li>如何构成一个二进制加法单元，即全加器
<blockquote>
<p>使用半加器构成</p>
</blockquote>
</li>
<li>如何构成一个n位并行加法器</li>
<li>以加法器为核心，通过输入选择逻辑扩展为具有多种算数和逻辑运算的ALU</li>
</ul>
<p>多位加法器</p>
<ul>
<li>串型加法器：由一个一位全加器组成，数据逐位串行进入加法器</li>
<li>并行加法器：由多个全加器组成，数据各位同时进入加法器进行运算
<ul>
<li>串行进位：将n个全加器串接起来，就可进行两个n位数相加，进位依赖于上一个全加器的值，延迟大</li>
<li>并行进位：复杂电路结构，让各级进位信号同时形成</li>
<li>分组的串并结合
<ul>
<li>组内并行、组间串行的进位链。</li>
</ul>
<blockquote>
<p>芯片SN74181
<img src="assets/SN74181.png" alt="" /></p>
</blockquote>
<ul>
<li>组内并行、组间并行的进位链。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-cpu模型机的组成及其数据通路"><a class="header" href="#3-cpu模型机的组成及其数据通路">3. CPU模型机的组成及其数据通路</a></h1>
<h2 id="31-基本组成"><a class="header" href="#31-基本组成">3.1 基本组成</a></h2>
<p><img src="assets/cpumodel.png" alt="" /></p>
<h3 id="311-寄存器"><a class="header" href="#311-寄存器">3.1.1 寄存器</a></h3>
<p>种类</p>
<ul>
<li>存放控制信息的寄存器</li>
<li>存放处理数据的寄存器</li>
</ul>
<p>为讨论简单，假设所有寄存器都是16位，内部结构是16个D触发 器，数据代码输入至D端，由CP端脉冲同步打入，其输出由输出门控 制。PSW的特征位则由R、S端置入，系统总线对MDR的输入也由R、S端 置入。</p>
<ol>
<li>
<p>可编程寄存器</p>
<ul>
<li>通用寄存器：R0,R1,R2,R3</li>
<li>堆栈指针: SP</li>
<li>程序状态字：PSW</li>
<li>程序计数器：PC</li>
</ul>
</li>
<li>
<p>暂存器: C,D,Z</p>
<ul>
<li>在ALU输出端设暂存器Z存放运算结果。</li>
<li>暂存器D还可暂存从主存储器读出的数据，并设有左移和右移功能。</li>
<li>暂存器C主要用于暂存从主存读出的源操作数。</li>
</ul>
</li>
<li>
<p>指令寄存器IR</p>
<ul>
<li>存放当前正在执行的一条指令。</li>
<li>当执行一条指令时，应先将指令从主存中读出到IR中。</li>
<li>IR的内容（指令）是控制器产生控制信号的主要逻辑依据。</li>
</ul>
</li>
<li>
<p>与主存接口的寄存器MAR、MDR</p>
<ul>
<li>地址寄存器MAR用于存放CPU访问主存或I/O接口的地址。MAR连接
地址总线的输出门是三态门
<ul>
<li>当微命令EMAR为高电平时，MAR输出地址送往地址总线；</li>
<li>当EMAR为低电平时，MAR输出呈高阻态，与地址总线断开。</li>
</ul>
</li>
<li>数据寄存器MDR用于存放CPU与主存或I/O接口之间传送的数据。
<ul>
<li>CPU的输出数据必须先打入MDR，再从MDR输出到数据总线上。</li>
<li>对于输入 CPU的数据，则从数据总线输入数据到MDR，然后由MDR送往CPU中的其他部件。</li>
<li>MDR与数据总线间为双向连接，其输出级也采用三态门，可与数据总线断开。</li>
<li>CPU对主存的控制信号有两个
<ul>
<li>读信号RD控制对主存的读操作；</li>
<li>写信号WR控制对主存的写操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="312-运算部件"><a class="header" href="#312-运算部件">3.1.2 运算部件</a></h3>
<p>ALU的输入A来自暂存器D，输入B来自ALU总线，运算结果输出到Z。<br />
控制ALU运算的控制信号有：ADD、SUB、AND、OR、XOR、COM、NEG、A+1、A−1、B+1、B−1，它们分别控制ALU完成加、减、与、或、异或、求负、求反等运算。</p>
<h3 id="313-总线与数据通路结构"><a class="header" href="#313-总线与数据通路结构">3.1.3 总线与数据通路结构</a></h3>
<ol>
<li>ALU总线</li>
</ol>
<p>CPU内部采用单总线结构</p>
<ul>
<li>即设置一组ALU总线（也称为CPU内总线），由16根双向数据传送线组成</li>
<li>ALU和所有寄存器通过这组公共总线连接起来。</li>
<li>在单总线结构中，CPU的任何两个部件间的数据传送都必须通过这组总线</li>
</ul>
<p>挂接在ALU总线上的寄存器几乎都设有三态输出门和打入脉冲。</p>
<ul>
<li>三态输出门打开，便将寄存器中的信息代码送到ALU总线上去，但每次只允许 一个部件向ALU总线发送信息代码；</li>
<li>接收信息的寄存器可以有多个，由打入脉冲将ALU总线上的信息代码打入其中。</li>
</ul>
<ol start="2">
<li>系统总线</li>
</ol>
<p>模型机的CPU、存储器及I/O设备分别挂接在一组系统总线上。</p>
<p>系统总线包括：16根地址总线、16根数据总线，以及控制总线。
为简单起见，模型机采用同步控制方式。</p>
<ul>
<li>CPU通过MAR向地址总线提供访问主存单元或I/O接口的地址，由控制信号EMAR决定是否发送地址。I/O接口（如DMA控制器）也可以向地址总线发送访存地址。</li>
<li>CPU通过MDR向数据总线发送或接收数据，以完成与主存单元或I/O接口之间的数据传送，由控制信号RD、WR决定传送方向。主存M和I/O设备之间也可以通过数据总线传送数据。</li>
<li>CPU通过控制总线向主存或I/O设备发出有关控制信号，或接收控制信号。有时，I/O设备也可以向控制总线发出控制信号。</li>
</ul>
<h3 id="314-控制器及微命令的基本形式"><a class="header" href="#314-控制器及微命令的基本形式">3.1.4 控制器及微命令的基本形式</a></h3>
<ol>
<li>微命令的基本形式</li>
</ol>
<p>微操作命令是最基本的控制信号，通常是指直接作用于部件或控制门电路的控制信号，简称微命令。</p>
<blockquote>
<p>例如，打开或关闭某个三态门的电位信号，或是对寄存器进行同步打入、置位、复位的脉冲。</p>
</blockquote>
<p>微命令的两种形式</p>
<p>电位型微命令：用信号电平的高与低分别表示不同的信息</p>
<blockquote>
<p>通常定义高电平（如+5V）表示1，低电平（如0V）表示0。</p>
</blockquote>
<ul>
<li>各寄存器输出到ALU总线的控制信号有：$R0_{OUT} 、R1_{OUT} 、PC_{OUT} 、SP_{OUT} 、MDR_{OUT}$等。
• ALU运算控制信号有：ADD、SUB、AND、OR、XOR等。
• 暂存器D的左移/右移控制信号有：SAL、SAR。
• 程序计数器PC的计数控制信号有：PC+1。
• MAR和MDR输出到系统总线的控制信号有：EMAR、EMDR。
• 寄存器置入控制信号有：SMDR、SPSW。
• 主存的读/写信号有：RD、WR。</li>
</ul>
<p>脉冲型微命令：利用脉冲边沿（即正向或负向跳变）来表示某一时刻，起定时作用，或识别脉冲的有无。</p>
<ul>
<li>各寄存器均采用同步打入脉冲将ALU总线上的数据打入其中。</li>
<li>脉冲型微命令有：CP_{R0} 、CP_{R1} 、CP_{PC} 、CP_{IR} 、CP_{SP} 、CP_{MAR} 、CP_{MDR} 等。</li>
</ul>
<ol start="2">
<li>控制器</li>
</ol>
<p>功能：根据指令产生控制信号序列以控制相应部件分步完成指定的操作。</p>
<ul>
<li>向CPU内部发送控制信号，控制寄存器之间的数据传送，使ALU完成指定功能以及其他内部操作；</li>
<li>它也向CPU外部发出控制信号，以控制CPU与存储器或I/O设备之间传送数据。</li>
</ul>
<p>传统控制器的主要部件包括：</p>
<ul>
<li>指令寄存器IR</li>
<li>指令译码器</li>
<li>程序计数器PC</li>
<li>状态字寄存器PSW</li>
<li>时序系统</li>
<li>微操作信号发生器
在微型计算机中，将控制器和运算器（即CPU）集成在一块芯片上，因此现在
是将CPU作为一个整体来讨论。</li>
</ul>
<p>如图3-20所示，微操作信号发生器的输入由</p>
<ul>
<li>IR中的指令经译码后的输出</li>
<li>PSW的状态位</li>
<li>时序信号</li>
<li>外部的控制信号（如中断信号）组成。
微操作信号发生器则依据它的输入产生指令执行时所需要的微操作信号（即控制信号）。</li>
</ul>
<h2 id="32-数据传送"><a class="header" href="#32-数据传送">3.2 数据传送</a></h2>
<ol>
<li>寄存器之间的数据传送</li>
</ol>
<p>在模型机中，寄存器之间可直接通过ALU总线传送数据，具体传送由输出门和打入脉冲控制。</p>
<p>如图3-20所示，</p>
<ul>
<li>某寄存器$Ri$ 的输出和打入分别由$Ri_{OUT}$ 和$CP_{R_i}$控制。</li>
<li>$Ri$ 的输出门控制信号$Ri_OUT$ 为高电平时，输出门打开，Ri 的内容就送到了ALU总线上；</li>
<li>$Ri_OUT$为低电平时，输出门关闭，$Ri$的输出呈高阻态，与ALU总线隔离。</li>
<li>打入脉冲$CP_{R_i}$ 有效时，将ALU总线上的数据打入Ri 。</li>
</ul>
<p>例如，把寄存器R1的内容传送到寄存器R3，即实现传送操作R1→R3所需控制信号为$R1_{OUT} 、CP_{R3}$ 。</p>
<ol start="2">
<li>主存数据到CPU</li>
</ol>
<p>如图3-20所示，要从主存中读一个数据到CPU</p>
<ul>
<li>CPU首先要把所取数据的地址送到MAR</li>
<li>然后将MAR中的地址输出到地址总线上，同时发读命令到主存；</li>
<li>主存完成读操作后将读出的16位数据送到数据总线上，再将数据线上的信息置入MDR。</li>
</ul>
<p>例如要从存储器中取指令到指令寄存器IR，通过以下操作序列即可实现：</p>
<ul>
<li>PC→MAR ；PC中的指令地址送存储器地址寄存器
<ul>
<li>实现PC→MAR传送操作所需的控制信号为$PC_{OUT} 、CP_{MAR}$ 。</li>
</ul>
</li>
<li>M→MDR→IR ；从存储器中读指令到IR
<ul>
<li>实现读操作M→MDR的控制信号为EMAR、RD、SMDR；</li>
<li>实现MDR→IR的控制信号为$MDR_{OUT} 、CP_{IR}$ 。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>CPU数据到主存</li>
</ol>
<p>由图3-20可见，CPU数据要写入主存</p>
<ul>
<li>首先要将寄存器中的数据装入MDR，还要将写入主存单元的地址送MAR，然后发写命令；</li>
<li>主存将按MAR中的地址把MDR的内容写入对应单元中。</li>
</ul>
<p>例如在R2中存放需写入主存的数据，存储单元地址在R1中，则写一个数据到存储器可通过以下操作序列实现：</p>
<ul>
<li>R1→MAR ；地址送MAR
<ul>
<li>实现R1→MAR操作的控制信号为$R1_{OUT} 、CP_{MAR}$ 。</li>
</ul>
</li>
<li>R2→MDR ；数据送MDR
<ul>
<li>实现R2→MDR的控制信号为$R2_{OUT} 、CP_{MDR}$。</li>
</ul>
</li>
<li>MDR→M ；数据写入主存
<ul>
<li>实现写操作MDR→M的控制信号为EMAR、EMDR、WR。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>执行算数或逻辑操作</li>
</ol>
<p>执行算术或逻辑操作时，由于ALU本身是没有内部存储功能的组合电路，因此，如要执行加法运算，被相加的两个数必须在ALU的两个输入端同时有效，图3-20中的暂存器D即用于该目的。</p>
<ul>
<li>先将一个操作数经ALU总线送入暂存器D保存起来，D的内容在ALU的输入端A始终有效</li>
<li>再将另一个操作数经总线直接送到ALU的输入端B；这样两个操作数都
送入了ALU</li>
<li>运算结果暂存在暂存器Z中</li>
</ul>
<p>若要执行“把寄存器R1和R2的内容相加，结果送到R3”这个功能，需要分成三步执行：</p>
<ul>
<li>R1→D ；把R1的内容先送到寄存器D
<ul>
<li>实现R1→D操作的控制信号为$R1_{OUT} 、CP_D$ 。</li>
</ul>
</li>
<li>D+ R2→Z ；R2内容送到ALU的B端与D内容通过ALU相加，结果送Z
<ul>
<li>实现D + R2→Z的控制信号为$R2_{OUT} 、ADD、CP_Z$ 。</li>
</ul>
</li>
<li>Z→R3 ；将相加结果送入R3中
<ul>
<li>实现Z→R3的控制信号为$Z_{OUT} 、CP_{R3}$。</li>
</ul>
</li>
</ul>
<h1 id="4组合逻辑控制器原理"><a class="header" href="#4组合逻辑控制器原理">4、组合逻辑控制器原理</a></h1>
<p>按产生控制信号的方式不同，控制器可分为</p>
<ul>
<li>组合逻辑控制器</li>
<li>微程序控制器两种基本类型。</li>
</ul>
<p>组合逻辑控制器是指产生控制信号（即微命令）的部件，是用组合逻辑线路来实现的。</p>
<p>在模型机中有几十个微命令，则每个微命令都需要一组逻辑门电路，根据相应的逻辑条件（如指令的操作码、寻址方式、时序信号等）产生该微命令。控制器一旦制造完成后，这些逻辑电路之间的连接关系就固定了，不易改动，所以组合逻辑控制器又称为硬连逻辑控制器。</p>
<h2 id="41-模型机的指令系统"><a class="header" href="#41-模型机的指令系统">4.1 模型机的指令系统</a></h2>
<p>本节先介绍模型机的指令系统，然后假设模型机采用的是组合逻辑控制器，讨论其时序系统、指令执行流程及微命令的产生与综合。</p>
<h3 id="411-指令格式"><a class="header" href="#411-指令格式">4.1.1 指令格式</a></h3>
<p><img src="assets/model_instrution.png" alt="" /></p>
<p>对于转移指令字段，第0-3位中有一位为1，表示转移条件</p>
<ul>
<li>进位--<code>C</code></li>
<li>溢出--<code>V</code></li>
<li>结果为零--<code>Z</code></li>
<li>结果为负--<code>N</code><br />
第五位表明转移方式，若为0，表示相关标志位为0则转移。<br />
若第0-5位全为0，则表无条件转移</li>
</ul>
<p>可编程寄存器有七个，编号如下</p>
<ul>
<li>通用寄存器R0-R3,000-011</li>
<li>堆栈指针SP,100</li>
<li>程序状态字PSQ,101</li>
<li>程序计数器PC,111</li>
</ul>
<h3 id="412-寻址方式"><a class="header" href="#412-寻址方式">4.1.2 寻址方式</a></h3>
<ul>
<li>立即数寻址，操作数紧跟着指令，即在指令代码之中。</li>
<li>操作数在寄存器中，即寄存器寻址方式。</li>
<li>操作数在主存中，相应的寻址方式有：
<ul>
<li>直接寻址方式，地址紧跟指令操作码与寻址字段后。</li>
<li>寄存器间址方式，地址在寄存器中。</li>
<li>自增型寄存器间址方式。</li>
<li>自减型寄存器间址方式。</li>
<li>变址方式。</li>
</ul>
</li>
</ul>
<p><img src="assets/model_find_pos.png" alt="" /></p>
<ul>
<li>0型</li>
</ul>
<p>寄存器寻址方式，寻址字段代码000，汇编符号<code>R</code>，定义为：操作数在指定的寄存器中</p>
<ul>
<li>1型</li>
</ul>
<p>寄存器间址方式，寻址字段代码001，汇编符号<code>(R)</code>，定义为：操作数地址在指定寄存器中（即从指定寄存器中得到操作数地址，再按次地址访问主存，从主存中读取操作数）</p>
<ul>
<li>2型</li>
</ul>
<p>自减型寄存器寻址方式，寻址字段代码010，汇编符号<code>-(R)</code>，定义为：将指定寄存器内容减去1后为操作数地址，再按地址防伪主存，从主存中获取操作数</p>
<ul>
<li>3型</li>
</ul>
<p>立即/自增型寄存器寻址方式，寻址代码011，汇编代码<code>(R)+</code>，定义为：操作数地址在指定寄存器中，地址使用后将寄存器内容加1，</p>
<ul>
<li>4型</li>
</ul>
<p>直接寻址方式，寻址字段代码100，汇编符号<code>DI</code>，定义为：操作数地址紧跟指令操作码与寻址字段后的单元中，然后PC+1，将修改后的PC内容作为地址，据此访问紧跟当前指令操作码与寻址字段后的存储单元，从中取得操作数地址（称为绝对地址），据此再度访存，读得操作数，然后PC+1</p>
<ul>
<li>5型</li>
</ul>
<p>变址方式，寻址字段101，汇编符号<code>X(R)</code>，其中X是变址的一种习惯标注符，定义为：指定变址寄存器内容与紧跟指令操作码与寻址字段后的位移量相加，其结果为操作数地址。</p>
<h3 id="413-操作类型"><a class="header" href="#413-操作类型">4.1.3 操作类型</a></h3>
<p>操作码共4位，现设14中指令，余下两种操作码可共扩展</p>
<ol>
<li>传送指令</li>
</ol>
<ul>
<li><code>MOV</code>: 传送，操作码0000</li>
</ul>
<ol start="2">
<li>双操作数算数逻辑指令</li>
</ol>
<ul>
<li><code>ADD</code>: 加，操作码0001（带进位）</li>
<li><code>SUB</code>: 减，操作码0010（带进位）</li>
<li><code>AND</code>: logic and,operator 0011</li>
<li><code>OR</code>: logic or,operator 0100</li>
<li><code>EOR</code>: 逻辑异或,操作码0101</li>
</ul>
<ol start="3">
<li>singnal operator instruction</li>
</ol>
<ul>
<li><code>COM</code>: 求反,operator 0110</li>
<li><code>NEG</code>: 求补，operator 0111</li>
<li><code>INC</code>: add 1,operator 1000</li>
<li><code>DEC</code>: substruct 1,operator 1001</li>
<li><code>SL</code>: move left,operator 1010</li>
<li><code>SR</code>: move right,operator 1011</li>
</ul>
<ol start="4">
<li>program control instruction</li>
</ol>
<ul>
<li><code>JMP</code>: 转移指令,operator 1100</li>
</ul>
<p><img src="assets/jmp.png" alt="" /></p>
<p>如表3-5所示，JMP指令第3～0位选择一位为1，表明以PSW中的某一特征作为转移条件。</p>
<p>JMP指令第5位（IR5）决定转移条件为0转，还是为1转。若JMP指令第5～0位全为0，则表示无条件转移。</p>
<ul>
<li><code>RST</code>: 返回指令，operator 1100</li>
</ul>
<p>RST指令与JMP指令的操作码相同，可视为一条指令。RST指令只能采用自增型寄存器间址表明转移地址，并指定寄存器为SP，即寻址方式为（SP）+。它从堆栈中取出返回地址，然后修改堆栈指针SP+1。实际上，“JMP（SP）+”指令就是一条RST指令。</p>
<ul>
<li><code>JSR</code>: 转子指令，operator 1101</li>
</ul>
<p>执行JSR指令时，先将返回地址压栈保存，然后按寻址方式找到转移地址（即子程序入口地址），将它送入PC中。</p>
<h2 id="42-模型机的时序系统"><a class="header" href="#42-模型机的时序系统">4.2 模型机的时序系统</a></h2>
<p>组合逻辑控制器依靠不同的时间标志，使CPU分步工作。</p>
<p>模型机采用前述的三级时序系统，即将时序信号分为工作周期、节拍（时钟周期）和工作脉冲。</p>
<h3 id="421-工作周期划分"><a class="header" href="#421-工作周期划分">4.2.1 工作周期划分</a></h3>
<p>模型机设置了6种工作周期，分别用6个周期状态触发器来表示它们的状态。任一时刻只允许一个触发器为1，表明CPU现在所处的工作周期状态，并为该阶段的工作提供时间标志与依据。</p>
<ol>
<li>取指令周期<code>FT</code></li>
</ol>
<p>完成取指所需的操作。</p>
<ol start="2">
<li>源周期<code>ST</code></li>
</ol>
<p>如果需要从主存中读取源操作数，则进入ST。在ST中将依据指令寄存器IR的源地址字段信息进行操作，形成源地址，读取源操作数。</p>
<ol start="3">
<li>目的周期<code>DT</code></li>
</ol>
<p>如果需要从主存中读取目的地址或目的操作数，则进入DT。在DT中将依据指令寄存器IR的目的地址段信息进行操作。</p>
<ol start="4">
<li>执行周期<code>ET</code></li>
</ol>
<p>取得操作数后，则进入ET，将依据IR中操作码执行相应操作，如传送、算术运算、逻辑运算、获得转移地址等。</p>
<ol start="5">
<li>中断响应周期<code>IT</code></li>
</ol>
<p>CPU在响应中断请求之后，进入中断响应周期IT。</p>
<ul>
<li>在IT中将直接依靠硬件进行关中断、保存断点、转处理程序入口等操作。</li>
<li>IT结束后，进入取指周期FT，开始执行中断处理程序。</li>
</ul>
<blockquote>
<p>中断方式是指这样一种工作方式：由于某些异常情况或特殊请求，引起CPU暂停执行当前程序，转去执行中断处理子程序，以处理这些情况或请求，等处理完后又返回原程序断点继续执行，这一过程就称为中断。</p>
</blockquote>
<ol start="6">
<li>DMA传送周期<code>DMAT</code></li>
</ol>
<p>CPU响应DMA请求之后，进入DMAT。</p>
<p>在DMAT中</p>
<ul>
<li>CPU交出系统总线的控制权，即MAR、MDR与系统总线脱钩（呈高阻态）</li>
<li>改由DMA控制器控制系统总线，实现主存与外围设备间的数据直接传送</li>
<li>因此对CPU来说，DMAT是一个空操作周期。</li>
</ul>
<blockquote>
<p>DMA（Direct Memory Access）即直接访存方式，它的基本思想是在主存储器和I/O设备 之间建立直接的数据传送通路，由专门的DMA控制器控制主存和I/O设备间的数据传送，在传送时不需CPU干预。由于传送过程完全由硬件实现，所花费的时间短，因此能满足高速数据传送的需要。</p>
</blockquote>
<p><img src="assets/cpu_period.png" alt="" /></p>
<p>为此，在每一周期结束前，都要判断下一个周期状态将是什么，并为此准备好进入该周期的条件，如发出电位信号1→ST等。到本周期结束的时刻，再实现周期状态的定时切换。</p>
<p>由于DMA周期要实现的是高速数据直传，所以DMA请求的优先级高于中断请求。</p>
<blockquote>
<p>注意，实际的计算机大多允许在一个系统总线周期结束时插入DMAT。本模型机为了简化其控制逻辑，限制在一条指令结束时才判别与响应DMA请求。</p>
</blockquote>
<h3 id="422-节拍时钟周期"><a class="header" href="#422-节拍时钟周期">4.2.2 节拍（时钟周期）</a></h3>
<p>每个工作周期的操作一般需要分成若干步完成，为此将工作周期划分成若干节拍。</p>
<p>节拍宽度为最长微操作所需的时间，即访问主存操作所需的时间</p>
<blockquote>
<p>注意，在实际机器中节拍长度短于访存周期</p>
</blockquote>
<p>节拍发生器由计数器T与节拍译码器组成。当工作周期开始时，T=0，若本工作周期还需延长，则发命令T+1，计数器将继续计数，表示进入一个新的节拍；若本工作周期应当结束，则发命令T=0，计数器T复位，从T=0开始一个新的计数循环，进入新的工作周期。</p>
<h3 id="423-工作脉冲"><a class="header" href="#423-工作脉冲">4.2.3 工作脉冲</a></h3>
<p>在节拍中执行的有些操作需要同步定时脉冲，如将稳定的运算结果打入寄存器，又如周 期状态切换等。为此，模型机在每个节拍的末尾发一个工作脉冲P，作为各种同步脉冲的来源</p>
<ul>
<li>工作脉冲P的前沿作为打入寄存器的定时信号，它标志着一次数据通路操作的完成。</li>
<li>P的后沿作为节拍与工作周期切换的定时信号，在此刻对节拍计数器T计数、打入新的工作周期状态。</li>
</ul>
<h2 id="43-指令流程"><a class="header" href="#43-指令流程">4.3 指令流程</a></h2>
<p>分析指令流程是为了在寄存器这一层次分析指令序列的读取与执行过程，也就是讨论CPU的工作机制</p>
<p>设计和确定指令执行的具体流程通常有两种方法</p>
<ul>
<li>工作周期为线索: 以工作周期为主轴来制定各类指令的操作流程</li>
<li>指令为线索: 以指令类型为主轴来制定流程</li>
</ul>
<h3 id="431-取指令周期ft"><a class="header" href="#431-取指令周期ft">4.3.1 取指令周期FT</a></h3>
<p>FT中的操作是各类指令流程都需首先经历的，与指令类型无关，通常称为公共操作。</p>
<h4 id="进入ft的条件"><a class="header" href="#进入ft的条件">进入FT的条件</a></h4>
<p>取指周期状态触发器FT为1</p>
<p><img src="assets/ft_trrigle.png" alt="" /></p>
<ol>
<li>初始化置入FT</li>
</ol>
<p>当机器加电或按“复位”键后，将产生一个“复位信号”预置全机的初始状态。</p>
<ul>
<li>首先将某值（如全0）置入程序计数器PC中，此即为开机后执行的第一条指令的地址，同时将取指周期状态触发器FT置1。</li>
<li>当复位信号结束后，开放时钟，开始执行取指操作，进入操作系统程序运行状态。由于在复位信号作用时，时钟被封锁，因此采取S端置入方式。</li>
</ul>
<ol start="2">
<li>程序运行过程中，同步打入FT</li>
</ol>
<p>在正常的程序运行过程中，时钟已开放，可用同步方式实现周期状态转换。</p>
<ul>
<li>若要进入FT，则事先在状态触发器D端准备好条件1→FT，然后产生同步脉冲$CP_FT$ ，由$CP_FT$的上升沿（即脉冲P的后沿），将1打入FT。</li>
<li>若要结束FT状态，则让D端电平为0，并产生$CP_FT$将0打入FT，使FT变为0，表示取指周期结束。</li>
</ul>
<p>有三种情况可采用同步方式进入新的取指周期：</p>
<ul>
<li>当一条指令将执行完毕时，即在执行周期ET中，如果不响应DMA请求与中断请求，程序正常执行，接着就转入新的FT，开始执行下一条指令。</li>
<li>在中断周期IT这一过渡阶段操作结束后，就应转入中断处理程序，即进入FT。</li>
<li>在DMA周期完成一次DMA传送后，如果没有新的DMA请求，也没有中断请求，则恢复执行被暂停的程序，也应进入FT。</li>
</ul>
<p>因此，产生控制信号1→FT的逻辑条件如下：
$$1 \to FT = ET(\overline{1 \to IT} \cdot \overline{1 \to DMAT}) + IT + DMAT(\overline{1 \to IT} \cdot \overline{1 \to DMAT})$$</p>
<blockquote>
<p>整个表达式是一个布尔逻辑表达式，所有变量都只有两种状态（0或1），用来表示不同条件的真或假，以便触发控制信号$1 \to FT$。</p>
</blockquote>
<h4 id="取指流程"><a class="header" href="#取指流程">取指流程</a></h4>
<p><img src="assets/get_instruction.png" alt="" /></p>
<ul>
<li>在$FT_0$中先将指令地址由PC送入MAR；</li>
<li>在$FT_1$中从主存读出指令代码到MDR再送到指令寄存器IR中，由于PC本身具有计数功能，所以可同时修改程序计数器PC的内容，让PC+1，则修改后的PC指向紧跟当前指令操作码与寻址字段后的下一主存单元。</li>
</ul>
<h4 id="微操作时间表"><a class="header" href="#微操作时间表">微操作时间表</a></h4>
<p><img src="assets/smalloperationtable.png" alt="" /></p>
<p>表3-6以操作时间表形式，进一步给出了为实现取指流程的每步基本操作与转入下一步操作所需的微命令（包括控制电位和脉冲）。</p>
<ul>
<li>左栏给出节拍序号，如T0 、T1 、…，也可将工作周期状态与节拍序号综合标注，如FT0 形式。</li>
<li>中栏给出在本拍中应发的电平型微命令，这些命令同时发出，维持一个节拍宽度。
<ul>
<li>有些命令只在某些逻辑条件下才发出，则进一步在括号中标注其补充逻辑条件</li>
<li>如果表中空间不便写全，或是在拟定本表时还不能给出全部逻辑条件，要等到全部指令流程与操作时间表都列完后才能全部确定，则可在括号中先注明逻辑条件，以后再补充相应逻辑式</li>
</ul>
</li>
<li>右栏给出本拍中应发的脉冲型微命令，并示意性地表明脉冲是在时钟周期的末尾发出的，由工作脉冲P或其反相脉冲P定时。</li>
</ul>
<hr />
<p>让我们分析FT操作时间表中各个微命令的含义。如表3-6所示，</p>
<ul>
<li>在$FT_0$
<ul>
<li>要完成PC→MAR操作，则应发控制信号$PC_{OUT}$、$CP_{MAR}$ ，由它们控制将PC的内容送ALU总线并打入MAR中。</li>
<li>控制信号T+1、CPT 控制转入下一个节拍FT1 。</li>
</ul>
</li>
<li>在FT1中
<ul>
<li>要完成M→MDR→IR操作，控制信号EMAR、RD、SMDR控制从主存中读一个字（指令）置入MDR，由$MDR_{OUT}$ 、$CP_{IR}$将MDR内容打入IR中。</li>
<li>要完成PC+1→PC操作，控制信号PC+1、$CP_{PC}$ 将PC内容加1计数。</li>
</ul>
</li>
</ul>
<p>在取指周期结束时，需根据已取到IR中的指令操作码与寻址方式，判断应转入哪个周期， 因此1→ST、1→DT、1→ET这三个电位信号中只能有一个为1，其逻辑条件主要涉及操作码与寻址方式。</p>
<p>当周期状态发生转换时，FT触发器的D端1→FT为0，$CP_{FT}$将其打入0。<br />
在周期状态结束时，T+1为0，由CPT使T计数器置0。</p>
<h3 id="432-move指令"><a class="header" href="#432-move指令">4.3.2 MOVE指令</a></h3>
<p>如果当前指令是MOV指令，CPU将执行MOV指令流程，如图3-26所示。</p>
<p><img src="assets/move_instruction.png" alt="" /></p>
<p>MOV指令流程图包含了各种寻址方式的组合</p>
<ul>
<li>流程分支的逻辑依据就是指令的寻址方式字段代码，图中标注为相应的汇编符号。</li>
<li>每个工作周期结束时要判断后继工作周期将是什么。</li>
</ul>
<ol>
<li>FT</li>
</ol>
<p>取指令周期FT</p>
<ol start="2">
<li>ST</li>
</ol>
<p>在FT中根据寻址方式作出判别，决定在ST中的分支。</p>
<ul>
<li>R型: 源操作数在指定寄存器中
<ul>
<li>第1拍ST0将寄存器Ri内容送入C中。</li>
</ul>
</li>
<li>(R)型
<ul>
<li>第1拍ST0 完成从指定寄存器Ri 中取得源地址</li>
<li>第2拍ST1 访存读取操作数，经MDR送入C中暂存。</li>
</ul>
</li>
<li>−(R)型
<ul>
<li>第1拍先修改地址指针内容，即指定寄存器Ri 内容减1，所得结果打入Z。</li>
<li>第2拍将Z同时送入Ri 与MAR，形成源地址</li>
<li>第3拍访存读取操作数，送入C暂存。</li>
</ul>
</li>
<li>I/(R)+型
<ul>
<li>第1拍取得地址</li>
<li>第2拍读取操作数</li>
<li>第3、4拍修改地址指针，即Ri 加1。</li>
</ul>
</li>
<li>DI型 操作数地址紧跟着指令。取指后PC已加1，指向紧跟当前指令的下一单元
<ul>
<li>ST0 将PC内容送MAR</li>
<li>ST1 据此访存，从中取得操作数地址，并同时修改PC。</li>
<li>ST2 读取操作数。</li>
</ul>
</li>
<li>X(R)型 需两次访存，第1次在PC指点下读取位移量，第2次读取操作数。
<ul>
<li>ST0 中将PC内容送MAR。</li>
<li>ST1 读取位移量，暂存于D，并修改PC指针。</li>
<li>ST2 实现变址计算，即变址寄存器Ri中的变址量与D中的位移量相加，获得操作数地址。</li>
<li>ST3 操作数地址送MAR。</li>
<li>ST4 读取操作数。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>DT</li>
</ol>
<p>与ST相似，但对于MOV指令，DT直到取得目的地址为止。</p>
<blockquote>
<p>$DR$表示目的地址采用寄存器寻址方式，若不是寄存器寻址方式，则用$\overline{DR}$表示。</p>
</blockquote>
<ol start="4">
<li>ET</li>
</ol>
<p>执行周期的基本任务是实现操作码要求的传送操作，这就需要考虑在进入ET时，操作数是送往寄存器还是送往主存，可以根据DR状态区分。因此，按DR形成两种分支，如图3-26所示。</p>
<p>指令流程图只反映了正常执行程序的情况，实际上在最后一拍还需判别是否响应DMA请求与中断请求，即是否发1→DMAT或1→IT。如果都没有，则建立1→FT，转入下一条指令。</p>
<h3 id="433-双操作数指令"><a class="header" href="#433-双操作数指令">4.3.3 双操作数指令</a></h3>
<p>双操作数指令共有5条：加ADD、减SUB、与AND、或OR、异或EOR，其指令流程如图3-27所示。</p>
<p>其中取指和取源操作数周期，与MOV指令相同，图中不再细画。目的周期DT也与MOV指令的DT相似，但多一步操作，即访存读取目的操作数，其余则完全相同，不再赘述。</p>
<p>OP是操作运算符，例如C OP D→Z，若该指令是一条加法指令，则所描述的含义即为C+D→Z。</p>
<p><img src="assets/double_operator_instruction.png" alt="" /></p>
<h3 id="434-单操作数指令"><a class="header" href="#434-单操作数指令">4.3.4 单操作数指令</a></h3>
<p>单操作数指令共有6条：求反COM、求补NEG、加“1”INC、减“1”DEC、左移SL、右移SR，其指令流程图如图3-28所示。</p>
<p><img src="assets/single_operator_instruction.png" alt="" /></p>
<p>单操作数指令只有一个操作数，处理后送回原处，因此不需源周期状态ST，取指后直接进入目的周期DT，执行周期ET中的流程分支也只有两类，其余均与双操作数指令相同。$RT_0$ 中的具体操作含义取决于操作码OP，例如OP D→Z，若该指令是一条求反指令，则所描述的含义为 $\overline{D}$→Z。</p>
<h3 id="435-转移指令jmp返回指令rst"><a class="header" href="#435-转移指令jmp返回指令rst">4.3.5 转移指令JMP/返回指令RST</a></h3>
<p>JMP指令的流程如图3-29所示。RST指令被视为JMP指令的一种特例。</p>
<p><img src="assets/jump_insruction.png" alt="" /></p>
<p>JMP/RST指令的主要任务是获得转移地址或返回地址，安排在执行周期ET中完成，因此</p>
<ul>
<li>在FT中读得指令并修改PC后，直接进入ET。</li>
<li>根据指令规定的转移条件与PSW相应的位的实际状态，决定是否转移，相应地分成转移成功（JP）、转移不成功（NJP）两种可能。</li>
</ul>
<ol>
<li>转移不成功<code>NJP</code></li>
</ol>
<p>转移条件不满足，则程序将顺序执行。 在决定下一条指令地址时有以下两种可能的情况</p>
<ul>
<li>
<p>转移地址段中的寻址方式所指定的寄存器如果不是PC寄存器，称为$\overline{PC}$型(即通用寄存器、堆栈指针SP)，则后继指令紧跟着当前转移指令（在FT中修改后的PC内容，就是后继指令地址）。</p>
</li>
<li>
<p>转移地址段中的寻址方式所指定的寄存器指明是PC，称为PC型，则紧跟指令操作码与寻址字段之后的单元已用来存放转移地址，再下一个存储单元内容才是后继指令，所以在ET中令PC再次加1。</p>
</li>
</ul>
<ol start="2">
<li>转移成功JP</li>
</ol>
<p>即转移条件满足，按寻址方式获得转移地址。</p>
<ul>
<li>寄存器寻址R: 从指定寄存器中读取转移地址。</li>
<li>寄存器间址（R）: 从指定寄存器中读取间址单元地址，再从间址单元中读取转移地址。</li>
<li>自增型寄存器间址（R）+ : 比上一种寻址方式增加一步修改指针R i 的操作。</li>
<li>返回指令RST 其寻址方式固定为（SP）+，即从堆栈中读取返回地址，然后修改指针SP。</li>
<li>相对寻址X（PC）: 以PC内容为基准进行转移地址计算。</li>
</ul>
<h3 id="434-转子指令jsr"><a class="header" href="#434-转子指令jsr">4.3.4 转子指令JSR</a></h3>
<p><img src="assets/vrzi_instruction.png" alt="" />
转子指令采用（R）或（R）+型，安排在源周期ST，从主存中读取转移地址，暂存于C中。</p>
<p>在ET0 ～ET3 中，先将返回地址压入堆栈保存，即修改堆栈指针，将PC内容（返回地址）经MDR写入堆栈。在ET4 中再将子程序入口地址送入PC。</p>
<h3 id="435-中断响应周期it"><a class="header" href="#435-中断响应周期it">4.3.5 中断响应周期IT</a></h3>
<p>当外部有中断请求信号送入CPU时</p>
<ul>
<li>若允许响应，则在一条指令的执行周期ET的最后一拍，向请求源发中断响应回答信号INTA，并在ET结束时将IT置1，即转入中断响应周期。</li>
<li>进入IT后，将断点与PSW压入堆栈，然后关中断，最后形成中断处理程序的入口地址并送入PC。</li>
<li>IT一结束就切换到取指周期FT，即开始执行中断处理程序。</li>
</ul>
<blockquote>
<p>有关中断的内容将在以后的章节深入讨论。</p>
</blockquote>
<h3 id="436-dma周期"><a class="header" href="#436-dma周期">4.3.6 DMA周期</a></h3>
<p>在一条指令执行结束时查询有无DMA请求</p>
<ul>
<li>如有请求且CPU允许响应，则CPU与总线断开，将总线控制权交给DMA控制器，并转入DMA周期。</li>
<li>在DMAT中，CPU暂停工作，由DMA控制器接管系统总线，向总线发出有关地址码与控制信息，控制主存与外设接口之间的信息传送。</li>
<li>由于DMAT并不影响程序计数器PC的内容与有关现场，只是暂停执行程序，所以只要由DMAT转入FT，程序就将恢复执行。</li>
</ul>
<h3 id="437-键盘操作"><a class="header" href="#437-键盘操作">4.3.7 键盘操作</a></h3>
<p>模型机在加电或复位后，产生一个“复位信号”对全机进行初始化，使PC置0，然后进入取指周期FT。</p>
<ul>
<li>主存0号单元中存放的是一条无条件转移指令，它指向“操作系统”的入口。</li>
<li>机器进入系统状态后，可通过键盘输入各种命令信息，使机器进入所要求的工作状态。</li>
</ul>
<h2 id="44-微命令的综合与产生"><a class="header" href="#44-微命令的综合与产生">4.4 微命令的综合与产生</a></h2>
<p>在组合逻辑（硬连逻辑）控制器中</p>
<ul>
<li>微命令是由组合逻辑电路产生的。产生微命令的逻辑条件有工作周期名称、节拍序号、定时脉冲，以及操作码、寻址方式、寄存器号、PSW状态、中断请求、DMA请求等。</li>
<li>在给出全部指令的流程图和微操作时间表后，通过对它们进行综合分析，就可列出各个微命令的逻辑表达式。</li>
</ul>
<p>微命令的逻辑表达式都是“与-或”式的逻辑形态，各“与”项通常包括：指令操作码译码信号、寻址字段译码信号、工作周期状态、节拍、工作脉冲等。</p>
<p>例如：
$$PC_{OUT} =  FT \cdot T_0 + MOV \cdot [DI + X(R) \cdot ST \cdot T_0 + ...$$</p>
<p>$PC_{OUT}$的输出由不同指令（如FT和MOV）与控制信号（如$T_0,ST$等$）组合触发。</p>
<p>$$CP_{MAR} = FT \cdot T_0 \cdot P + MOV \cdot ST \cdot T_0 \cdot P ...$$
在特定状态$P$、周期$T_0$及指令条件下触发$CP_{MAR}$信号输出。</p>
<p>上述微命令的逻辑式反映出在什么情况下需发出某个微命令，将它们整理化简后就获得一组最终的逻辑表达式，可用组合逻辑门电路实现，也可用PLA门阵列实现。所有产生微命令的组合逻辑电路就构成了微操作信号发生器，如图3-20所示。</p>
<p><img src="assets/logic_map.png" alt="" /></p>
<h2 id="45-小结"><a class="header" href="#45-小结">4.5 小结</a></h2>
<p>组合逻辑控制方式</p>
<ul>
<li>优点：组合逻辑控制方式是用逻辑门电路产生微命令的，其速度主要取决于电路延迟，因此在高速计算机，如RISC处理器中，常采用这种速度较快的硬连控制方式。</li>
<li>缺点：在组合逻辑控制器中，产生微命令的门电路所需的逻辑形态很不规整，因此组合逻辑控制器的核心部分比较繁琐、零乱，设计效率较低，检查调试也比较困难。而且设计结果用印制电路板（硬连逻辑）固定下来以后，就很难再修改与扩展。</li>
</ul>
<p>解决上述问题的方法是采用微程序控制方式</p>
<ul>
<li>将程序技术引入到CPU的构成级，即像编制程序那样编制微命令序列，从而使设计规整化</li>
<li>另一方面，将存储结构引入CPU，取代组合逻辑的微操作信号发生器。也就是将微命令表示为二进制代码直接存入一个存储器中，只要修改所存储的代码即微命令信息，就可修改有关功能与执行方式。</li>
</ul>
<h1 id="5-微程序控制器原理"><a class="header" href="#5-微程序控制器原理">5. 微程序控制器原理</a></h1>
<h2 id="微程序控制概念"><a class="header" href="#微程序控制概念">微程序控制概念</a></h2>
<p>有些CPU采用微程序控制方式来产生微命令，相应的控制器称为微程序控制器。</p>
<h3 id="基本概念与术语"><a class="header" href="#基本概念与术语">基本概念与术语</a></h3>
<ol>
<li>微命令与微操作</li>
</ol>
<ul>
<li>
<p>微命令：构成控制信号序列的最小单位（例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等）微命令由控制器通过控制线向有关的部件发出。</p>
</li>
<li>
<p>微操作：微命令控制微操作的发生，微操作是微命令的具体实现。</p>
</li>
</ul>
<ol start="2">
<li>微指令与微周期</li>
</ol>
<ul>
<li>微指令</li>
</ul>
<p>若干微命令的组合，以编码形式存放在控制存储器的一个单元中，控制实现一步操作。一条微指令的功能就是给出完成指令某一步操作所需的微操作控制信息和后继微 指令地址信息。</p>
<p><img src="assets/little_instruction.png" alt="" /></p>
<ul>
<li>微周期</li>
</ul>
<p>通常指从控制存储器中读取一条微指令并执行相应的
微操作所需的时间。</p>
<ol start="3">
<li>微程序与微程序设计</li>
</ol>
<ul>
<li>微程序：一系列微指令的有序集合。</li>
<li>微程序设计：是将传统的程序设计方法运用到控制逻辑的设计中</li>
</ul>
<ol start="4">
<li>工作程序与微程序、主存储器与控制存储器</li>
</ol>
<ul>
<li>
<p>程序员所编制的工作程序以机器指令为单位存放在主存储器中，由于解决不同问题的工作程序中所包含的机器指令、数据及机器指令条数可能有所不同，要求主存单元内容是可以更新的，因此主存储器是可读可写的随机访问存储器。</p>
</li>
<li>
<p>而由机器设计者编制的微程序是以微指令为基本单位，在制作机器时用特殊方式将其写入控制存储器中，由于机器的指令系统是固定的，所以实现指令系统的微程序也是固定的，并且在CPU执行机器指令时，控制存储器只能被读出，不能写入，故控制存储器用只读存储器来实现。</p>
</li>
</ul>
<h3 id="微程序控制方式的基本思想"><a class="header" href="#微程序控制方式的基本思想">微程序控制方式的基本思想</a></h3>
<ul>
<li>
<p>将机器指令分解为基本的微命令序列，用二进制代码表示这些微命令，并编成微指令，多条微指令再形成微程序。</p>
</li>
<li>
<p>每条机器指令对应一段微程序，在制造CPU时固化在CPU中的一个控制存储器（CM）中。</p>
</li>
<li>
<p>当执行一条机器指令时，CPU依次从控制存储器CM中取微指令，从而产生微命令序列。</p>
</li>
<li>
<p>一条微指令包含的微命令，控制实现一步（一个节拍）操作；</p>
</li>
<li>
<p>若干条微指令组成的一小段微程序解释执行一条机器指令。CM中的微程序能解释执行整个指令系统的所有机器指令。</p>
</li>
<li>
<p>这种将微命令以代码形式存储起来的做法就是前面提到的存储控制逻辑，而微指令序列设计方法可以借助于一般的程序设计技术实现。</p>
</li>
</ul>
<p><img src="assets/little_control_principle.png" alt="" /></p>
<p>微程序控制器的核心是控制存储器CM，用它存放各条指令对应的微程序。</p>
<ul>
<li>CM可用只读存储器ROM构成。</li>
<li>若采用可擦除可编程只读存储器EPROM作为CM，则有利于微程序的修改和动态微程序设计。</li>
</ul>
<p>控制存储器CM中的一行表示存放的一条微指令</p>
<ul>
<li>列线输出微指令代码。</li>
<li>行列交叉处有黑点者表示该位信息为1，行列交叉处无黑点者表示该位信息为0。</li>
</ul>
<p>微指令寄存器存放从CM中读出的微指令，它包含两大部分：</p>
<ul>
<li>微操作控制字段（微命令字段）: 微命令字段可直接按位或通过译码提供微命令</li>
<li>顺序控制字段（微地址字段）: 顺序控制字段用于控制产生下一条微指令地址</li>
</ul>
<h3 id="微程序执行过程的描述"><a class="header" href="#微程序执行过程的描述">微程序执行过程的描述</a></h3>
<p>机器所有指令对应的微程序放在控制存储器CM中，其一条机器指令对应的微程序执行过程可描述如下：</p>
<ol>
<li>根据微地址寄存器的内容（通常为0或1），从CM的0号（或1号）单元中读出一条“取机器指令”微指令，送到微指令寄存器，这是一条公用微指令。</li>
</ol>
<blockquote>
<p>该微指令的微命令字段产生有关控制信号，完成从存储器中取出机器指令送往指令寄存器IR，并修改程序计数器PC的内容。</p>
</blockquote>
<ol start="2">
<li>
<p>IR中机器指令的操作码通过微地址形成电路形成这条指令对应的微程序入口地址，并送入微地址寄存器中。</p>
</li>
<li>
<p>根据微地址寄存器中的微地址从CM中取出对应微程序的一条微指令，其微命令字段产生一组微命令控制有关操作；由顺序控制字段形成下一条微指令地址，送入微地址寄存器。重复步骤3直到该机器指令的微程序执行完。</p>
</li>
<li>
<p>执行完一条机器指令的微程序后，返回到CM的0号（或1号）微地址单元，重复步骤1，读取“取机器指令”微指令，以便取下一条机器指令。</p>
</li>
</ol>
<h2 id="微指令编码方式"><a class="header" href="#微指令编码方式">微指令编码方式</a></h2>
<ol>
<li>直接控制编码（不译码法）</li>
</ol>
<p>微指令的微命令字段中每一位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0就可以了。因此，微命令的产生不需译码。</p>
<p>这种编码的优点是简单、直观、执行速度快、操作并行性好，其缺点是微指令字长过长。</p>
<ol start="2">
<li>分段直接译码法</li>
</ol>
<ul>
<li>互斥性微命令：在同一微周期中不能同时出现的微命令</li>
</ul>
<blockquote>
<p>例如，控制ALU操作的各种微命令ADD、SUB、 AND等是不能同时出现的，即在一条微指令中只能出现一种运算操作。 又如主存储器的读命令与写命令也不能同时出现。</p>
</blockquote>
<ul>
<li>相容性微命令：在同一微周期中可以同时出现的微命令</li>
</ul>
<p>如果将微指令的微命令字段分成若干小字段，把相斥性微命令组合在同一字段中，而把相容性微命令组合在不同的字段中。每个字段独立编码，每种编码代表一个微命令，且各字段编码含义单独定义，与其他字段无关，这就称为分段直接编译法</p>
<p>分段直接编译法可以缩短微指令字长，同时又保持一定的并行控制能力。</p>
<p>常见的分段方法有两种：</p>
<ul>
<li>将机器的全部微命令中相斥性微命令尽可能编入同一字段，而不管它们是否属于同一类操作。</li>
<li>将同类操作（或控制同一部件的操作）中相斥性微命令划分在一个字段内</li>
</ul>
<ol start="3">
<li>分段间接译码法</li>
</ol>
<p>一个字段的含义不仅决定于本字段编码，还兼由其他字段来解释，以便使用较少的信息位表示更多的微命令。</p>
<p>属于这种编码方法的常见形式有以下两种：</p>
<ul>
<li>可解释的字段译码</li>
</ul>
<p>例如微指令中A字段（高3位）的含义兼由第0位来解释，当第0位为1时，字段A表示某一类操作中的8个相斥性微命令；第0位为0时，字段A表示另一类操作中的8个微命令。因此，第0位与A字段总共可表示16种微命令。</p>
<p>这种方法可将属于不同类型的操作归并为一个字段。当然解释位也可扩展为一个字段或某一个状态触发器。</p>
<ul>
<li>分类编译</li>
</ul>
<p>按微指令的功能将其分成几类，分别安排各类微指令的格式和编码，由某一字段或状态触发器来控制和区别。例如，可分为ALU操作类、I/O操作类等。</p>
<ol start="4">
<li>常数源字段E的设置</li>
</ol>
<p>在微指令中，一般设有一个常数源字段E，就如同机器指令中的立即操作数一样，用来提供微指令所使用的常数（由设计者填写）</p>
<ul>
<li>如提供计数器初值，通用寄存器地址，转移地址等。</li>
<li>字段E也可用来参与其他控制字段的间接编码，以减少微指令字长，增加微指令的灵活性。</li>
</ul>
<p>字段E在微指令中的形式为</p>
<p><img src="assets/little_yr_operator.png" alt="" /></p>
<h2 id="微程序的顺序控制方式"><a class="header" href="#微程序的顺序控制方式">微程序的顺序控制方式</a></h2>
<h3 id="微程序入口地址的形成"><a class="header" href="#微程序入口地址的形成">微程序入口地址的形成</a></h3>
<p>由于每条机器指令都需要取指操作，所以将取指操作编制成一段公用微程序，通常安排在控制存储器的0号或1号单元开始的一段CM空间。</p>
<p>每一条机器指令对应着一段微程序，其入口就是初始微地址。首先由“取机器指令”微程序取出一条机器指令到IR中，然后根据机器指令操作码转换成该指令对应的微程序入口地址。</p>
<p>这是一种多分支（或多路转移）的情况，常用以下三种方式形成入口地址:</p>
<ol>
<li>当操作码的位数与位置固定时，可直接使操作码与入口地址码的部分相对应。</li>
</ol>
<p>例如，操作码为P，则入口地址为000P，这样控制存储器0页的一些单元地址被安排作为各段微程序入口地址，再通过单元内的无条件转移微指令与各自的后续微程序相连接。</p>
<ol start="2">
<li>当每类指令中的操作码位数与位置固定，而各类指令之间的操作码与位置不固定时，可采用分级转移的方式。</li>
</ol>
<p>例如，操作码为P，则入口地址为000P，这样控制存储器0页的一些单元地址被安排作为各段微程序入口地址，再通过单元内的无条件转移微指令与各自的后续微程序相连接。</p>
<ol start="3">
<li>当机器指令的操作码位数和位置都不固定时，通常可以采用PLA电路将每条指令的操作码翻译成对应的微程序入口地址，也可以采用PROM（可编程只读存储器）实现转移，将指令操作码作为PROM的地址输入，其对应的PROM单元内容即为该机器指令的微程序入口地址。</li>
</ol>
<h3 id="后继地址的形成"><a class="header" href="#后继地址的形成">后继地址的形成</a></h3>
<p>转移到一条机器指令对应的微程序入口地址后，就开始执行微程序，这时每条微指令执行完毕时，需根据其中的顺序控制字段的要求形成后继微指令地址。</p>
<p>形成后继微指令地址的方式很多，总的来说，可分为两大基本类型。</p>
<ol>
<li>增量方式（顺序-转移型微地址）</li>
</ol>
<p>在微程序控制器中，可设置一个微程序计数器μPC</p>
<ul>
<li>在顺序执行微指令时，后继微指令地址由当前微地址（即μPC内容）加上一个增量（通常为1）来形成</li>
<li>遇到转移时，由微指令给出转移微地址，使微程序按新的顺序执行。</li>
</ul>
<p><img src="assets/little_next_addr_add.png" alt="" />
增量方式可能有以下形态：</p>
<ul>
<li>顺序执行: 由转移方式字段指明。此时，μPC加1给出后继微地址。为减少微指令长度，可将转移地址字段暂作为微命令字段。</li>
<li>无条件转移: 由转移方式字段指明。转移地址字段提供微地址的全部；或给出低位部分，高位与当前微地址相同。</li>
<li>条件转移: 由转移方式字段指明判别条件，转移地址字段指明转移成功的去向，不成功则顺序执行。</li>
</ul>
<blockquote>
<p>机器中可作为转移判别的条件有多个，但每次只能选择一个测试判别源，所以一次只允许两路分支。</p>
</blockquote>
<ul>
<li>转微子程序: 由转移方式字段指明。微子程序入口地址由转移地址字段（或与μPC组合）提供。在转微子程序之前，要将该条微指令的下一条微指令地址（μPC+1）送入返回地址寄存器中，以备返回微主程序。</li>
<li>微子程序返回: 由转移方式字段指明。此时将返回地址寄存器内容作为后继微地址送入μPC中，从而实现从微子程序返回到原来的微主程序。此时，可将转移地址字段暂用作微命令字段。</li>
</ul>
<p>缺点是这种方式不利于解决两路以上的并行微程序转移，因而不利于提高微程序的执行速度。</p>
<ol start="2">
<li>断定方式</li>
</ol>
<p>所谓断定型微地址是指后继微地址可由微程序设计者指定，或者根据微指令所规定的测试结果直接决定后继微地址的全部或部分值。</p>
<p><img src="assets/little_instruction_next_drdk.png" alt="" /></p>
<ul>
<li>非测试段: 可由设计者直接给定，通常是后继微地址的高位部分，用以指定后继微指令在某个区域内。</li>
<li>测试段: 根据有关状态的测试结果确定其地址值，占后继微地址的低位部分。这相当于在指定区域内断定具体的分支。所依据的测试状态可能是指定的开关状态、指令操作码、状态字等。</li>
</ul>
<p>事实上，在多数机器的微指令系统中，增量方式和断定方式是混合使用的</p>
<h2 id="微指令格式"><a class="header" href="#微指令格式">微指令格式</a></h2>
<h3 id="水平型微指令"><a class="header" href="#水平型微指令">水平型微指令</a></h3>
<p>特征：</p>
<ul>
<li>微指令较长，通常为几十位到上百位左右。如VAX-11/780的微指令字长96位，总之，机器规模越大、速度越快，其微指令字越长。</li>
<li>微指令中的微操作具有高度并行性，这种并行操作能力是以数据通路中各部件间的并行操作结构为基础的。例如执行一条水平型微指令就能控制信息从若干源部件同时传送到若干目的部件。</li>
<li>微指令编码简单，减少微命令的译码时间。</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：执行效率高、灵活性好，微程序条数少，因此广泛应用于速度较快的机器中。</li>
<li>缺点：其微指令字较长，复杂程度高，难以实现微程序设计自动化。</li>
</ul>
<h3 id="垂直型微指令"><a class="header" href="#垂直型微指令">垂直型微指令</a></h3>
<p>特征是微指令较短，微指令的并行操作能力有限，一般一条微指令只能控制数据通路的一两种信息传送操作。</p>
<p>通常每条微指令都有一个微操作码字段、源地址和目的地址及某些扩展操作字段。</p>
<ul>
<li>优点：便于编制微程序。由此编制的微程序规整、直观、有利于设计的自动化。</li>
<li>缺点：但垂直型微指令不能充分利用数据通路的并行操作能力，微程序长，因而效率低。</li>
</ul>
<h2 id="5-模型机微程序指令格式"><a class="header" href="#5-模型机微程序指令格式">5. 模型机微程序指令格式</a></h2>
<p>微指令的微操作控制字段是按操作性质划分字段，对于一些零乱的微操作可归入辅助操作一组。</p>
<p>由于模型机CPU内部采用的是单总线结构，每次只能完成一种基本的数据通路传送操作，如PC→MAR，这表明其微指令格式应偏向于垂直型；但由于微指令控制字段的设置是面向微命令的，因此又具有水平型微指令的某些特点，故可以看成是混合型微指令。</p>
<p>对于微程序的顺序控制方式，在模型机中采用增量方式和断定方式相结合的方案，当微程序顺序执行、无条件和条件转移，以及转微子程序与返回时，用增量方式形成后继微地址；当微程序需要多路转移时，用断定方式形成相应的各路转移微地址。</p>
<p><img src="assets/little_instruction_model.png" alt="" /></p>
<ol>
<li>基本数据通路控制字段</li>
</ol>
<ul>
<li>$F_{OUT}$：寄存器的输出控制字段</li>
<li>$F_{ALU}$：ALU的操作与Z的移位控制字段</li>
<li>$F_{CP}$：寄存器的同步打入控制字段</li>
<li>$F_{PC}$：PC的操作控制字段</li>
</ul>
<ol start="2">
<li>访存控制字段</li>
</ol>
<ul>
<li>$F_{EMAR}$：MAR输出控制字段</li>
<li>$F_{R/W}$：主存读写与MDR开支字段</li>
</ul>
<ol start="3">
<li>辅助控制字段</li>
</ol>
<ul>
<li>$F_{ST}$：辅助操作控制字段</li>
</ul>
<ol start="4">
<li>顺序控制字段</li>
</ol>
<ul>
<li>$JC$：转移方式字段，用以选择后继指令地址的形成方式</li>
</ul>
<h1 id="精简指令计算机risc"><a class="header" href="#精简指令计算机risc">精简指令计算机(RISC)</a></h1>
<ol>
<li>RISC和CISC</li>
</ol>
<p>统的CISC设计思想并不利于提高计算机的速度。而且复杂的指令系统必然增加硬件实现的复杂性，从而使计算机的研制周期长、投资大。因此人们开始研究指令系统的合理性问题。对CISC指令系统运行的统计分析表明，各种指令的使用频率相差悬殊，最常用的是一些比较简单的指令，仅占指令总数的20%，但在程序中出现的频率却占80%。</p>
<ol start="2">
<li>特点</li>
</ol>
<p>精简指令系统计算机的着眼点不是简单地放在简化指令系统上，而是通过简化指令使计算机的结构更加简单合理，更易于流水线的实现，从而提高处理速度。</p>
<ul>
<li>面向寄存器的结构</li>
</ul>
<p>所有运算使用的数据都来自寄存器，运算结果也都写入寄存器。通常CPU内应设置大量的通用寄存器，以减少访问主存储器。</p>
<ul>
<li>采用LOAD/STORE结构</li>
</ul>
<p>能够访问主存储器的只有两种指令：从存储器读取数据到寄存器的LOAD（取数）指令和从寄存器向存储器写数据的STORE（存数）指令。</p>
<ul>
<li>较少的指令数和寻址方式</li>
</ul>
<p>选取使用频率最高的一些简单指令，以及很有用但不复杂的指令，可简化控制部件。选用简单的寻址方式，有利于减少指令的执行周期数。</p>
<ul>
<li>所有指令长度相同</li>
</ul>
<p>指令长度相同，指令格式固定简单，可简化指令的译码逻辑，并 有利于提高流水线的执行效率。为了便于编译的优化，常采用三地址 指令格式。</p>
<ul>
<li>硬布线控制逻辑</li>
</ul>
<p>由于指令系统的精简，控制部件可由组合逻辑实现，不用或少用微程序控制，这样可使控制部件的速度大大提高。</p>
<ul>
<li>注重编译的优化</li>
</ul>
<p>RISC指令系统的简化，必然使编译生成的代码长度增长。但通过编译优化技术，将编译初步生成的代码重新组织，调度指令的执行次序，以充分发挥内部操作的并行性，从而进一步提高流水线的执行效率。</p>
<ol start="3">
<li>超标量与超流水线概念</li>
</ol>
<p>在一个单执行部件的RISC中，多数指令是单周期执行，但仍有少数指令需要一个周期以上的执行时间。因此，其每条指令执行的平均周期数CPI接近于1，但不能小于1。</p>
<p>要使CPI小于1</p>
<ul>
<li>
<p>超标量结构: 将RISC设计成具有多个执行部件的结构，同时在每一个周期内允许发出多条指令，并调度多条指令在不同的执行部件中并行执行操作</p>
</li>
<li>
<p>超标量结构: 将流水线的每个节拍分成3个或4个小节拍，每个小节拍执行一个操作，便有可能在取出第i 条指令后，相隔一个小节拍，就取出第i +1条指令，这样就可能在一个流水线的节拍内，取出3条或4条指令，送入流水线去执行，从而使CPI小于1</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>第四章、指令系统层</p>
<p>计算机的基本工作主要体现为执行指令。</p>
<p>指令系统(指令集)：指令格式、寻址方式、指令类型与功能。</p>
<p>相对微体系结构层，是一个抽象的层次，它是硬件和软件之间的接口（硬件和编译器都能理解的语言）</p>
<p>其主要特征就是指令系统的两种状态</p>
<ul>
<li>内核模式</li>
<li>用户模式</li>
</ul>
<p>本章将以80x86为背景讨论指令系统层，介绍</p>
<ul>
<li>80x86系列cpu的结构</li>
<li>80x86主存储器和寄存器</li>
<li>80x86指令系统</li>
</ul>
<h1 id="1-80x86cpu"><a class="header" href="#1-80x86cpu">1. 80x86CPU</a></h1>
<p>目前，主要的CPU架构有四种</p>
<ul>
<li>ARM</li>
<li>X86</li>
<li>MIPS Power</li>
<li>ALPHA<br />
目前，在移动芯片领域，ARM架构的芯片占据了90%以上的市场份额，在服务器CPU市场上，英特尔X86处理器占据超过90%市场份额</li>
</ul>
<p>80x86是Intel首先开发制造的一种微处理器体系结构的泛称</p>
<p><img src="./assets/all80x86cpu.png" alt="80x86CPU概括" /></p>
<h2 id="11-80868088cpu"><a class="header" href="#11-80868088cpu">1.1 8086/8088cpu</a></h2>
<ul>
<li>
<p>8086
16位微处理器，即8086CPU的内外数据总线为16位，⼀个总线周期可以传送⼀个字（16位）数据。</p>
</li>
<li>
<p>8088
准16位微处理器,即8088CPU的内部DB为16位，外部DB为8位，⼀个总线周期只能传送⼀个字节。</p>
</li>
</ul>
<p>8086/8088两者的内部结构基本上相同，地址引脚均为20位，可寻址1MB主存空间。指令系统完全相同，在软件上是完全兼容的。</p>
<h3 id="指令流水线结构"><a class="header" href="#指令流水线结构">指令流水线结构</a></h3>
<ul>
<li>BIU总线接口部件: 取指令（或取操作数）</li>
<li>EU执行部件: 执行指令<br />
当EU执行某条指令时，BIU同时完成从主存中预取后继指令，两个部件并行地工作。</li>
</ul>
<h3 id="内部架构"><a class="header" href="#内部架构">内部架构</a></h3>
<p><img src="assets/2024-11-20-13-51-35.png" alt="8086cpu内部架构" /></p>
<ol>
<li>执行部件EU</li>
</ol>
<p>包括：</p>
<ul>
<li>一个ALU（16位）</li>
<li>一组通用寄存器（16位）</li>
<li>暂存器</li>
<li>标志寄存器（16位）</li>
<li>EU控制器</li>
</ul>
<p>功能：</p>
<ul>
<li>从指令队列中取出指令代码，由EU控制器进⾏译码后产⽣对应的控制信号到各部件以完成指令规定的操作。</li>
<li>对操作数进⾏算术和逻辑运算，并将运算结果的特征状态存放在标志寄存器中。</li>
<li>由于EU不直接与系统总线连接，因此当需要与主存储器或I/O端⼝传送数据时，EU向BIU发出命令，并提供给BIU 16位有效地址与传送的数据。</li>
</ul>
<ol start="2">
<li>总线接口部件BIU</li>
</ol>
<p>包括</p>
<ul>
<li>一组段寄存器</li>
<li>指令指针</li>
<li>指令队列（6字节，8088是4字节）</li>
<li>总线地址形成部件（20位，地址加法器）</li>
<li>总线控制逻辑</li>
</ul>
<p>功能：完成CPU与主存储器或I/O端口之间的信息传送</p>
<ul>
<li>从主存取出指令送到指令队列中排队</li>
<li>从主存或I/O端⼝取操作数或存放运算结果</li>
<li>计算并形成访问主存的20位物理地址</li>
</ul>
<h3 id="8086主存地址的形成"><a class="header" href="#8086主存地址的形成">8086主存地址的形成</a></h3>
<p>8086cpu内部寄存器即数据线均为16位，可访问存储器空间64K，实际主存地址20位，寻址空间1M。16位字长的机器如何提供20位地址？</p>
<p>解决办法：分段：将1M空间分成64K一段</p>
<ol>
<li>地址概念</li>
</ol>
<ul>
<li>物理地址：每个存储单元的唯一的20位地址</li>
<li>段基址
<ul>
<li>段起始地址，XXXX0H</li>
<li>段起始地址的20位后4位为零，所以只需要表示前16位即可，前16位地址称为段基址</li>
<li>段基址放在段寄存器中</li>
</ul>
</li>
<li>偏移地址：段内相对于段起始地址的偏移量</li>
<li>逻辑地址：
<ul>
<li>由段基址和逻辑地址组成，记作<code>段基址:偏移地址</code></li>
</ul>
</li>
</ul>
<p>物理地址与逻辑地址的转换
$$物理地址 = 段基址 x 2^4 + 偏移地址$$</p>
<p><img src="assets/2024-11-20-13-57-58.png" alt="8086主存地址的形成" /></p>
<h4 id="段寄存器"><a class="header" href="#段寄存器">段寄存器</a></h4>
<p>汇编语言源程序是分段结构（代码段、数据段...）</p>
<p>在8086～80286中，有4个专门存放段基值的寄存器，称为段寄存器。</p>
<blockquote>
<p>每个段寄存器可以确定一个段的起始地址</p>
</blockquote>
<ol>
<li>段寄存器的种类</li>
</ol>
<ul>
<li>CS: 代码段
存放当前正在运行的程序</li>
<li>DS: 数据段
存放当前运行程序所用的数据</li>
<li>SS: 堆栈段
定义了堆栈的所在区域</li>
<li>ES: 附加段
附加的数据段，一个辅助的数据区，也是串处理指令的目的操作数存放区</li>
</ul>
<blockquote>
<p>在80386及其后继的80x86中，除上述4个段寄存器外，又增加了2个段寄存器FS和GS，它们也是附加的数据段寄存器</p>
</blockquote>
<ol start="2">
<li>段寄存器与存放偏移地址的寄存器之间的默认组合关系</li>
</ol>
<ul>
<li>8086/8088,80286</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>段寄存器</th><th>偏移地址</th></tr></thead><tbody>
<tr><td>CS</td><td>IP</td></tr>
<tr><td>SS</td><td>SP或BP</td></tr>
<tr><td>DS</td><td>BX,SI,DI或一个16位数</td></tr>
<tr><td>ES</td><td>DI(用于串指令)</td></tr>
</tbody></table>
</div>
<ul>
<li>80386及后续机型</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>段寄存器</th><th>偏移地址</th></tr></thead><tbody>
<tr><td>CS</td><td>IP</td></tr>
<tr><td>SS</td><td>SP或BP</td></tr>
<tr><td>DS</td><td>BX,SI,DI或一个16位数</td></tr>
<tr><td>ES</td><td>EAX,EBX,ECX,EDX,EDI,ESI,一个8位或32位数</td></tr>
<tr><td>FS</td><td>无默认</td></tr>
<tr><td>GS</td><td>无默认</td></tr>
</tbody></table>
</div>
<h2 id="12-8038680486cpu"><a class="header" href="#12-8038680486cpu">1.2 80386/80486cpu</a></h2>
<ol>
<li>80386</li>
</ol>
<ul>
<li>32位地址，可直接寻址的物理存储空间为4 GB。</li>
<li>具有片内存储管理部件，使虚拟存储空间（逻辑地址空间）可达64 TB。</li>
<li>字长32位，系统总线的数据通路宽度32位。</li>
<li>采用多级流水线结构(多独立部件，重叠执行)。</li>
<li>平均运算速度约为4 MIPS（4百万指令每秒）。</li>
</ul>
<ol start="2">
<li>80486</li>
</ol>
<p>80486相当于一个增强型的80386、一个增强型的80387数值协处理器（浮点部件FPU）、一个8 KB的高速缓存（Cache）的集成，基本上沿用了80386的体系结构,5级流水</p>
<p><img src="assets/2024-11-20-17-51-59.png" alt="80486cpu结构" /></p>
<ul>
<li>
<p>总线接口部件BIU:</p>
<ul>
<li>包含
<ul>
<li>地址驱动器</li>
<li>数据收发器</li>
<li>总线控制器</li>
</ul>
</li>
<li>功能:
<ul>
<li>CPU与存储器及I/O设备之间的高速接口</li>
<li>当取指令、取数据或写数据、响应分页部件或分段部件请求时，能有效地满足CPU对系统总线的传送要求。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>指令部件</p>
<ul>
<li>包含
<ul>
<li>指令预取部件</li>
<li>指令译码部件</li>
<li>产生微命令的控制部件</li>
<li>高速缓存Cache。</li>
</ul>
</li>
<li>功能:
<ul>
<li>完成预取指令</li>
<li>分析指令</li>
<li>然后产生指令所需的微命令去控制相应部件操作。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>执行部件</p>
<ul>
<li>数据部件: 执行控制部件所指定的数据操作,包括:
<ul>
<li>通用寄存器</li>
<li>一个有乘除功能的ALU</li>
<li>一个64位的桶形移位器</li>
</ul>
</li>
<li>浮点部件FPU
<ul>
<li>浮点部件FPU</li>
<li>浮点寄存器组</li>
</ul>
<blockquote>
<p>由于浮点部件FPU和浮点寄存器组集成在80486芯片内，缩短了FPU与处理器各部件之间的距离，因此FPU的执行速度比80386和80387组成的系统快3倍。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>存储器管理部件MMU</p>
<ul>
<li>将存储器按段来组织，以适应用户程序的逻辑结构，段的大小可变，最大可达到4 GB。</li>
<li>针对主存物理空间的组织，又将存储器划分为页，每页大小均为4 KB。</li>
<li>存储器管理部件设置了分段部件与分页部件
<ul>
<li>分段部件按控制部件的要求计算有效地址，并且将逻辑地址（由段基值和偏移地址组成）转换成线性地址，即：线性地址=段基址+有效地址（即偏移地址）</li>
<li>分页部件通过页变换，将来自分段部件或指令预取部件的线性地址转换成主存的物理地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上述9个部件可以独立操作，也能与其他部件并行工作。在取指令和执行指令的过程中，每个部件都完成一部分功能，因此80486可以同时对不同指令进行操作。</p>
<p>80486具有5级流水线，使不同指令的操作重叠程度更高，从而允许一些常用指令在一个时钟周期内完成。</p>
<blockquote>
<p>尽管这些指令的读取、译码和执行实际上占用了多个时钟周期，但由于这些指令与其他指令的译码和执行相重叠，因此平均每条指令的执行时间只占一个时钟周期。</p>
</blockquote>
<h2 id="3-pentium系列cpu"><a class="header" href="#3-pentium系列cpu">3. Pentium系列cpu</a></h2>
<h3 id="pentium-cpu"><a class="header" href="#pentium-cpu">Pentium cpu</a></h3>
<p>Pentium CPU是第一个实现系统管理方式的高性能微处理器，它能很好地实现PC机系统的能耗与安全管理。</p>
<p>Pentium CPU是Intel 80x86系列微处理器的第五代产品，其性能比它的前一代产品又有较大的提高，但它仍保持与Intel 8086、80286、80386、80486兼容。</p>
<p><img src="assets/2024-11-20-18-08-24.png" alt="Pentium cpu的功能结构" /></p>
<ol start="0">
<li>
<p>64位数据总线</p>
</li>
<li>
<p>超标量体系</p>
</li>
</ol>
<ul>
<li>三条指令执行流水线
<ul>
<li>两条独立的整数指令流水线（U流水线和V流水线）</li>
<li>一条浮点指令流水线</li>
</ul>
</li>
</ul>
<p>意味着每条流水线拥有</p>
<ul>
<li>独立的算数逻辑运算部件</li>
<li>地址生成逻辑</li>
<li>高数数据缓存接口</li>
</ul>
<blockquote>
<p>一个时钟周期执行两条简单指令，比相同频率下的80486性能提高1倍</p>
</blockquote>
<ol start="2">
<li>浮点指令流水线与浮点指令部件</li>
</ol>
<p>浮点指令流水线具有8级，U流水线的扩充。</p>
<ul>
<li>U流水线的前4级准备一条浮点指令，浮点部件中的后4级执行浮点运算操作并报错。</li>
<li>浮点指令（加、减、除）采用专用硬件电路，这比相同频率下的80486浮点处理性能提高了4倍。</li>
</ul>
<ol start="3">
<li>指令转移预测指令</li>
</ol>
<p>小型1KB高速缓存（称为转移目标缓冲器BTB）</p>
<ul>
<li>记录正在执行的程序最近所发生的几次转移</li>
<li>预示很可能会引向何处</li>
<li>进入流水线的新指令与有关转移信息进行比较
<ul>
<li>多数预测是正确的</li>
<li>若错误，重新取指令。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>数据和指令高数缓存</li>
</ol>
<p>两个超高速缓冲存储器Cache</p>
<ul>
<li>8KB的数据Cache</li>
<li>8KB的指令Cache<br />
并行操作。减少指令预取和数据操作之间冲突，提高微处理器的信息存取速度</li>
</ul>
<h3 id="pentium-pro-cpu"><a class="header" href="#pentium-pro-cpu">Pentium Pro cpu</a></h3>
<p>Pentium Pro CPU即P6，中文名称为高能奔腾处理器，适用32位操作系统</p>
<ul>
<li>三路发布超标量微结构，14级超流水线，使一个时钟周期内可同时执行三条简单指令。</li>
<li>5个并行处理单元
<ul>
<li>两个整数运算部件</li>
<li>一个装入部件</li>
<li>一个存储部件</li>
<li>一个浮点运算部件（FPU）。</li>
</ul>
</li>
<li>8KB两路组相关指令高速缓存，8KB四路组相关数据高速缓存。</li>
<li>专用全速总线上的256 KB SRAM使二级高速缓存与微处理器紧密相联。</li>
<li>事务处理I/O总线和非封锁高速缓存分级结构。</li>
<li>乱序执行，动态分支预测和推理执行。</li>
</ul>
<h3 id="pentium2-cpu"><a class="header" href="#pentium2-cpu">Pentium2 cpu</a></h3>
<ol>
<li>概述</li>
</ol>
<p>PentiumⅡ（PⅡ）CPU采用了与Pentium Pro CPU相同的核心结构。同时，增加了对多媒体的支持和对16位代码优化的特性，它能够同时处理两条MMX多媒体指令。</p>
<ul>
<li>双重独立总线DIB体系结构，能同时使用具有纠错功能的64位系统总线和具有可选纠错功能的64位Cache总线。</li>
<li>多重跳转分支预测。</li>
<li>数据流分析。分析哪一条指令依赖于其他指令的结果或数据，由此来优化指令调度。根据分析结果来重排指令，使指令以优化的顺序执行，而与原始程序的顺序无关。</li>
<li>指令推测执行。使用转移预测和数据流分析，让指令在程序实际执行之前就“推测执行”，并把结果暂时存储起来。通过执行可能需要的指令，使处理器的执行机制尽可能地保持繁忙。</li>
<li>采用Intel MMX技术。它包括57条增强的MMX指令，可处理视频、声频及图像数据。</li>
</ul>
<ol start="2">
<li>内部结构</li>
</ol>
<p><img src="assets/2024-11-20-18-19-47.png" alt="Pentium2 cpu的内部架构" /></p>
<p>PⅡ有3条指令流水线，每条指令流水线共有14级</p>
<p><img src="assets/2024-11-20-18-20-30.png" alt="Pentium2 cpu14级流水" /></p>
<p>PⅡ CPU在体系结构上较以前的处理器有很大变化，一个最明显的技术特征就是其核心完全采用RISC微结构，为了保持与80x86其他处理器兼容，仍继续采用CISC指令集，因此内部增加了RISC与CISC之间的转换硬件。</p>
<p>PⅡ与P6一样采用*BE7～*BE0作为8个存储体的选择信号对存储器的访问加以控制。它们在非流水线的地址方式下需要两个时钟周期进行总线操作，在P6和早期PⅡ系统中，系统总线的速度为66 MHz，主频为250 MHz，以后的PentiumⅡ系统总线速度提高到100 MHz。</p>
<ol start="3">
<li>操作模式</li>
</ol>
<p>PentiumⅡ具有3种操作模式：实模式、虚拟8086模式和保护模式。</p>
<blockquote>
<p>实际上，80386及后继机型都具有这3种模式。</p>
</blockquote>
<ul>
<li>
<p>在实模式下</p>
<ul>
<li>所有8088/8086之后增加的新特性都被关闭</li>
<li>这时PentiumⅡ就像一台单纯的8088/8086一样运行</li>
</ul>
</li>
<li>
<p>在虚拟8086模式下</p>
<ul>
<li>可以用一种受保护的方式来运行老的8088/8086程序</li>
<li>这时，有一个实际的操作系统在控制整个计算机。</li>
</ul>
</li>
<li>
<p>在保护模式下</p>
<ul>
<li>有4种可用的特权级别，它们由程序状态字中的对应位控制</li>
<li>第0级相当于别的计算机中的内核模式，它可以完全控制计算机，因而只由操作系统使用</li>
<li>第3级用于运行用户程序，它阻塞用户程序对某些特殊的关键指令和控制寄存器的访问，以防止某些鲁莽的用户程序搞垮整个计算机</li>
</ul>
<blockquote>
<p>第1级和第2级很少使用。</p>
</blockquote>
</li>
</ul>
<h1 id="2-80x86-cpu的寄存器和主存储器"><a class="header" href="#2-80x86-cpu的寄存器和主存储器">2. 80x86 cpu的寄存器和主存储器</a></h1>
<h2 id="21-80x86-cpu的寄存器"><a class="header" href="#21-80x86-cpu的寄存器">2.1 80x86 cpu的寄存器</a></h2>
<ol>
<li>基本结构寄存器组</li>
</ol>
<ul>
<li>通用寄存器</li>
<li>指令指针寄存器</li>
<li>标志寄存器</li>
<li>段寄存器</li>
</ul>
<ol start="2">
<li>浮点寄存器组</li>
</ol>
<ul>
<li>数据寄存器</li>
<li>标记字寄存器</li>
<li>指令和数据指针寄存器</li>
<li>控制字寄存器</li>
</ul>
<ol start="3">
<li>系统级寄存器</li>
</ol>
<ul>
<li>系统地址寄存器</li>
<li>控制寄存器</li>
<li>测试寄存器</li>
<li>调试寄存器</li>
</ul>
<h3 id="211-基本结构寄存器组"><a class="header" href="#211-基本结构寄存器组">2.1.1 基本结构寄存器组</a></h3>
<p><img src="assets/2024-11-21-13-26-14.png" alt="基本结构寄存器组图示" /></p>
<h4 id="通用寄存器"><a class="header" href="#通用寄存器">通用寄存器</a></h4>
<ol>
<li>通用寄存器</li>
</ol>
<p>8086/8088和80286所具有的寄存器: 图中除阴影区以外的寄存器,都是16位寄存器。</p>
<p>四个16位数据寄存器</p>
<ul>
<li>AX: 数据存储器，累加器，I/O</li>
<li>BX: 数据存储器，基址寄存器</li>
<li>CX: 数据存储器，循环次数</li>
<li>DX: 数据存储器，与AX连用表示32为数据；I/O的端口地址</li>
</ul>
<blockquote>
<p>也可作为8位使用AH、AL、BH、BL……</p>
</blockquote>
<ol start="2">
<li>变址寄存器</li>
</ol>
<p>4个变址寄存器（地址指针寄存器）</p>
<ul>
<li>SP：栈顶指针寄存器</li>
<li>BP：基址指针寄存器</li>
<li>SI： 源变址寄存器</li>
<li>DI：目的变址寄存器</li>
</ul>
<blockquote>
<p>SP、BP、DI、SI也可做16位的数据寄存器使用</p>
</blockquote>
<h4 id="指令指针寄存器和标志寄存器"><a class="header" href="#指令指针寄存器和标志寄存器">指令指针寄存器和标志寄存器</a></h4>
<ol>
<li>IP（Instruction Pointer）</li>
</ol>
<p>指令指针寄存器，它用来存放代码段中的偏移地址。<br />
8086中的CS:IP类似于其他CPU中的PC</p>
<ol start="2">
<li>FLAGS</li>
</ol>
<p>标志寄存器，又称PSW（Program Status Word），即程序状态寄存器。存放条件码标志、控制标志等</p>
<p><img src="assets/2024-11-21-13-36-08.png" alt="80x86cpu中标志寄存器的内容" /></p>
<p>条件码标志:</p>
<ul>
<li>
<p>OF: Over Flow Flag溢出标志
溢出时，则OF置1；否则OF置0</p>
</li>
<li>
<p>SF: Sign Flag符号(负数)标志
结果为负，则SF置1；结果为正，则SF置0</p>
</li>
<li>
<p>ZF: Zero Flag零标志
结果各位全为0时，则ZF置1；否则ZF置0</p>
</li>
<li>
<p>CF: Carry Flag进位/借位标志
进位或借位时，则CF置1；否则置0</p>
</li>
<li>
<p>PF: Parity Flag奇偶标志
运算结果中1的个数为偶数时置1，否则置0</p>
</li>
<li>
<p>AF: Auxiliary Carry Flag辅助进位标志
低字节，低4位</p>
</li>
</ul>
<p>控制标志:</p>
<ul>
<li>DF: Direction Flag方向标志；
在串处理指令中
<ul>
<li>当DF=1时，负向, SI和DI不断减小</li>
<li>当DF＝0时，正向，SI和DI增⼤，使串处理从低地址向⾼地址⽅向处理。</li>
</ul>
</li>
<li>IF: Interrupt Flag中断标志</li>
<li>TF: Trap Flag单步运行标志</li>
</ul>
<p>调试程序DEBUG中提供了测试标志位的手段，它用符号表示某些标志位的值：</p>
<div class="table-wrapper"><table><thead><tr><th>标志名</th><th>标志为1</th><th>标志为0</th></tr></thead><tbody>
<tr><td>OF 溢出（是/否）</td><td>OV</td><td>NV</td></tr>
<tr><td>DF 方向（增量/减量）</td><td>DN</td><td>UP</td></tr>
<tr><td>IF 中断（允许/关闭）</td><td>EI</td><td>DI</td></tr>
<tr><td>SF 符号（正/负）</td><td>NG</td><td>PL</td></tr>
<tr><td>ZF 零（是/否）</td><td>ZR</td><td>NZ</td></tr>
<tr><td>PF 奇偶（偶/奇）</td><td>PE</td><td>PO</td></tr>
<tr><td>CF 进位（是/否）</td><td>CY</td><td>NC</td></tr>
<tr><td>AF 辅助进位（是/否）</td><td>AC</td><td>NA</td></tr>
</tbody></table>
</div>
<p>系统标志:</p>
<ul>
<li>TF(Trap Flat)
标志处理器是否进入单步调试状态</li>
<li>IF(Interrupt Flat)
控制是否允许响应外部中断请求</li>
<li>IOPL（I/O Privilege Level）
设置当前任务访问 I/O 指令的权限级别</li>
<li>NT（Nested Task）
嵌套任务标志，用来表示当前的任务是否嵌套在另一任务内</li>
<li>RF（Resume Flag）
恢复标志位，它与调试寄存器的断点一起使用，以保证不重复处理断点。</li>
<li>VM（Virtual-8086 Mode）
虚拟8086模式位 。</li>
<li>AC（Alignment Check mode）
对准检查方式位 。</li>
<li>VIF（Virtual Interrupt Flag）
虚拟中断标志。</li>
<li>VIP（Virtual Interrupt Pending flag）
虚拟中断未决标志。</li>
<li>ID（IDentification flag）
标识标志，程序有设置和清除ID标识的能力，以指示处理机对CPU ID指令的支持。</li>
</ul>
<h3 id="段寄存器-1"><a class="header" href="#段寄存器-1">段寄存器</a></h3>
<p>汇编语言源程序是分段结构（代码段、数据段…），段寄存器用来存放段起始地址</p>
<ol>
<li>分类</li>
</ol>
<ul>
<li>CS：（Code Segment）代码段</li>
<li>DS：（Data Segment）数据段</li>
<li>SS：（Stack Segment）堆栈段</li>
<li>ES：（Extra Segment）附加段</li>
</ul>
<blockquote>
<p>386后增加了FS、GS两个附加段</p>
</blockquote>
<ol start="2">
<li>段寄存器与存放偏移地址的寄存器之间的默认组合关系</li>
</ol>
<ul>
<li>8086/8088,80286</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>段寄存器</th><th>偏移地址</th></tr></thead><tbody>
<tr><td>CS</td><td>IP</td></tr>
<tr><td>SS</td><td>SP或BP</td></tr>
<tr><td>DS</td><td>BX,SI,DI或一个16位数</td></tr>
<tr><td>ES</td><td>DI(用于串指令)</td></tr>
</tbody></table>
</div>
<ul>
<li>80386及后续机型</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>段寄存器</th><th>偏移地址</th></tr></thead><tbody>
<tr><td>CS</td><td>IP</td></tr>
<tr><td>SS</td><td>SP或BP</td></tr>
<tr><td>DS</td><td>BX,SI,DI或一个16位数</td></tr>
<tr><td>ES</td><td>EAX,EBX,ECX,EDX,EDI,ESI,一个8位或32位数</td></tr>
<tr><td>FS</td><td>无默认</td></tr>
<tr><td>GS</td><td>无默认</td></tr>
</tbody></table>
</div>
<h3 id="212-系统级寄存器"><a class="header" href="#212-系统级寄存器">2.1.2 系统级寄存器</a></h3>
<p>系统级寄存器组是指不能由用户程序访问而只能由系统管理的寄存器</p>
<!-- TODO: many systemtic register -->
<h2 id="22-80x86的主存储器"><a class="header" href="#22-80x86的主存储器">2.2 80x86的主存储器</a></h2>
<p><img src="assets/2024-11-21-13-54-51.png" alt="存储单元的地址和内容" /></p>
<blockquote>
<p>低位字节存放在低位地址中</p>
</blockquote>
<h3 id="221-存储单元的地址和内容"><a class="header" href="#221-存储单元的地址和内容">2.2.1 存储单元的地址和内容</a></h3>
<p>存储器里以字节为单位存储信息，每一个字节单元给予一个唯一的编号即存储器地址，称为物理地址。地址从0开始编号，也是用二进制数来表示的。书写格式为十六进制数。</p>
<p>$$地址总线宽度n位 \Rightarrow^{可寻址} 寻址空间2^n$$</p>
<p>字、双字存放：以低位地址作为整个字/双字的地址</p>
<ul>
<li>对准字：字地址为偶地址</li>
<li>非对准字：字地址为奇地址</li>
</ul>
<blockquote>
<p>非对准字的存取速度比对准字慢，故尽量避免</p>
</blockquote>
<h3 id="222-实模式存储寻址"><a class="header" href="#222-实模式存储寻址">2.2.2 实模式存储寻址</a></h3>
<p>80x86中除8086/8088只能在实模式下工作外，其他的CPU均可在实模式或保护模式下工作。</p>
<ul>
<li>实模式下允许的最大寻址空间为1 MB。8086/8088的地址总线宽度为20位，因而其最大寻址空间正好是1MB。</li>
<li>在1MB的存储器里，每个存储单元都有一个唯一的20位地址，称为物理地址。</li>
<li>对于其他微处理器在实模式下只能访问前1MB的存储器地址。</li>
</ul>
<h3 id="223-保护模式存储器寻址"><a class="header" href="#223-保护模式存储器寻址">2.2.3 保护模式存储器寻址</a></h3>
<ol>
<li>逻辑地址</li>
</ol>
<p>在保护模式存储器寻址中 ，程序员在程序中指定逻辑地址， CPU采用一种比较复杂的方法来求得相应的物理地址。</p>
<p>$$逻辑地址 = 段选择器 + 偏移地址$$</p>
<p>段选择器存放在段寄存器中，由CPU通过一定的方法利用段选择器取得段基址，再和偏移地址相加，从而求得所选存储单元的线性地址，线性地址再通过分页部件转换成物理地址。</p>
<ol start="2">
<li>描述符</li>
</ol>
<p>段选择器是通过描述符表取得描述符，从而得到段基址的。</p>
<p>描述符有8个字节长，用来说明段的起始地址、段的大小、段在存储器中的位置及有关的控制和状态信息，其格式如下图所示:</p>
<p><img src="assets/2024-11-21-14-10-44.png" alt="80286描述符" />
<img src="assets/2024-11-21-14-11-07.png" alt="80386/80486/Pentium描述符" /></p>
<p>描述符由段基址、段界限、访问权和附加字段4部分组成</p>
<ul>
<li>
<p>段基址（Base）
用来指定段的起始地址。80386以上处理器的段基址为32位，说明段可以从4 GB存储器的任何地址开始。</p>
</li>
<li>
<p>段界限（Limit）
用来存放该段的段长度。80386及其后继机型的段界限为20位，同时在其描述符中又给出了一个粒度位G（Granularity）</p>
<ul>
<li>当G = 0时，段长的粒度单位为字节</li>
<li>当G = 1时，段长的粒度单位为页，每页为4 KB</li>
</ul>
</li>
<li>
<p>访问权（Access Rights）
有8位，所以又称为访问权字节,用来说明该段在系统中的功能，并给出访问该段的一些控制信息。
<img src="assets/2024-11-21-14-19-03.png" alt="访问权标志" /></p>
<ul>
<li>
<p>P（Present）存在位</p>
<ul>
<li>P = 1说明该段已装入物理存储器，其段基址和段界限值有效</li>
<li>P = 0则说明该段并未装入物理存储器，段基址和段界限值无用</li>
</ul>
</li>
<li>
<p>DPL（Descriptor Privilege Level）描述符特权级字段2位
用来指定该存储段的特权级0～3，0级为最高特权级。</p>
</li>
<li>
<p>S（Segment Descriptor）段描述符位</p>
<ul>
<li>S = 0表示该段为系统段</li>
<li>S = 1则表示该段为应用程序的代码段或数据（包括堆栈）段</li>
</ul>
</li>
<li>
<p>A（Accessed）已访问位</p>
<ul>
<li>A = 0表示该段尚未被访问过</li>
<li>A = 1表示该段已被访问过。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>附加字段部分在386及其后继机型中存在，它们包括G、D/B、0和AVL 共4位。</p>
<ul>
<li>
<p>G为粒度位
前面已有说明。</p>
</li>
<li>
<p>D/B位
在代码段里，该位称为D（Default OperationSize）默认操作长度位</p>
<ul>
<li>D= 1表示操作数及有效地址长度均为32位</li>
<li>D = 0则为16位操作数和16位有效地址。</li>
</ul>
</li>
<li>
<p>0位
该位必须为0，为未来的处理机保留。</p>
</li>
<li>
<p>AVL（Available）
该位只能由系统软件使用。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>描述符表</li>
</ol>
<p>描述符存放在描述符表中，主要有4种描述符表：</p>
<ul>
<li>
<p>全局描述符表GDT（Global Descriptor Table）
用于存放操作系统和各任务公用的描述符，如公用的数据和代码段描述符、各个任务的TSS描述符和LDT描述符等。</p>
</li>
<li>
<p>局部描述符表LDT（Local Descriptor Table）
用于存放各个任务私有的描述符，如本任务的代码段描述符和数据段描述符等。</p>
</li>
<li>
<p>中断描述符表IDT（Interrupt Descriptor Table）
用于存放系统中断描述符。</p>
</li>
<li>
<p>任务状态段TSS（Task State Segment）
用来存放各个任务的私有运行状态信息描述符。</p>
</li>
</ul>
<p>描述符表都存放在存储器中，每个表分别构成一个64 KB长的段，表中可存放8 K个描述符。</p>
<p>全局描述符表中的描述符所指定的段可用于所有程序，而局部描述符表中的描述符所指定的段通常只用于一个用户程序（或称一个任务）。在整个系统里，只有一个全局描述符表和一个中断描述符表，而局部描述符表可以有多个，它们分别对应于不同的任务。</p>
<ol start="4">
<li>段选择器</li>
</ol>
<p>段选择器提供描述符在描述符表中的位置，存放在段寄存器中，16位长，其格式如下：</p>
<p><img src="assets/2024-11-21-14-26-08.png" alt="段选择器的格式" /></p>
<ul>
<li>
<p>INDEX为索引值，即描述符表索引值
它给出所选描述符在描述符表中的地址。该字段共13位，可从表中8K个描述符中选取一个。</p>
</li>
<li>
<p>RPL（Requested Privilege Level）为请求特权级，这是对该存储段请求访问的特权级
其值可为0～3，0级特权级最高，如RPL和该段描述符中的DPL相等（同一特权级）或RPL＜DPL（请求特权级高于描述符特权级）则允许对该段的访问</p>
</li>
<li>
<p>TI（Table Indicator）为选择位</p>
<ul>
<li>TI = 0指示从全局描述符表GDT中选择描述符</li>
<li>TI = 1则指示从局部描述符表LDT中选择描述符。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>描述符寄存器</li>
</ol>
<p>为了提高保护模式存储器寻址的速度，CPU中设置了6个64位的描述符寄存器，用来存放对应段的描述符，如下图所示
<img src="assets/2024-11-21-14-31-35.png" alt="段寄存器和描述符" /></p>
<p>每当段寄存器中段选择器的值确定以后，硬件会自动地根据段选择器的索引值，从系统的描述符表中取出一个8字节（64位）的描述符，装入到相应的段描述符寄存器中</p>
<p>以后每当出现对该段存储器的访问时，就可直接使用相应的描述符寄存器中的段基址作为线性地址计算的一个元素，而不需要在内存中查表得到段基址，因此加快了存储器物理地址的形成。</p>
<p>应当指出，段寄存器是程序可访问的，而描述符寄存器则是程序不可访问的。</p>
<h3 id="224-80x86逻辑地址的来源"><a class="header" href="#224-80x86逻辑地址的来源">2.2.4 80x86逻辑地址的来源</a></h3>
<p>从以上内容可知</p>
<ul>
<li>实模式下的逻辑地址：由段基值和偏移地址组成</li>
<li>保护模式下的逻辑地址：由段选择器和偏移地址组成。</li>
</ul>
<p>实际上段基值和选择器都是由段寄存器提供。</p>
<p>在汇编语言程序中，逻辑地址可表示为：
$$段基值（或段选择器）：偏移地址$$</p>
<p>在80x86 CPU中，逻辑地址的两个分量之间存在一种默认组合关系，可以不在程序中指明
<img src="assets/2024-11-21-14-41-49.png" alt="80x86cpu逻辑地址两分量中的默认组合" /></p>
<blockquote>
<p>如用到非默认的组合关系（如使用允许替代来源），则必须用段跨越前缀加以说明。</p>
</blockquote>
<h1 id="3-80x86cpu的指令系统"><a class="header" href="#3-80x86cpu的指令系统">3. 80x86cpu的指令系统</a></h1>
<p>80x86 CPU的指令集是在8086/8088 CPU的指令系统上发展起来的。</p>
<ul>
<li>8086/8088 指令系统是基本指令集</li>
<li>80286、80386、80486和Pentium指令系统是在基本指令集上进行了扩充。扩充指令的
<ul>
<li>一部分是增强的8086/8088基本指令和一些专用指令；</li>
<li>另一部分是系统控制指令，即特权指令，它们对80286、80386、80486和Pentium保护模式的多任务、存储器管理和保护机制提供了控制能力。</li>
</ul>
</li>
</ul>
<p>80x86 CPU采用了变字长的机器指令格式，由1～15个字节组成一条指令。一般格式如下图所示:</p>
<p><img src="assets/2024-11-22-11-37-14.png" alt="80x86cpu机器指令格式" /></p>
<h2 id="31-80x86寻址方式"><a class="header" href="#31-80x86寻址方式">3.1 80x86寻址方式</a></h2>
<p>指令中的寻址方式是用来确定操作数地址以找到指令所需的操作数。</p>
<ul>
<li>
<p>8086和80286</p>
<p>字长是16位</p>
<ul>
<li>⼀般情况下只处理8位和16位操作数</li>
<li>只是在乘、除指令中才会有32位操作数；</li>
</ul>
</li>
<li>
<p>80386及其后继机型</p>
<p>字长为32位</p>
<ul>
<li>因此它除可处理8位和16位操作数外，还可处理32位操作数</li>
<li>在乘、除法情况下可产⽣64位操作数。</li>
</ul>
</li>
</ul>
<p>本节下面所述例⼦中，如处理的是32位操作数，则适用于80386及其后继机型</p>
<h3 id="311-立即寻址方式和寄存器寻址方式"><a class="header" href="#311-立即寻址方式和寄存器寻址方式">3.1.1 立即寻址方式和寄存器寻址方式</a></h3>
<ol>
<li>立即寻址方式</li>
</ol>
<p>指令所需的操作数直接在指令代码中，随着取指令一起取到CPU中。</p>
<p>这种操作数称为立即数。立即数用来表示常数</p>
<ul>
<li>经常用于给寄存器赋初值</li>
<li>只能用于源操作数字段，不能用于目的操作数字段</li>
<li>源操作数长度应与目的操作数长度一致</li>
<li>在汇编指令中，立即数若是数值常数可直接书写，若是字符常数则应加上引号。</li>
</ul>
<ol start="2">
<li>寄存器寻址方式</li>
</ol>
<p>指令所需的操作数存放在CPU的寄存器（通用寄存器或段寄存器）中，通过指令中的寄存器地址去找到操作数</p>
<p>在汇编指令中，寄存器地址直接用寄存器名表示，如用AX、BX、AL、BH、EAX、EBX、DS、ES等，这些寄存器可以是8位的、16位的或32位的。</p>
<h3 id="312-存储器寻址"><a class="header" href="#312-存储器寻址">3.1.2 存储器寻址</a></h3>
<p>在汇编语言程序中，一个存储单元的地址采用逻辑地址来表示，其形式为:
$$段基址（或段选择器）: 偏移地址$$</p>
<ul>
<li>操作数地址（物理地址）是根据段基值（或段选择器）和偏移地址通过一定的方法得到。
<ul>
<li>段基址在实模式和保护模式下可从不同的途径取得。</li>
<li>偏移地址是指存放操作数的存储单元与段起始地址（段基址）之间的字节距离</li>
</ul>
<blockquote>
<p>在80x86里，把按寻址方式计算出来的操作数偏移地址称为有效地址EA（Effective Address）。</p>
</blockquote>
</li>
</ul>
<hr />
<p>获得有效地址EA（偏移地址）的方法</p>
<p>EA可由4个地址分量的某种组合求得
$$EA = 基地址+（变址量 x 比例因子） + 位移量$$</p>
<blockquote>
<p>上式中的每一个地址分量均可空缺，但比例因子只能与变址寄存器同时使用。</p>
</blockquote>
<ul>
<li>
<p>位移量</p>
<p>指令代码中的一个8位、16位或32位二进制数，但它不是立即数，而是一个地址量。</p>
</li>
<li>
<p>基地址</p>
<p>基址寄存器或基址指针中的内容</p>
</li>
<li>
<p>变址量</p>
<p>变址寄存器中的内容</p>
</li>
<li>
<p>比例因子</p>
<p>它是80386及其后继机型新增加的寻址方式中的一个术语，其值可为1，2，4或8。在含比例因子的寻址方式中，可用变址寄存器的内容乘以比例因子来取得变址值</p>
</li>
</ul>
<p>8086/80386只能用16位寻址，80386及后续机型可用32位寻址</p>
<div class="table-wrapper"><table><thead><tr><th><strong>地址分量</strong></th><th><strong>16位寻址</strong></th><th><strong>32位寻址</strong></th></tr></thead><tbody>
<tr><td><strong>位移量</strong></td><td>0，8，16位</td><td>0，8，32位</td></tr>
<tr><td><strong>基址寄存器</strong></td><td>BX，BP</td><td>任何32位通用寄存器（包括ESP）</td></tr>
<tr><td><strong>变址寄存器</strong></td><td>SI，DI</td><td>除ESP以外的32位通用寄存器</td></tr>
<tr><td><strong>比例因子</strong></td><td>无</td><td>1，2，4，8</td></tr>
</tbody></table>
</div>
<h4 id="直接寻址方式"><a class="header" href="#直接寻址方式">直接寻址方式</a></h4>
<ul>
<li>指令所需的操作数存放在存储单元中</li>
<li>EA直接由指令代码中的位移量提供。
即EA只包含位移量这一种地址分量</li>
</ul>
<p>$$EA = 位移量$$</p>
<ol>
<li>数值地址表示EA</li>
</ol>
<p>如用数值表示操作数的有效地址，则操作数所在段的段寄存器必须指明，不能省略。例如</p>
<pre><code class="language-asm">MOV BX,段寄存器名:[位移量]
MOV BX,DS:[1000H]
</code></pre>
<ol start="2">
<li>符号地址表示EA</li>
</ol>
<p>源程序中</p>
<ul>
<li>常用符号地址表示存放操作数的存储单元</li>
<li>段基址缺省（DS）或用段跨越前缀给出</li>
</ul>
<pre><code class="language-asm">MOV BX,VARIABLE_NAME
</code></pre>
<h4 id="寄存器间接寻址"><a class="header" href="#寄存器间接寻址">寄存器间接寻址</a></h4>
<ul>
<li>指令所需的操作数在存储单元中</li>
<li>EA直接从基址寄存器或变址寄存器中获得
即EA是由基址（或变址）寄存器内容来提供的</li>
</ul>
<p>$$EA = 基地址/变地址$$</p>
<pre><code class="language-asm">MOV BX,[R_变址]/[R_基址]
MOV BX,[BP]
</code></pre>
<ul>
<li>
<p>16位寻址时可用的寄存器：基址BX、BP、变址SI、DI</p>
<blockquote>
<p>注意：BP缺省段地址为SS，其余3个缺省DS</p>
</blockquote>
</li>
<li>
<p>32位寻址时可用的寄存器：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI</p>
<blockquote>
<p>用BP、ESP、EBP时, 默认为SS段;其他默认为DS段</p>
</blockquote>
</li>
</ul>
<h4 id="寄存器相对寻址"><a class="header" href="#寄存器相对寻址">寄存器相对寻址</a></h4>
<ul>
<li>指令所需的操作数在存储单元中</li>
<li>EA是两个地址分量之和: 基址(或变址)寄存器的内容与指令中指定的位移量之和
<ul>
<li>若使用的是变址寄存器称为变址寻址方式</li>
<li>若使用的是基址寄存器称为基址寻址方式</li>
<li>位移量部分：可用数值表示，也可用符号地址表示</li>
</ul>
</li>
</ul>
<p>$$EA = (R_{变址})/(R_{基址}) + 位移量$$</p>
<pre><code class="language-asm">MOV BX,位移量[R_变址/R_基址]
MOV BX,2[BX]
MOV BX,VARIABLE_NAME[BX]
</code></pre>
<p>常用来访问顺序存放在主存中的一维数组、表、字符串等。其典型用法是将指令中不能修改的位移量作为基准地址，而将变址或基址寄存器内容作为修改量</p>
<h4 id="基址变址寻址方式"><a class="header" href="#基址变址寻址方式">基址变址寻址方式</a></h4>
<ul>
<li>指令所需的操作数在主存单元中</li>
<li>EA是三个地址分量之和：基址寄存器内容、变址寄存器内容与指令中的位移量（0位、8位、16位或32位）之和</li>
</ul>
<p>$$EA = (R_{变址})+(R_{基址})+位移量$$</p>
<pre><code class="language-asm">MOV BX,位移量[R_变址][R_基址]
MOV BX,2[BX][SI]
MOV BX,VARIABLE_NAME[BX][Si]
</code></pre>
<p>由于基址变址寻址⽅式中有两个地址分量可以在程序执⾏过程中进⾏修改，因此常用来访问存放在主存中的⼆维数组 。</p>
<h4 id="比例变址寻址方式"><a class="header" href="#比例变址寻址方式">比例变址寻址方式</a></h4>
<ul>
<li>指令所需的操作数在主存单元中</li>
<li>EA是变址寄存器的内容乘以指令中指定的比例因子再加上位移量之和</li>
</ul>
<p>$$EA = (R_{变址})X比例因子+位移量$$</p>
<pre><code class="language-asm">MOV BX,位移量[(R_{变址}) * 比例因子]
MOV EAX，COUNT[ESI * 4]
</code></pre>
<p>对于元素大小为2，4，8字节的数组，可以在变址寄存器中给出数组元素下标，而由寻址方式控制直接用比例因子把下标转换为变址值。</p>
<h4 id="基址比例变址寻址方式"><a class="header" href="#基址比例变址寻址方式">基址比例变址寻址方式</a></h4>
<ul>
<li>指令所需的操作数在主存单元中</li>
<li>EA由4种成分组成:变址寄存器的内容乘以比例因子，加上基址寄存器的内容，再加上位移量（0位、8位或32位）之和</li>
</ul>
<p>$$EA = (R_{变址})X比例因子+ (R_{基址}) + 位移量$$</p>
<pre><code class="language-asm">MOV BX,位移量[(R_{基址})][(R_{变址}) * 比例因子]
MOV BX,VARIABLE_NAME[BP][DI * 4]
MOV BX,2[BP][DI * 2]
</code></pre>
<h3 id="313-串操作寻址方式"><a class="header" href="#313-串操作寻址方式">3.1.3 串操作寻址方式</a></h3>
<p>80x86提供专门的串操作指令，这些指令所用的操作数也在存储器中，但它们不能使用上述寻址方式，而是隐含使用变址寄存器SI、ESI、DI或EDI</p>
<ul>
<li>隐含使用SI或ESI作为在数据段中的源串（即源操作数）的地址指针</li>
<li>隐含使用DI或EDI作为在附加段中的目的串的地址指针</li>
<li>在完成一次串操作后，指令自动修改SI或ESI、DI或EDI两个地址指针，使SI或ESI、DI或EDI指向下一个串元素的存储单元。</li>
</ul>
<h2 id="32-80x86cpu指令系统"><a class="header" href="#32-80x86cpu指令系统">3.2 80x86cpu指令系统</a></h2>
<p>80x86 CPU指令按操作数地址个数可划分为3种类:</p>
<ol>
<li>双操作数指令</li>
</ol>
<p>$$OPR \quad DEST,SRC$$</p>
<ul>
<li><code>OPR</code>: 指令操作码</li>
<li><code>DEST</code>: 目的操作数地址</li>
<li><code>SRC</code>: 源操作数地址</li>
</ul>
<blockquote>
<p>为了避免指令过长，双操作数指令的两个操作数不能同时是内存中的数</p>
</blockquote>
<ol start="2">
<li>单操作数指令</li>
</ol>
<p>$$ORP \quad DEST$$</p>
<ul>
<li><code>OPR</code>: 指令操作码</li>
<li><code>DEST</code>
<ul>
<li>既是源地址又是目的地址</li>
<li>目的地址，源操作数隐含</li>
</ul>
</li>
</ul>
<ol start="3">
<li>无操作数指令</li>
</ol>
<ul>
<li><code>OPR</code>: 指令操作码</li>
<li>操作数隐含</li>
<li>不需要操作数</li>
</ul>
<h3 id="传送类指令"><a class="header" href="#传送类指令">传送类指令</a></h3>
<p>把数据、地址送到寄存器或存储单元中</p>
<h4 id="mov"><a class="header" href="#mov">MOV</a></h4>
<p>$$MOV \quad DEST,SRC$$</p>
<ul>
<li>操作：<code>(SRC) -&gt; DEST</code></li>
<li>说明
<ul>
<li>SRC和DEST操作数位数一致</li>
<li>DEST不能是立即数和CS</li>
<li>不能将立即数给段寄存器</li>
<li>不能将段寄存器给段寄存器
<img src="assets/2024-11-22-13-36-09.png" alt="MOV指令的源操作数和目的操作数" /></li>
</ul>
</li>
</ul>
<h5 id="带符号扩展传送指令movsx"><a class="header" href="#带符号扩展传送指令movsx">带符号扩展传送指令MOVSX</a></h5>
<blockquote>
<p>MOVSX和MOVZX指令只支持386以后机型</p>
</blockquote>
<p>$$MOVSX \quad DEST,SRC$$</p>
<ul>
<li>操作：<code>符号扩展(SRC) -&gt; DEST</code></li>
<li>说明
<ul>
<li>SRC可以是8位或16位的寄存器或存储单元的内容</li>
<li>DEST必须是16位或32位寄存器</li>
<li>将源操作数进⾏符号扩展后送⼊目的寄存器，8位扩展到16位或32位,16位到32位</li>
</ul>
<blockquote>
<p>符号扩展：将缺少的高位填入符号位进行位数扩展</p>
</blockquote>
</li>
</ul>
<h5 id="带零扩展传送指令"><a class="header" href="#带零扩展传送指令">带零扩展传送指令</a></h5>
<p>$$MOVZX \quad DEST,SRC$$</p>
<ul>
<li>操作：<code>零扩展(SRC) -&gt; DEST</code></li>
<li>说明
<ul>
<li>SRC是⽆符号整数，作零扩展，</li>
<li>即不管源操作数的符号位是否为1，⾼位均扩展为零</li>
</ul>
</li>
</ul>
<h4 id="pushpop"><a class="header" href="#pushpop">PUSH/POP</a></h4>
<ol>
<li>PUSH</li>
</ol>
<p>$$PUSH \quad SRC$$</p>
<ul>
<li><code>(SP)/(ESP) - 2 -&gt; (SP)/(ESP)</code></li>
<li><code>16位SRC -&gt; (SP)/(ESP)</code>
<img src="assets/2024-11-22-13-54-47.png" alt="PUSH AX举例" /></li>
</ul>
<ol start="2">
<li>POP</li>
</ol>
<p>$$POP \quad DEST$$</p>
<ul>
<li>操作：</li>
<li><code>(SP)/(ESP) -&gt; (DST)</code></li>
<li><code>(SP)/(ESP) + 2 -&gt; (SP)/(ESP)</code>
<img src="assets/2024-11-22-13-55-40.png" alt="POP AX举例" /></li>
</ul>
<ol start="3">
<li>说明</li>
</ol>
<ul>
<li>以字（16位）或双字(32位)为单位入、出栈</li>
<li>寄存器、段寄存器、存储单元可入栈，80286之后立即数允许入栈</li>
<li>除CS外，寄存器、段寄存器、存储单元都可作为出栈目的DST</li>
<li>对于不同长度的操作数，所执行的操作不同
<img src="assets/2024-11-22-13-57-58.png" alt="不同操作数长度时所执行de 不同的操作" /></li>
</ul>
<h5 id="pushapushd"><a class="header" href="#pushapushd">PUSHA/PUSHD</a></h5>
<ol>
<li>PUSHA</li>
</ol>
<p>$$PUSHA$$</p>
<ul>
<li>16位通用寄存器依次进栈</li>
<li>进栈次序为AX、CX、DX、BX,以及指令执⾏前的SP、BP、SI、DI</li>
<li>指令执⾏后<code>（SP）&lt;-（SP）- 16</code>指向新栈顶</li>
</ul>
<ol start="2">
<li>PUSHAD</li>
</ol>
<p>$$PUSHAD$$</p>
<ul>
<li>32位通用寄存器依次进栈</li>
<li>进栈次序为EAX、ECX、EDX、EBX，以及指令执⾏前的ESP、EBP、ESI和EDI</li>
<li>指令执⾏后<code>（SP）&lt;-（SP）- 32</code></li>
</ul>
<h5 id="popapopad"><a class="header" href="#popapopad">POPA/POPAD</a></h5>
<ol>
<li>POPA</li>
</ol>
<p>$$POPA$$</p>
<ul>
<li>16位通用寄存器依次出栈</li>
<li>出栈次序为DI、SI、BP、SP、BX、DX、CX、AX</li>
<li>指令执⾏后<code>（SP）&lt;-（SP）+ 16</code></li>
</ul>
<blockquote>
<p>SP的出栈只是修改了指针使其后的BX能顺利出栈，而堆栈中原先由PUSHA指令存入的SP的原始内容被丢弃，并未真正送到SP寄存器中去（SP的伪出栈）</p>
</blockquote>
<ol start="2">
<li>POPAD</li>
</ol>
<p>$$POPAD$$</p>
<ul>
<li>32位通用寄存器依次出栈 (ESP的伪出栈)</li>
<li>出栈次序为EDI、ESI、EBP、ESP、EBX、EDX、ECX、EAX</li>
<li>指令执⾏后<code>（ESP）&lt;-（ESP）＋ 32</code></li>
</ul>
<h4 id="xchg"><a class="header" href="#xchg">XCHG</a></h4>
<p>$$XCHG \quad DEST,SRC$$</p>
<ul>
<li>
<p>操作</p>
<ul>
<li><code>(DEST) Rightleftarrow (SRC)</code></li>
<li>交换SRC和DEST的内容</li>
</ul>
</li>
<li>
<p>说明</p>
<ul>
<li>通用寄存器间或与存储单元,不允许段寄存器、立即数</li>
</ul>
</li>
</ul>
<h4 id="地址传送类"><a class="header" href="#地址传送类">地址传送类</a></h4>
<p>将存储器操作数的地址传送给指定的寄存器，而不是传送操作数</p>
<ul>
<li>LEA（Load Effective Address）有效地址送寄存器</li>
<li>LDS（Load DS with pointer）地址指针送寄存器和DS</li>
<li>LES（Load ES with pointer）地址指针送寄存器和ES</li>
<li>LFS（Load FS with pointer） 地址指针送寄存器和FS</li>
<li>LGS（Load GS with pointer）地址指针送寄存器和GS</li>
<li>LSS（Load SS with pointer） 地址指针送寄存器和SS</li>
</ul>
<h5 id="lea"><a class="header" href="#lea">LEA</a></h5>
<p>$$LEA \quad DEST,SRC$$</p>
<ul>
<li><code>DEST &lt;- SRC的偏移地址</code></li>
<li>DEST不允许是段寄存器，只能是16位或32位通用寄存器</li>
<li>SRC不允许是立即数、寄存器，必须是存储单元</li>
<li>目的操作数位数和源操作数有效地址长度不同时执行的操作
<img src="assets/2024-11-22-14-12-32.png" alt="目的操作数位数和源操作数有效地址长度不同时执行的操作" /></li>
</ul>
<h5 id="ldsleslfslgslss"><a class="header" href="#ldsleslfslgslss">LDS,LES,LFS,LGS,LSS</a></h5>
<p>将地址指针指向的内存单元内容送寄存器和段寄存器指令</p>
<p><img src="assets/2024-11-22-14-19-52.png" alt="SRC地址指针指向内存的存储情况" /></p>
<ol>
<li>LDS</li>
</ol>
<p>$$LDS \quad DEST,SRC$$</p>
<ul>
<li><code>(SRC) -&gt; DEST</code></li>
<li>偏移地址送至DEST通用寄存器</li>
<li><code>(SRC + 2/4) -&gt; DS</code></li>
<li>段基址送至段寄存器</li>
</ul>
<ol start="2">
<li>LES</li>
</ol>
<p>$$LES \quad DEST,SRC$$</p>
<ul>
<li><code>(SRC) -&gt; DEST</code></li>
<li><code>(SRC + 2/4) -&gt; ES</code></li>
</ul>
<ol start="3">
<li>
<p>LFS,LGS,LSS指令格式类似，不过指定的段寄存器不同</p>
</li>
<li>
<p>说明</p>
</li>
</ol>
<ul>
<li>DEST不允许是段寄存器，只能是16位或32位通用寄存器</li>
<li>SRC不允许是立即数、寄存器，必须是存储单元</li>
</ul>
<h4 id="标志传送指令"><a class="header" href="#标志传送指令">标志传送指令</a></h4>
<p>用于对标志寄存器进行存取操作，都是无操作数指令</p>
<ol>
<li>
<p><code>LAHF</code>: <code>(FLAGS低8位) -&gt; AH</code></p>
</li>
<li>
<p><code>SAHF</code>: <code>(AH) -&gt; FLAGS低八位</code></p>
</li>
<li>
<p><code>PUSHF/PUSHFD</code>: <code>16位FLAGS入栈/32位FLAGS入栈</code></p>
</li>
<li>
<p><code>POPF/POPFD</code>: <code>16位FLAGS出栈/32位FLAGS出栈</code></p>
</li>
</ol>
<h4 id="类型转换指令"><a class="header" href="#类型转换指令">类型转换指令</a></h4>
<p>将字节、字转换为字、双字，共有4条指令且都是无操作数指令<br />
操作数隐含（在AL或AX或EAX中）</p>
<ol>
<li>CBW（Convert Byte to Word）</li>
</ol>
<p>$$CBW$$</p>
<ul>
<li>字节转换为字</li>
<li>AL最高位置入AH的所有位，AL扩为AX</li>
</ul>
<ol start="2">
<li>CWD/CWDE(Convert Word to Double Word）</li>
</ol>
<p>$$CWD/CWDE$$</p>
<ul>
<li>字转换为双字</li>
<li>CWD
<ul>
<li>AX最高位置入DX的所有位，AX扩为DX:AX</li>
</ul>
</li>
<li>CWDE
<ul>
<li>AX扩展成EAX</li>
</ul>
</li>
</ul>
<ol start="3">
<li>CDQ（Convert Double to Quad）</li>
</ol>
<p>$$CDQ$$</p>
<ul>
<li>双字转换为4字</li>
<li>EAX扩展成EDX：EAX</li>
</ul>
<ol start="4">
<li>BSWAP（Byte SWAP）</li>
</ol>
<p>$$BSWAP REG32$$</p>
<ul>
<li>使指令指定的32位寄存器的字节次序变反</li>
<li>具体操作为：1，4字节互换；2，3字节互换。</li>
</ul>
<blockquote>
<p>该指令只能用于80486及其后继机型</p>
</blockquote>
<h3 id="算数运算类指令"><a class="header" href="#算数运算类指令">算数运算类指令</a></h3>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th><th>操作</th></tr></thead><tbody>
<tr><td>加</td><td>ADD DEST, SRC</td><td>(DEST) + (SRC) → DEST</td></tr>
<tr><td>带进位加</td><td>ADC DEST, SRC</td><td>(DEST) + (SRC) + (CF) → DEST</td></tr>
<tr><td>减</td><td>SUB DEST, SRC</td><td>(DEST) - (SRC) → DEST</td></tr>
<tr><td>带借位减</td><td>SBB DEST, SRC</td><td>(DEST) - (SRC) - (CF) → DEST</td></tr>
<tr><td>比较</td><td>CMP DEST, SRC</td><td>(DEST) - (SRC)</td></tr>
</tbody></table>
</div>
<blockquote>
<p>CMP指令后往往跟条件转移指令，根据比较结果产生不同分支</p>
</blockquote>
<ul>
<li>影响所有标志位(ZF,SF,CF,OF,PF,AF)</li>
<li>DEST不能是立即数</li>
<li>不允许两存储单元操作</li>
</ul>
<ol>
<li>ADD举例</li>
</ol>
<p><img src="assets/2024-11-22-14-49-02.png" alt="ADD举例" /></p>
<ul>
<li>ZF(零) = 0</li>
<li>OF(溢出) = 0</li>
<li>PF(奇数个1) = 0</li>
</ul>
<blockquote>
<p>OF表示带符号数的溢出，CF表示无符号数的溢出</p>
</blockquote>
<ol start="2">
<li>SUB举例</li>
</ol>
<p><img src="assets/2024-11-22-14-52-58.png" alt="SUB举例" /></p>
<ul>
<li>ZF = 0</li>
<li>OF = 0</li>
<li>PF = 1</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th><th>操作</th></tr></thead><tbody>
<tr><td>交换并相加</td><td>XADD DEST,SRC</td><td>（DEST）+（SRC）→TEMP;（DEST →SRC;（TEMP）→DEST</td></tr>
</tbody></table>
</div>
<ul>
<li>SRC只能用寄存器寻址⽅式</li>
<li>DEST可用寄存器或任⼀种存储器寻址⽅式</li>
<li>对标志位的影响同ADD指令</li>
<li>只能用于80486及其后继机型</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th><th>操作</th></tr></thead><tbody>
<tr><td>加1</td><td>INC OPR</td><td>(OPR) + 1 → OPR</td></tr>
<tr><td>减1</td><td>DEC OPR</td><td>(OPR) - 1 → OPR</td></tr>
</tbody></table>
</div>
<ul>
<li>不影响CF，其余影响</li>
<li>OPR不允许是立即数、段寄存器</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th><th>操作</th></tr></thead><tbody>
<tr><td>求补</td><td>NEG OPR</td><td>0 - (OPR) → OPR</td></tr>
</tbody></table>
</div>
<ul>
<li>影响所有标志</li>
<li>OPR不允许是立即数、段寄存器</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th></tr></thead><tbody>
<tr><td>比较并交换指令</td><td>CMPXCHG DEST,SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>操作</p>
<ul>
<li>累加器AC与（DEST）相比较（相减）</li>
<li>如果相等，则1→ ZF，（SRC）→ DEST ；</li>
<li>否则 0→ ZF ， （DEST） → AC</li>
</ul>
</li>
<li>
<p>累加器可为AL、AX或EAX寄存器</p>
</li>
<li>
<p>SRC只能用8位、16位或32位寄存器</p>
</li>
<li>
<p>DEST则可用寄存器或存储单元</p>
</li>
<li>
<p>该指令只能用于80486及其后继机型</p>
</li>
<li>
<p>该指令对其他标志位的影响与CMP指令相同</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th></tr></thead><tbody>
<tr><td>比较并交换8字节指令</td><td>CMPXCHG8B DEST</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>操作</p>
<ul>
<li>EDX：EAX与DEST相比较，64位数比较</li>
<li>如果相等，则 1→ ZF，（ EDX：EAX ）→ DEST</li>
<li>否则 0→ ZF ，（DEST）→EDX：EAX</li>
</ul>
</li>
<li>
<p>该指令只影响ZF位，但不影响其他标志位</p>
</li>
<li>
<p>该指令只能用于Pentium及其后继机型</p>
</li>
<li>
<p>操作数均为64位数，目的操作数必须采用存储器寻址⽅式确定⼀个64位数</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th></tr></thead><tbody>
<tr><td>无符号乘法</td><td>MUl SRC</td></tr>
<tr><td>带符号乘法</td><td>IMUL SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>操作</p>
<ul>
<li>字节：<code>(AL)*(SRC)→(AX)</code></li>
<li>字：<code>(AX)*(SRC)→(DX:AX)</code></li>
<li>双字：<code>(EAX)*(SRC)→(EDX:EAX)</code></li>
</ul>
<blockquote>
<p>隐含另一操作数在累加器中</p>
</blockquote>
</li>
<li>
<p>影响CF、OF,其余无定义</p>
</li>
<li>
<p>SRC为寄存器或用byte_ptr或word_ptr指明的存储单元</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>指令</th></tr></thead><tbody>
<tr><td>无符号除法</td><td>DIV SRC</td></tr>
<tr><td>带符号除法</td><td>IDIV SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>操作</p>
<ul>
<li>除数为字节：<code>(AX)/(SRC)→ 商(AL)余数(AH)</code></li>
<li>除数为字：<code>(DX:AX)/(SRC)→ 商(AX)余数(DX)</code></li>
<li>除数为字：<code>(EDX:EAX)/(SRC)→ 商(EAX)余数(EDX)</code></li>
</ul>
<blockquote>
<p>隐含被除数在EDX/EAX/DX/AX中</p>
</blockquote>
</li>
<li>
<p>对标志位无定义</p>
</li>
<li>
<p>SEC为寄存器或用byte_ptr或word_ptr指明的存储单元</p>
</li>
</ul>
<!-- NOTE: BCD码校正指令跳过 -->
<h3 id="逻辑类指令"><a class="header" href="#逻辑类指令">逻辑类指令</a></h3>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>指令格式</th></tr></thead><tbody>
<tr><td>与</td><td>AND DEST, SRC</td></tr>
<tr><td>或</td><td>OR DEST, SRC</td></tr>
<tr><td>异或</td><td>XOR DEST, SRC</td></tr>
<tr><td>测试</td><td>TEST DEST, SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>将CF、OF置0，影响SF，ZF，ZF</li>
<li>SRC可以是立即数，REG和MEM，字/字节/双字</li>
<li>DEST允许是ERG,MEM</li>
<li>不允许两存储单元操作</li>
</ul>
<ol>
<li>测试TEST</li>
</ol>
<p><code>(DEST)Λ(SRC)</code>，相与，结果不保存,ZF</p>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>指令格式</th></tr></thead><tbody>
<tr><td>非</td><td>NOT OPR</td></tr>
</tbody></table>
</div>
<ul>
<li>不影响标志位</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>指令</th><th>格式</th><th>功能描述</th></tr></thead><tbody>
<tr><td>BT</td><td><code>BT DEST, SRC</code></td><td>把 <code>DEST</code> 中由 <code>SRC</code> 指定位的值送往标志位 <code>CF</code></td></tr>
<tr><td>BTS</td><td><code>BTS DEST, SRC</code></td><td>完成 <code>BT</code> 功能外，将 <code>DEST</code> 中的指定位置 1</td></tr>
<tr><td>BTR</td><td><code>BTR DEST, SRC</code></td><td>完成 <code>BT</code> 功能外，将 <code>DEST</code> 中的指定位置 0</td></tr>
<tr><td>BTC</td><td><code>BTC DEST, SRC</code></td><td>完成 <code>BT</code> 功能外，将 <code>DEST</code> 中的指定位取反</td></tr>
</tbody></table>
</div>
<ul>
<li>SRC是十进制数</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>指令格式</th></tr></thead><tbody>
<tr><td>正向位扫描</td><td>BSF REG，SRC</td></tr>
<tr><td>反向位扫描</td><td>BSR REG，SRC</td></tr>
</tbody></table>
</div>
<ul>
<li>指令从位0开始自右向左扫描源操作数(反向位扫描则相反)，目的是检索第一个为1的位。</li>
<li>如遇到第一个为1的位则将ZF位置0，并把该位的位置装入目的寄存器中；</li>
<li>如源操作数为0，则将ZF位置1，目的寄存器无定义。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>指令</th><th>格式</th><th>功能描述</th></tr></thead><tbody>
<tr><td>SHL</td><td><code>SHL OPR, CNT</code></td><td>逻辑左移：最高位移入 <code>CF</code>，空出的位补 <code>0</code></td></tr>
<tr><td>SHR</td><td><code>SHR OPR, CNT</code></td><td>逻辑右移：最低位移入 <code>CF</code>，空出的位补 <code>0</code></td></tr>
<tr><td>SAL</td><td><code>SAL OPR, CNT</code></td><td>算术左移：最高位移入 <code>CF</code>，补 <code>0</code></td></tr>
<tr><td>SAR</td><td><code>SAR OPR, CNT</code></td><td>算术右移：最低位移入 <code>CF</code>，空出的位复制最高位</td></tr>
</tbody></table>
</div>
<ul>
<li>OPR可以是字、字节、双字,在存储单元或REG中</li>
<li>CNT可以是1或CL，指移位次数</li>
</ul>
<blockquote>
<p>对于80386及以后机型，COUNT还可以是8位立即数，可指定1～31的移位次数</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>指令</th><th>格式</th><th>功能描述</th></tr></thead><tbody>
<tr><td>SHLD</td><td><code>SHLD DEST, SRC, COUNT</code></td><td>双精度左移：将 <code>DEST</code> 的内容左移 <code>COUNT</code> 次，同时将 <code>SRC</code> 的高位移入 <code>DEST</code> 的低位，<code>SRC</code> 保持不变</td></tr>
<tr><td>SHRD</td><td><code>SHRD DEST, SRC, COUNT</code></td><td>双精度右移：将 <code>DEST</code> 的内容右移 <code>COUNT</code> 次，同时将 <code>SRC</code> 的低位移入 <code>DEST</code> 的高位，<code>SRC</code> 保持不变</td></tr>
</tbody></table>
</div>
<ul>
<li>80386及其后继机型可用</li>
<li><img src="assets/2024-11-22-15-22-06.png" alt="双精度移位指令图解" /></li>
<li>DEST：字或双字操作数，不允许立即数，REG 或 MEM</li>
<li>SRC：只能使用寄存器寻址方式且与 DEST目的操作数 相同长度的字或双字</li>
<li>COUNT：移位次数，它可以是一个8位的立即数或 CL移位次数的范围应为1～31，对于大于31的数，机器则自动取模32的值来取代。
<ul>
<li>COUNT ＝0，不影响标志位；</li>
<li>COUNT ≠ 0，根据移位后结果设置SF、ZF、PF、CF;
<ul>
<li>COUNT＝1，移位后符号位改变，OF＝1；否则为0</li>
<li>COUNT&gt;1, OF无定义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="串操作指令"><a class="header" href="#串操作指令">串操作指令</a></h3>
<h4 id="串传送指令"><a class="header" href="#串传送指令">串传送指令</a></h4>
<p>$$MOVS DST，SRC$$</p>
<ul>
<li>DST、SRC提供类型(字节or字)</li>
<li>源串首址DS：SI→目的首址ES：DI</li>
<li>SI±1 →SI，DI±1 →DI(字节操作+1，字操作+2;DF＝0时用＋，DF＝1用－)</li>
<li>不影响标志位</li>
</ul>
<p>MOVSB
(已指明是字节)
MOVSW
(已指明是字）</p>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>操作描述</th></tr></thead><tbody>
<tr><td><strong>串传送</strong></td><td><code>MOVS DST, SRC</code></td><td>将<code>SRC</code>的数据传送到<code>DST</code>，通过<code>DS:SI</code>指向源地址，<code>ES:DI</code>指向目标地址。</td></tr>
<tr><td></td><td></td><td><code>SI</code>和<code>DI</code>根据方向标志<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td></td><td></td><td>不影响标志位。</td></tr>
<tr><td><strong>存入串</strong></td><td><code>STOS DST</code></td><td>将累加器（字节: <code>AL</code>，字: <code>AX</code>）存入由<code>ES:DI</code>指向的地址。</td></tr>
<tr><td></td><td></td><td><code>DI</code>根据<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td></td><td></td><td>不影响标志位。</td></tr>
<tr><td><strong>从串取</strong></td><td><code>LODS SRC</code></td><td>将<code>DS:SI</code>指向的值加载到累加器（字节: <code>AL</code>，字: <code>AX</code>）。</td></tr>
<tr><td></td><td></td><td><code>SI</code>根据<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td></td><td></td><td>不影响标志位。</td></tr>
<tr><td><strong>串比较</strong></td><td><code>CMPS DST, SRC</code></td><td>比较<code>DS:SI</code>指向的值和<code>ES:DI</code>指向的值(相减)，并影响标志位（<code>OF/SF/ZF/CF/PF/AF</code>）。</td></tr>
<tr><td></td><td></td><td><code>SI</code>和<code>DI</code>根据<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td><strong>串扫描</strong></td><td><code>SCAS DST</code></td><td>比较累加器（字节: <code>AL</code>，字: <code>AX</code>）与<code>ES:DI</code>指向的值(相减)，影响标志位（<code>OF/SF/ZF/CF/PF/AF</code>）。</td></tr>
<tr><td></td><td></td><td><code>DI</code>根据<code>DF</code>调整：字节操作±1，字操作±2。</td></tr>
<tr><td><strong>方向标志</strong></td><td><code>CLD</code></td><td>设置方向标志<code>DF=0</code>，用于递增操作。</td></tr>
<tr><td></td><td><code>STD</code></td><td>设置方向标志<code>DF=1</code>，用于递减操作。</td></tr>
</tbody></table>
</div><!-- TODO: 到这里有点累了，歇歇 -->
<h3 id="程序转移类指令"><a class="header" href="#程序转移类指令">程序转移类指令</a></h3>
<p>执行指令的地址由CS:IP决定</p>
<ul>
<li>顺序执行时，IP的值根据指令的长度依次递增</li>
<li>转移时
<ul>
<li>若在同一段中，改变IP的值，CS不变；</li>
<li>若转向不同的段，改变CS和IP的值</li>
</ul>
</li>
</ul>
<h4 id="无条件转移"><a class="header" href="#无条件转移">无条件转移</a></h4>
<p>JMP 目标；转到目标处执行程序, 对标志位无影响</p>
<ul>
<li>标号</li>
<li>标会+常数</li>
<li>寄存器</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>指令格式</th><th>功能描述</th></tr></thead><tbody>
<tr><td>段内直接短转移</td><td><code>JMP SHORT OPR</code></td><td>(IP)+由OPR决定的8位位移量→(IP)</td></tr>
<tr><td>段内直接近转移</td><td><code>JMP NEAR PTR OPR</code></td><td>(IP)+由OPR决定的16位位移量→(IP)</td></tr>
<tr><td>段内间接近转移</td><td><code>JMP WORD PTR OPR</code></td><td>由OPR寻址方式决定的有效地址→(IP)</td></tr>
<tr><td>段间直接远转移</td><td><code>JMP FAR PTR OPR</code></td><td>OPR在段内的偏移量→(IP);OPR所在的段地址→(CS)</td></tr>
<tr><td>段间间接远转移</td><td><code>JMP DWORD PTR OPR</code></td><td>(EA)→(IP)(EA+2)→(CS) EA由OPR决定</td></tr>
</tbody></table>
</div>
<h4 id="条件转移"><a class="header" href="#条件转移">条件转移</a></h4>
<p>$$JXX \quad 目标$$</p>
<ul>
<li>条件XX满足，转到目标处执行程序；</li>
<li>条件XX不满足，顺序执行程序。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>等效助记符</th><th>测试条件</th></tr></thead><tbody>
<tr><td>结果为0或相等</td><td><code>JZ OPR</code></td><td><code>JE</code></td><td><code>ZF=1</code> 转移</td></tr>
<tr><td>结果为负</td><td><code>JS OPR</code></td><td>无</td><td><code>SF=1</code> 转移</td></tr>
<tr><td>溢出</td><td><code>JO OPR</code></td><td>无</td><td><code>OF=1</code> 转移</td></tr>
<tr><td>有进位</td><td><code>JC OPR</code></td><td><code>JB, JNAE</code></td><td><code>CF=1</code> 转移</td></tr>
<tr><td>奇数个1</td><td><code>JP OPR</code></td><td><code>JPE</code></td><td><code>PF=1</code> 转移</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>等效助记符</th><th>测试条件</th></tr></thead><tbody>
<tr><td>非0或不等</td><td><code>JNZ OPR</code></td><td><code>JNE</code></td><td><code>ZF=0</code> 转移</td></tr>
<tr><td>结果为正</td><td><code>JNS OPR</code></td><td>无</td><td><code>SF=0</code> 转移</td></tr>
<tr><td>非溢出</td><td><code>JNO OPR</code></td><td>无</td><td><code>OF=0</code> 转移</td></tr>
<tr><td>无进位</td><td><code>JNC OPR</code></td><td><code>JNB, JAE</code></td><td><code>CF=0</code> 转移</td></tr>
<tr><td>偶数个1</td><td><code>JNP OPR</code></td><td><code>JPO</code></td><td><code>PF=0</code> 转移</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>等效助记符</th><th>测试条件</th></tr></thead><tbody>
<tr><td>大于或不小于且≠转移</td><td><code>JA OPR</code></td><td><code>JNBE</code></td><td><code>CF=0 且 ZF=0</code></td></tr>
<tr><td>大于等于或不小于转移</td><td><code>JAE OPR</code></td><td><code>JNB</code></td><td><code>CF=0 或 ZF=0</code></td></tr>
<tr><td>小于或不大于且≠转移</td><td><code>JB OPR</code></td><td><code>JNAE</code></td><td><code>CF=1 且 ZF=0</code></td></tr>
<tr><td>小于等于或不大于转移</td><td><code>JBE OPR</code></td><td><code>JNA</code></td><td><code>CF=1 或 ZF=0</code></td></tr>
</tbody></table>
</div>
<ul>
<li>比较两个无符号数，并根据结果转移</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>格式</th><th>等效助记符</th><th>测试条件</th></tr></thead><tbody>
<tr><td>大于或不小于且≠转移</td><td><code>JG OPR</code></td><td><code>JNLE</code></td><td><code>ZF=0 且 SF⊕OF=0</code></td></tr>
<tr><td>大于等于或不小于转移</td><td><code>JGE OPR</code></td><td><code>JNL</code></td><td><code>ZF=1 或 SF⊕OF=0</code></td></tr>
<tr><td>小于或不大于且≠转移</td><td><code>JL OPR</code></td><td><code>JNGE</code></td><td><code>ZF=0 且 SF⊕OF=1</code></td></tr>
<tr><td>小于等于或不大于转移</td><td><code>JLE OPR</code></td><td><code>JNG</code></td><td><code>ZF=1 或 SF⊕OF=1</code></td></tr>
</tbody></table>
</div>
<ul>
<li>比较两个带符号数，并根据结果转移</li>
</ul>
<h4 id="循环控制"><a class="header" href="#循环控制">循环控制</a></h4>
<ol>
<li>LOOP</li>
</ol>
<p>$$LOOP \quad 标号$$</p>
<ul>
<li>(CX)－1→(CX)</li>
<li>若(CX)≠0 ,从标号处继续循环;若(CX)＝0 , 退出循环</li>
</ul>
<p>相当于</p>
<ul>
<li>DEC CX</li>
<li>JNZ 标号</li>
</ul>
<ol start="2">
<li>为 0/ 相等时循环
$$LOOPE \quad 标号$$</li>
</ol>
<ul>
<li>(CX)－1→(CX)</li>
<li>(CX)≠0且ZF＝1 ,转至标号处继续循环;若(CX)＝0 或ZF＝0, 顺序执行</li>
</ul>
<ol start="3">
<li>非 0/ 不等时循环
$$LOOPNE \quad 标号$$</li>
</ol>
<ul>
<li>(CX)－1→(CX)</li>
<li>(CX)≠0且ZF＝0 ,转至标号处继续循环;若(CX)＝0 或ZF＝1, 顺序执行</li>
</ul>
<ol start="4">
<li>按 CX 循环</li>
</ol>
<p>$$JCXZ \quad 标号$$</p>
<ul>
<li>(CX)＝0 ,转至标号处继续循环</li>
</ul>
<ol start="5">
<li>说明</li>
</ol>
<ul>
<li>循环指令不影响标志位</li>
<li>隐含(CX)－1操作</li>
<li>LOOP指令按循环次数决定是否结束循环</li>
<li>LOOPZ和LOOPNZ提供了提前结束循环的可能，常跟在比较指令之后</li>
<li>JCXZ常用于循环初值为0而发生循环的情况</li>
</ul>
<h3 id="处理机控制类指令"><a class="header" href="#处理机控制类指令">处理机控制类指令</a></h3>
<div style="break-before: page; page-break-before: always;"></div><p>第五章、汇编语言层</p>
<p>[toc]</p>
<p>在第3章中介绍的微体系结构层，可看作是为第四章的指令系统层提供了一个解释器，使指令系统的功能得以实现。</p>
<p>但是，直接用机器指令代码编程是非常困难的，而让微体系结构层直接执行高级语言也不是好办法。因此，人们为所有的计算机都设计了一个汇编语言层，它位于指令系统层、操作系统层与面向问题语言层之间。</p>
<p>从这一层看去，每一种计算机都有一套自己的汇编语言和解释它的汇编器，以及相应的程序设计及开发方法。</p>
<p>本章所讨论的汇编语言级程序设计是以80x86 CPU为硬件背景，以MASM 5.0～MASM 6.0为“汇编”环境。</p>
<h1 id="1-概述"><a class="header" href="#1-概述">1. 概述</a></h1>
<p>在计算机中，为使CPU能按照人们的设想去加工处理这些信息，就必须让计算机连续地执行有序的机器指令序列，即运行用中央处理器指令系统中的指令代码（即二进制代码）编制的程序。用计算机指令代码编制的程序称为机器语言程序，这种程序是计算机实现各种运算处理功能的最终目标代码。</p>
<p>汇编语言是一种面向机器结构的低级程序设计语言，它把由机器指令组成的机器语言程序“符号化”</p>
<blockquote>
<p>也就是说，汇编语言程序中每一条指令语句都与机器语言程序的每一条机器指令一一对应。</p>
</blockquote>
<p>从目标代码的长度和程序运行的时间来看，用汇编语言编制的程序与用机器指令编制的机器语言程序是一样的</p>
<p>汇编语言程序也是一种符号式的程序，用汇编语言编制的程序称为汇编语言源程序，这个源程序仍然不能由计算机直接执行，必须经过汇编程序（Assembler）“汇编”（即翻译）成目标代码后才能直接由计算机执行。</p>
<h1 id="2-汇编语句格式"><a class="header" href="#2-汇编语句格式">2. 汇编语句格式</a></h1>
<p>语句（Statements）是汇编语言程序的基本组成单位。在汇编语言源程序中有三种语句</p>
<ul>
<li>指令语句</li>
<li>伪指令语句</li>
<li>宏指令语句（或宏调用语句）</li>
</ul>
<h2 id="指令与伪指令"><a class="header" href="#指令与伪指令">指令与伪指令</a></h2>
<p>指令语句就是第4章中所述的80x86 CPU指令系统中的各条指令。每一条指令语句在源程序汇编时都要产生相应的、可供计算机执行的指令代码（即目标代码），所以这种语句又称为可执行语句。</p>
<p>伪指令语句用于指示（命令）汇编程序对源程序如何汇编，除其所定义的具体数据要生成目标代码外，其他项均没有对应的目标代码。</p>
<p>指令语句和伪指令语句有相同的语句格式，每条语句均由如下4个字段（Fields）组成：
$$名字 \quad 操作符 \quad 操作数 \quad ; \quad 注释$$</p>
<h3 id="名字字段name-field"><a class="header" href="#名字字段name-field">名字字段(Name Field)</a></h3>
<ul>
<li>指令语句中: 这个字段叫标号，用冒号<code>:</code>作为名字字段的结束符
<ul>
<li>标号是一条指令的符号地址，它代表该指令代码的第一个字节单元地址。</li>
</ul>
</li>
<li>伪指令语句中: 对于不同的伪指令这个字段的名字有所不同，后面用空格<code> </code>作为结束符
<ul>
<li>伪指令语句的这些名字，有的代表一个具体常数值，有的作为存储单元的符号地址。它们都可以在指令语句和伪指令语句的操作数字段中直接加以引用。</li>
</ul>
</li>
</ul>
<p>名字字段的名字统称为标识符，组成规则如下：</p>
<ul>
<li>字符个数为1-31个</li>
<li>可包含字母，数字，问号，@和下划线，不能以数字开头</li>
<li>不能使用保留字</li>
</ul>
<h3 id="操作符字段operator-field"><a class="header" href="#操作符字段operator-field">操作符字段(Operator Field)</a></h3>
<ul>
<li>指令语句中: 这个字段就是指令助记符，表示程序在运行时CPU完成的操作功能。</li>
<li>伪指令中: 这个字段就是本章后面将要介绍的各种伪指令，表示汇编程序如何汇编（翻译）源程序各条语句。
<blockquote>
<p>如数据定义伪指令DB、DW、DD；段定义伪指令SEGMENT；过程定义伪指令PROC等</p>
</blockquote>
</li>
</ul>
<h3 id="操作数字段operand-field"><a class="header" href="#操作数字段operand-field">操作数字段(Operand Field)</a></h3>
<ul>
<li>本字段与操作符字段用空格<code> </code>或制表符<code>Tab</code>作为分界符</li>
<li>如果本字段要求有两个或两个以上操作数，那么各操作数之间用逗号<code>,</code>或空格<code> </code>分隔。</li>
</ul>
<h3 id="注释字段comment-field"><a class="header" href="#注释字段comment-field">注释字段(Comment Field)</a></h3>
<p>必须以分号<code>;</code>作为字段的开始符</p>
<blockquote>
<p>一条语句可以只有注释字段，此时该语句以分号<code>;</code>开始</p>
</blockquote>
<h1 id="3-80x86宏汇编语言数据"><a class="header" href="#3-80x86宏汇编语言数据">3. 80x86宏汇编语言数据</a></h1>
<p>在指令语句和伪指令语句中，操作数字段的主要内容是数据。宏汇编语言数据通常包含数值和属性两部分，这两部分对一条语句汇编成目标代码都有着直接关系。80x86宏汇编语言能识别的数据有：常数、变量和标号。</p>
<h2 id="31-常数"><a class="header" href="#31-常数">3.1 常数</a></h2>
<p>常数是没有任何属性的纯数值数据，在汇编源程序期间，它的值已能完全确定，且在程序运行中，它也不会发生变化。</p>
<h3 id="数值常数"><a class="header" href="#数值常数">数值常数</a></h3>
<p>可以用不同进制数的形式表示数值常数</p>
<ol>
<li>二进制</li>
</ol>
<p>以字母B结尾的0和1组成的数字序列</p>
<ol start="2">
<li>八进制</li>
</ol>
<p>以字母O或Q结尾的0～7数字序列组成的数</p>
<ol start="3">
<li>十进制</li>
</ol>
<p>0～9数字序列组成的数，可以用字母D结尾，也可以没有结尾字母</p>
<ol start="4">
<li>十六进制数</li>
</ol>
<p>以字母H结尾的0～9和A～F（或a～f）数字字母序列组成的数</p>
<p>凡以字母A～F（或a～f）为起始的十六进制数，必须在前面冠以数字0，否则汇编程序认作符号。</p>
<h3 id="字符常数"><a class="header" href="#字符常数">字符常数</a></h3>
<p>用单引号或双引号括起来的一个或多个字符，这些字符用它的ASCII码形式存储在存储单元中。</p>
<h2 id="32-变量"><a class="header" href="#32-变量">3.2 变量</a></h2>
<p>变量代表存放在存储单元中的数据，并作为存储数据单元的符号地址。</p>
<h3 id="321-变量的定义与预置"><a class="header" href="#321-变量的定义与预置">3.2.1 变量的定义与预置</a></h3>
<p>定义变量就是分配存储单元，这些存储单元可以预置数据初值或仅保留若干存储单元。定义与预置变量的语句格式如下：</p>
<p>$$变量名 \quad &lt;数据定义伪指令&gt; \quad &lt;表达式1&gt;,&lt;表达式2&gt;,...$$</p>
<ol>
<li>变量名是任选的</li>
</ol>
<p>变量名是任选的</p>
<ul>
<li>若选用变量名，那么它就是这些存储单元中首字节单元的符号地址</li>
<li>在程序中访问这些存储单元时，就可以直接引用这个变量名。</li>
</ul>
<ol start="2">
<li>数据定义伪指令</li>
</ol>
<p>数据定义伪指令有：DB、DW和DD，它们用来定义字节、字和双字数据。</p>
<p>可以用DQ和DT来定义8和10字节的数据。80386及其以上机型中还可用DF来定义6字节数据。DW和DD伪指令还可定义存储地址，而DF伪指令可定义存储由16位段基值和32位偏移地址组成的地址指针。</p>
<p>经过定义后的变量（变量名），它们拥有一下三个属性</p>
<ul>
<li>
<p>段属性（SEG）</p>
<p>段属性表示变量存放在哪一个逻辑段中。</p>
</li>
<li>
<p>偏移地址属性（OFFSET）</p>
<p>偏移地址属性表示变量在逻辑段中离段起始单元的距离（字节数）。</p>
</li>
</ul>
<blockquote>
<p>段和偏移地址两个属性就构成一个变量的逻辑地址</p>
</blockquote>
<ul>
<li>
<p>类型属性（TYPE）</p>
<p>类型属性表示一个变量的数据大小，是字节（8位二进制数）、字（16位二进制数）、双字（32位二进制数）数据，或是6字节、8字节、10字节数据。这一属性是由数据定义伪指令DB、DW、DD、DF、DQ、DT来确定的。</p>
</li>
</ul>
<ol start="3">
<li>表达式</li>
</ol>
<p>数据定义伪指令（DB、DW等）在为数据分配存储单元的同时，还可以给这些存储单元预置初值，每个初值由相应的表达式确定。定义变量语句中表达式可以有如下4种情况：</p>
<ul>
<li>
<p>数值表达式</p>
<ul>
<li>在单一的存储单元，中设置一个数据
<blockquote>
<p>如<code>var DB 50H</code></p>
</blockquote>
</li>
<li>在连续的若干存储单元中设置数据，使用逗号将值隔开
<blockquote>
<p>如<code>var DB 50H,20H</code></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>字符串表达式</p>
<ul>
<li>字符串表达式中的字符串必须用引号（单引号或双引号）括起来</li>
<li>字符串中各字符均以ASCII码形式存放在相应的存</li>
<li>字符串表达式的表示方法和存储顺序：
<ul>
<li>
<p>在DB伪指令中</p>
<ul>
<li>一个字符串表达式可以连续书写少于255个的字符</li>
<li>每一个字符分配一个字节存储单元，按地址递增的排列顺序依次存放字符串自左至右的每一个字符</li>
</ul>
</li>
<li>
<p>DW伪指令中</p>
<ul>
<li>一个字符串表达式只能由1～2个字符组成</li>
<li>DW伪指令为每一个字符串表达式分配两个字节存储单元</li>
<li>如果表达式由两个字符组成，前一个字符的ASCII码存放在高字节中，后一个字符的ASCII码存放在低字节中。</li>
<li>如果表达式由一个字符组成，那么该字存储单元的高字节存放00，而唯一字符的ASCII码存放在低字节存储单元中。</li>
</ul>
</li>
<li>
<p>DD伪指令中</p>
<ul>
<li>一个字符串表达式也只能由1～2个字符组成</li>
<li>为每个表达式分配4字节的存储单元</li>
<li>两个低字节存储单元存放这1～2个字符的ASCII码（存储的顺序与DW伪指令相同），另外两个高字节存储单元均自动存放00。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="assets/2024-11-16-12-06-56.png" alt="使用不同的伪指令存储字符串&#39;string&#39;" /></p>
<ul>
<li>
<p>？表达式</p>
<ul>
<li>表示仅分配相应数量的存储单元</li>
</ul>
</li>
<li>
<p>带DUP表达式</p>
<ul>
<li>重复数据操作符DUP（Duplication），其格式如下
$$变量名 \quad &lt;数据定义伪指令&gt; \quad &lt;表达式1&gt; \quad DUP \quad (&lt;表达式2&gt;)$$
<ul>
<li>表达式1是重复的次数</li>
<li>表达式2是重复数据的内容。</li>
</ul>
<blockquote>
<p>DUP操作符可以嵌套使用</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="322-变量的使用"><a class="header" href="#322-变量的使用">3.2.2 变量的使用</a></h3>
<p>变量定义和预置后才可以使用。对变量的使用就是对变量名的引用。在程序的其他语句中，对变量名的使用通常分两种情况:</p>
<ol>
<li>在指令语句的操作数字段中</li>
</ol>
<p>引用的变量名作为地址表达式的组成部分之一。</p>
<ol start="2">
<li>数据定义语句的操作数字段上引用了变量名</li>
</ol>
<p>在为DW或DD伪指令分配的存储单元中，将预置被引用变量名的地址部分</p>
<blockquote>
<p>即存储引用变量的地址</p>
</blockquote>
<ul>
<li>如是DW，则仅有被引用变量名的偏移地址；</li>
<li>如是DD，则前两个字节存放偏移地址，后两个字节存放段基值。</li>
</ul>
<h2 id="33-编号"><a class="header" href="#33-编号">3.3 编号</a></h2>
<p>标号是一条指令的符号地址。</p>
<p>在无条件转移指令、条件转移指令和循环指令的操作数位置上，通常用标号作为程序转移指令的目标地址。</p>
<p>与变量一样，每个标号也具有3个属性：</p>
<ol>
<li>段属性（SEG）</li>
</ol>
<p>表示指令在哪个逻辑段中</p>
<ol start="2">
<li>偏移地址属性（OFFSET）</li>
</ol>
<p>表示这条指令离段起始单元之间的字节数（准确地讲，是这条指令目标代码的首字节单元与段起始单元之间的字节数）</p>
<blockquote>
<p>上述两个属性构成了这条指令的逻辑地址</p>
</blockquote>
<ol start="3">
<li>类型属性（TYPE）</li>
</ol>
<p>表示它的转移特性，即该标号是作为段内转移指令还是段间转移指令的目标地址。</p>
<ul>
<li>NEAR（近）: 表示段内转移，本标号只能作为标号所在段的转移指令的目标地址。</li>
<li>FAR（远）: 表示段间转移，本标号可作为其他段（不是标号所在段）的转移指令的目标地址。</li>
</ul>
<p>标号的类型属性可以用下面两种方法来设置：</p>
<ul>
<li>
<p>隐含方式</p>
<p>当某指令语句选用一个标号后，该标号就隐含为NEAR属性(缺省)</p>
</li>
<li>
<p>使用LABEL伪命令</p>
<ul>
<li>LABEL伪指令语句格式如下：
$$名字 \quad LABEL \quad 类型$$</li>
<li>与指令语句连用时，LABEL语句中的名字就是一个新的标号，其类型可选择NEAR或FAR</li>
<li>当与数据定义语句连用时，LABEL语句中的名字就是一个新的变量名，其类型可选择BYTE，WORD或DWORD。</li>
<li>这个新的标号或变量名，与它们连用的指令语句的标号或数据定义语句的变量名有相同的段和偏移地址属性，即与它连用的语句有相同的逻辑地址。只是类型不同，存取控制方式不同</li>
</ul>
</li>
</ul>
<h2 id="34-表达式与运算符"><a class="header" href="#34-表达式与运算符">3.4 表达式与运算符</a></h2>
<p>表达式由常数、变量和标号通过某些运算符连接而成的。</p>
<p>任一表达式的数据计算或操作类型（指数据的大小、转移特性等）的确定是在汇编源程序过程中完成的，不是在程序运行时获得的。</p>
<p>80x86宏汇编语言程序设计</p>
<ul>
<li>可使用的表达式有两种：数值表达式和地址表达式。</li>
<li>表达式中的运算符有：算术运算符、逻辑运算符、关系运算符、数值返回运算符和属性修改运算符。</li>
</ul>
<h3 id="算数运算符"><a class="header" href="#算数运算符">算数运算符</a></h3>
<ul>
<li>
<p>+（加）</p>
</li>
<li>
<p>− （减）</p>
<p>减法可用于同段两个操作数地址（以变量名表示）的运算，其结果是一个常数，表示这两个地址之间的相距字节数。</p>
</li>
<li>
<p>*（乘）</p>
</li>
<li>
<p>/（除）</p>
<p>除法运算只取商的整数部分</p>
</li>
<li>
<p>MOD（模除）</p>
<p>MOD运算符是进行整数除法，运算结果只取它的余数部分。</p>
</li>
<li>
<p>SHL（左移）</p>
</li>
<li>
<p>SHR（右移）</p>
</li>
</ul>
<blockquote>
<p>+、−、*、/运算中，参加运算的数和运算的结果均是整数。</p>
</blockquote>
<h3 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h3>
<ul>
<li>AND（逻辑与）</li>
<li>OR（逻辑或）</li>
<li>NOT（逻辑非）</li>
<li>XOR（逻辑异或）</li>
</ul>
<p>运算符格式：
$$&lt;表达式1&gt; \quad &lt;逻辑运算符&gt; \quad &lt;表达式2&gt;$$
$$NOT \quad &lt;表达式&gt;$$</p>
<blockquote>
<p>逻辑运算符是按位进行逻辑运算的。</p>
</blockquote>
<h3 id="关系运算符"><a class="header" href="#关系运算符">关系运算符</a></h3>
<ul>
<li>EQ（相等）</li>
<li>NE（不等）</li>
<li>LT（小于）</li>
<li>LE（小于等于）</li>
<li>GT（大于）</li>
<li>GE（大于等于）</li>
</ul>
<p>$$&lt;表达式1&gt; \quad &lt;关系运算符&gt; \quad &lt;表达式2&gt;$$</p>
<p>如果比较关系成立，则用全1表示真，否则用全0表示假。</p>
<p>如果比较的是数值表达式，则按无符号数比较；</p>
<p>如果比较的是同段内的地址表达式，则比较它们的偏移地址。</p>
<h3 id="数值返回运算符"><a class="header" href="#数值返回运算符">数值返回运算符</a></h3>
<p>这种运算符的运算对象必须是存储器操作数，即由变量名或标号组成的地址表达式。运算的结果是一个纯数值，这个数值表示该存储器操作数地址的组成部分及其某些特征。数值返回运算符的格式如下：
$$&lt;数值返回运算符&gt; \quad &lt;地址表达式&gt;$$</p>
<ol>
<li>SEG运算符和OFFSET运算符</li>
</ol>
<p>运算符结果分别是这个变量名或标号所在段的段基值或它在段内的偏移地址</p>
<ol start="2">
<li>TYPE运算符</li>
</ol>
<p>TYPE运算符是用数值形式表示变量和标号的类型属性</p>
<p><img src="assets/2024-11-16-12-45-01.png" alt="type运算符返回值所对应的类型" /></p>
<ol start="3">
<li>LENGTH运算符和SIZE运算符</li>
</ol>
<p>如果变量是用重复数据操作符DUP定义的，那么运算符LENGTH的运算结果是外层DUP的重复次数；如果没有用DUP定义的变量，运算结果总是1。</p>
<p>而运算符SIZE是LENGTH和TYPE两个运算结果的乘积。</p>
<h3 id="属性修改运算符"><a class="header" href="#属性修改运算符">属性修改运算符</a></h3>
<p>这种运算符用来对变量、标号或存储器操作数的类型属性进行说明和设定。
$$类型 \quad PTR \quad &lt;地址表达式&gt;$$</p>
<p>把PTR运算符右边地址表达式所确定的存储单元<strong>临时</strong>设定为PTR运算符左边的“类型”（BYTE、WORD、DWORD或NEAR、FAR）。</p>
<h3 id="运算符的优先级"><a class="header" href="#运算符的优先级">运算符的优先级</a></h3>
<p><img src="assets/2024-11-16-12-47-38.png" alt="运算符的优先级表" /></p>
<h1 id="4-80x86宏汇编语言伪指令"><a class="header" href="#4-80x86宏汇编语言伪指令">4. 80x86宏汇编语言伪指令</a></h1>
<h2 id="41-符号定义语句"><a class="header" href="#41-符号定义语句">4.1 符号定义语句</a></h2>
<p>把某些常数或表达式用一个特定符号表示</p>
<h3 id="411-等值语句"><a class="header" href="#411-等值语句">4.1.1 等值语句</a></h3>
<p>$$符号 \quad EQU \quad &lt;表达式&gt;$$</p>
<p>EQU是等值伪指令，把表达式的值或符号赋给EQU左边的符号。</p>
<p>表达式可以是以下三种之一：</p>
<ul>
<li>常数或数值表达式</li>
<li>地址表达式</li>
<li>变量、标号或指令助记符</li>
</ul>
<p>等值伪指令语句定义的符号仅在汇编源程序时作为替代符号使用，不产生任何目标代码，也不占有存储单元。类似于<code>#define</code></p>
<blockquote>
<p>同一符号不能用EQU伪指令重新定义</p>
</blockquote>
<h3 id="412-等号语句"><a class="header" href="#412-等号语句">4.1.2 等号语句</a></h3>
<p>$$符号 \quad = \quad 表达式$$</p>
<p>这种语句的含义和表达式的内容都与等值语句相同，不同的是等号语句</p>
<ul>
<li>可以重新定义符号</li>
<li>不能为指令助记符定义别名</li>
</ul>
<h2 id="42-处理器选择伪指令"><a class="header" href="#42-处理器选择伪指令">4.2 处理器选择伪指令</a></h2>
<p>作用：确定使用的指令系统</p>
<blockquote>
<p>缺省默认只使用8086/8088指令系统和8087协处理器指令集。</p>
</blockquote>
<p>处理器选择伪指令通常是放在源程序的开头位置，格式：
$$. \quad 目标处理器代号$$</p>
<blockquote>
<p>在程序中某处要使用一条286，386，486或586所增加的指令，那么可以在这条指令语句前加上处理器选择伪指令。</p>
</blockquote>
<h2 id="43-段结构伪指令segmentends"><a class="header" href="#43-段结构伪指令segmentends">4.3 段结构伪指令（SEGMENT/ENDS）</a></h2>
<p>在编制一个80x86汇编语言源程序时，段是基础。这有两方面的含义</p>
<ul>
<li>一是必须按段来构造程序</li>
<li>二是在程序执行时，要凭借几个段寄存器对各个段的存储单元进行访问。</li>
</ul>
<h3 id="431-段定义伪指令"><a class="header" href="#431-段定义伪指令">4.3.1 段定义伪指令</a></h3>
<pre><code class="language-asm">段名 SEGMENT [定位类型] [组合类型] [使用类型] ['类别名']
    ...
    ...
段名 ENDS
</code></pre>
<p>每一个段都以SEGMENT伪指令开始，以ENDS伪指令结束，在这两个伪指令之间可以编写各种语句序列。在SEGMENT伪指令中有几个参数可供选择。</p>
<ol>
<li>段名</li>
</ol>
<p>段名由用户自己选定，必须选用，且开始与结尾的段名应一致。</p>
<ol start="2">
<li>定位类型（Align Type）</li>
</ol>
<p>定位类型表示该段装入内存时，对段起始边界的要求。定位类型有下列4种选择：</p>
<ul>
<li>
<p>PAGE（页）
表示本段从一个页的边界开始。从存储器0号单元开始，每256字节为一页。所以段的起始地址一定能被256整除。</p>
<blockquote>
<p>这样段的起始地址（即段基址）的最后8位二进制数一定为0（即以00H结尾）。</p>
</blockquote>
</li>
<li>
<p>PARA（节）（缺省）</p>
<p>表示本段从一个小节的边界开始（一个小节为16字节）。所以段的起始地址一定能被16整除，最后4位二进制数一定为0</p>
</li>
<li>
<p>WORD（字）</p>
<p>表示本段从一个偶字节地址开始。段起始地址的最后1位二进制数一定是0</p>
</li>
<li>
<p>BYTE（字节）</p>
<p>表示本段起始地址可从任一地址开始。即前一个段结束就可设置本段，在两个段之间不留空单元。</p>
</li>
</ul>
<ol start="2">
<li>组合类型(Combine Type)</li>
</ol>
<p>组合类型指定段与段之间是怎样连接和定位的。这种类型有6种可供选择：</p>
<ul>
<li>
<p>NONE(缺省)</p>
<p>表示本段与其他段无连接关系，按照源程序中各个逻辑段的自然顺序依次在存储器中分配各段存储单元。</p>
</li>
<li>
<p>PUBLIC</p>
<p>满足定位类型的前提下，本段与其他有相同段名、且也用PUBLIC说明的段在存储单元分配时邻接在一起，形成一个新的逻辑段，公用一个段基址。所有存储单元的偏移地址都调整为相对于新逻辑段的起始地址。</p>
</li>
<li>
<p>COMMON</p>
<p>产生一个覆盖段。表示本段与其他有相同段名、且也用COMMON说明的段设置相同的起始地址，共享相同的存储区。共享存储区的长度由同名段中最大的段确定。</p>
</li>
<li>
<p>STACK</p>
<p>自动产生一个堆栈段。把所有相同段名的段连接在一起，形成一个新的逻辑段。系统自动对段寄存器SS初始化为新逻辑段的起始地址，并同时初始化堆栈指针SP。</p>
<blockquote>
<p>通常，用户程序中至少有一个段是用STACK说明的，否则需在程序运行中对SS和SP进行初始化。</p>
</blockquote>
</li>
<li>
<p>AT表达式</p>
<p>表示本段可定位在表达式所指定的小节边界上。</p>
</li>
<li>
<p>MEMORY</p>
<p>表示本段在存储器中应定位在所有其他段的最高地址。</p>
</li>
</ul>
<ol start="4">
<li>使用类型（Use Type）</li>
</ol>
<p>使用类型是用于80386，80486和Pentium处理器机型的两种段模式选择：</p>
<ul>
<li>USE 16 段基值为16位，偏移地址为16位。一个段的最大寻址空间为64 KB。</li>
<li>USE 32 段基值为16位，偏移地址为32位。一个段的最大寻址空间为4 GB。</li>
</ul>
<ol start="5">
<li>类别名</li>
</ol>
<p>类别名必须用单引号括起来，并由用户自己选用。</p>
<p>在程序连接处理时，连接程序LINK把类别名相同的所有段存放在连续的存储区内，如在组合类型中没有选择PUBLIC，COMMON，MEMORY时，这些类别名相同的段仍然是各自独立的段。</p>
<h3 id="432-段寻址伪指令assume"><a class="header" href="#432-段寻址伪指令assume">4.3.2 段寻址伪指令（ASSUME）</a></h3>
<p>由段寄存器指向的段是当前段，在任何时刻，只有当前段内的存储单元才可访问。在汇编源程序时，汇编程序必须知道哪些段是当前段，且它们分别由哪个段寄存器指向。</p>
<p>ASSUME伪指令就是告诉汇编程序，在下面程序中哪些段是当前段，它们分别由哪个段寄存器指向。</p>
<p>ASSUME伪指令只影响汇编源程序时的设定，而不影响程序运行时段寄存器的设置。</p>
<p>ASSUME伪指令格式如下:
$$ASSUME \quad 段寄存器名:段名,段寄存器名:段名...$$</p>
<ul>
<li>段寄存器名是指CS、SS、DS和ES（对于80386及其后续机型还有FS和GS）中的一个</li>
<li>段名是指在SEGMENT/ENDS伪指令语句中定义的段名</li>
<li>段寄存器名和段名之间必须用冒号“：”分隔。</li>
<li>可以用关键字NOTHING作为段名将前面的某些设置取消或直接<code>ASSUME NOTHING</code>将所有段寄存器取消</li>
</ul>
<h3 id="433-段寄存器的装载"><a class="header" href="#433-段寄存器的装载">4.3.3 段寄存器的装载</a></h3>
<ol>
<li>DS和ES的装载</li>
</ol>
<p>如在指令的操作数字段上引用段名，就是将该段的段基值以立即数形式出现在操作数字段中。</p>
<blockquote>
<p>MOV传送指令不能把立即数直接传送给段寄存器，所以只能把段基值先送给一个通用寄存器，然后再转送给段寄存器DS或ES。</p>
</blockquote>
<ol start="2">
<li>SS的装载</li>
</ol>
<p>SS是堆栈段寄存器，它的装载就是对堆栈的设置。堆栈的使用离不开堆栈指针SP，所以在完成SS的装入的同时要实现对SP的设置。对SS的装载有如下两种办法：</p>
<ul>
<li>
<p>自动装载</p>
<ul>
<li>在段定义伪指令（SEGMENT）的组合类型中选择“STACK”参数，指示这个段是堆栈段。</li>
<li>当含有这个段的目标代码载入内存后，SS已自动装载STACK1段的段基值，同时堆栈指针SP也自动指向这个段最大地址+1单元（即堆栈底部+1的存储单元）。</li>
</ul>
</li>
<li>
<p>用执行指令的方法装载</p>
</li>
</ul>
<ol start="3">
<li>CS的装载</li>
</ol>
<p>CS和IP提供了当前执行目标代码的段基值和偏移地址。为保证程序的正确执行，CS和IP载入新值必须一起完成。</p>
<ul>
<li>
<p>使用结束伪指令<br />
$$END \quad &lt;地址表达式&gt;$$</p>
<ul>
<li>
<p>地址表达式一般是一个已定义的标号，也可以是一个标号加或减一个常数。地址表达式的值是这个程序要执行的第1条指令语句的地址。</p>
</li>
<li>
<p>END伪指令语句一方面告诉汇编程序，源程序到此结束，在END语句后面的任何语句均被汇编程序略去；
另一方面待程序目标代码装入内存储器时，系统用END语句中的地址表达式所示单元的段基值和偏移地址分别自动载入CS和IP中。</p>
</li>
</ul>
</li>
<li>
<p>执行段间程序转移指令时，CPU将自动修改CS和IP的内容。</p>
</li>
</ul>
<h2 id="段组伪指令group"><a class="header" href="#段组伪指令group">段组伪指令（GROUP）</a></h2>
<p>把程序中若干不同段名的段组成一个段组，在目标程序装入内存时，一个段组的若干段都装在一个≤64KB的物理段中。段组伪指令GROUP的格式如下：
$$&lt;段组名&gt; \quad GROUP \quad &lt;段名1，短命2，...&gt;$$</p>
<p>此时，对段组的引用就是使用段组名</p>
<h2 id="45-内存模式和简化段定义伪指令"><a class="header" href="#45-内存模式和简化段定义伪指令">4.5 内存模式和简化段定义伪指令</a></h2>
<h3 id="内存模式伪指令model"><a class="header" href="#内存模式伪指令model">内存模式伪指令(MODEL)</a></h3>
<p>内存模式伪指令MODEL用于确定用户程序中代码和数据如何安排和存放，以及其占用内存的大小。</p>
<p>内存模式伪指令MODEL的格式如下：
$$. /quad&gt; MODEL &lt;内存模式&gt;$$</p>
<ol>
<li>
<p>Tiny(最小型模式)</p>
<p>程序的代码和数据都放在同一个64 KB的段内。这就是扩展名为.COM的程序形式。程序的转移仅是段内转移，对数据的存取是在一个段内进行。</p>
</li>
<li>
<p>Small(小型模式)</p>
<p>程序的代码放在一个64 KB的段内，数据放在另一个64 KB的段内。程序的转移仅是段内转移，对数据的存取也是在一个段内进行。</p>
<blockquote>
<p>这是最常用的内存模式。</p>
</blockquote>
</li>
<li>
<p>Medium(中型模式)</p>
<p>程序的代码可以放在多个段中，但数据则放在一个64 KB的段内。这样，程序的转移就有可能是段间转移，而对数据的存取仍是在一个段内进行。</p>
</li>
<li>
<p>Compact(压缩型模式)</p>
<p>程序的代码放在一个64 KB的段内，而数据则可存放在多个段中。这样，程序的转移是段内转移，而对数据的存取要在不同段中进行</p>
</li>
<li>
<p>Large(大型模式)</p>
<p>程序中代码和数据都可以分别放在多个段中。因此，程序的转移就有可能是段间转移，而对数据的存取也可能要在不同段中进行。</p>
</li>
<li>
<p>Huge(巨型模式)</p>
<p>与大型模式（Large）类同，不同的是数据段可以超过64 KB。</p>
</li>
</ol>
<h3 id="简化段定义伪指令"><a class="header" href="#简化段定义伪指令">简化段定义伪指令</a></h3>
<p>使用简化段定义伪指令之前必须使用内存模式伪指令MODEL。</p>
<p>简化段定义伪指令有：</p>
<pre><code class="language-asm">. CODE [段名];代码段。若只有一个代码段，段名可任选；
             ;若是多个代码段，则应为每个代码段选定一个段名

. DATE;数据段，已初始化数据
. DATE?;数据段，未初始化数据
. CONST;常数段
. FARDATA [段名];远数据段。已初始化远数据
. FARDATA? [段名];远数据段。未初始化远数据
. STACK [长度];堆栈段。可指定堆栈的大小，缺省为1KB
</code></pre>
<ul>
<li>若FARDATA未指定段名，默认段名是FAR_DATA</li>
<li>而FARDATA？的默认段名是FAR_BSS</li>
</ul>
<blockquote>
<p>远数据段的设置主要是为了与高级语言接口连接</p>
</blockquote>
<p>一个简化段定义的开始也就是前一个段的结束，而不必使用ENDS伪指令，仅在最后一个段用结束伪指令END表示全部程序的结束。</p>
<h3 id="预定义符号"><a class="header" href="#预定义符号">预定义符号</a></h3>
<p>MASM提供一些在程序中使用的预定义符号，它类似于EQU伪指令定义的等价符号</p>
<ol>
<li>
<p>@Model</p>
<p>内存模式用数值形式表示。即Tiny = 1，Small= 2，Compact = 3，Medium = 4，Large = 5，Huge = 6。</p>
</li>
<li>
<p>@Code</p>
<p>简化段定义.CODE的等价别名，即代码段段名。</p>
</li>
<li>
<p>@Data</p>
<p>简化段定义.DATA的等价别名，即近数据段段名。</p>
</li>
<li>
<p>@Fardata</p>
<p>简化段定义.FARDATA的等价别名，即远数据段段名。</p>
</li>
<li>
<p>@Stack</p>
<p>简化段定义.STACK的等价别名，即堆栈段段名</p>
</li>
<li>
<p>@Codesize</p>
<p>用数值表示代码段的情况</p>
<ul>
<li>当内存模式为Tiny，Small，Compact时，只有一个代码段，此值为0</li>
<li>当内存模式为Medium，Large，Huge时，有多个代码段，此值为1。</li>
</ul>
</li>
<li>
<p>@Datasize</p>
<p>用数值表示数据段的情况。</p>
<ul>
<li>当内存模式为Tiny，Small，Medium时
<ul>
<li>只有一个数据段，此值为0</li>
</ul>
</li>
<li>当内存模式为Compact，Large时
<ul>
<li>有多个数据段，此值为1</li>
</ul>
</li>
<li>当内存模式为Huge时
<ul>
<li>有多个数据段且有超过64 KB的大数据段，此值为2。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="46-定义与对准伪指令"><a class="header" href="#46-定义与对准伪指令">4.6 定义与对准伪指令</a></h2>
<h3 id="定义伪指令org和位置技术器"><a class="header" href="#定义伪指令org和位置技术器">定义伪指令(ORG)和位置技术器($)</a></h3>
<p>汇编程序有一个位置计数器，用来记载正在汇编的数据或指令的目标代码在当前段内的偏移地址，符号“$”表示位置计数器的当前值。</p>
<p>定位伪指令ORG是对位置计数器设置、修改的控制命令。ORG伪指令语句格式如下：
$$ORG /quad &lt;表达式&gt;$$</p>
<p>ORG伪指令语句把表达式的值赋给位置计数器，即ORG语句后面的目标代码（指令代码或数据）由表达式给定的值作为起始偏移地址。</p>
<blockquote>
<p>且表达式中可以包含位置计数器的现行值＄。</p>
</blockquote>
<h2 id="对准伪指令"><a class="header" href="#对准伪指令">对准伪指令</a></h2>
<p>对准伪指令EVEN也是对位置计数器的一个控制命令，它把位置计数器的值调整为偶数。</p>
<p>对准伪指令EVEN语句格式如下:
$$EVEN$$</p>
<p>在存储器中，对字单元（包括双字等多字单元）进行存取操作时，如是偶地址，那么存取速度较快。所以对准伪指令EVEN主要应用在定义字数据（包括多字数据）前，用以对位置计数器进行调整。</p>
<h2 id="47-过程定义伪指令procendp"><a class="header" href="#47-过程定义伪指令procendp">4.7 过程定义伪指令(PROC/ENDP)</a></h2>
<p>在程序设计中，我们常把具有一定功能的程序段组织成一个子程序。MASM宏汇编程序用“过程”来构造子程序。过程定义伪指令语句的格式如下：</p>
<pre><code class="language-asm">过程名 PROC [NEAR/FAR]
    ...
    指令序列
    ...
过程名 EDNP
</code></pre>
<p>一个过程名类同于标号，它也有三个属性：段、偏移地址 和类型属性。</p>
<blockquote>
<p>如没有选择类型属性，则隐含为NEAR</p>
</blockquote>
<p>在一个过程（子程序）中，至少有一条子程序返回指令RET，它可以在过程中的任何位置，但过程执行的最后一条指令一定是返回指令RET。</p>
<h2 id="48-包含伪指令include"><a class="header" href="#48-包含伪指令include">4.8 包含伪指令(INCLUDE)</a></h2>
<pre><code class="language-asm">INCLUDE &lt;文件名&gt;
</code></pre>
<p>INCLUDE伪指令把指定的文件插入到现在正在汇编的源程序中，作为源程序的一个组成部分</p>
<h2 id="49-标题伪指令title"><a class="header" href="#49-标题伪指令title">4.9 标题伪指令(TITLE)</a></h2>
<pre><code class="language-asm">TITLE &lt;文本&gt;
</code></pre>
<p>标题伪指令TITLE是给程序指定一个标题，以便在列表文件中每一页的第一行都显示这个标题文本。</p>
<p>文本内容可以由程序设计人员任选名字或字符串，但字符个数不得超过80。标题伪指令语句应在源程序开始处使用</p>
<h1 id="5-宏命令"><a class="header" href="#5-宏命令">5. 宏命令</a></h1>
<h2 id="宏命令的使用过程"><a class="header" href="#宏命令的使用过程">宏命令的使用过程</a></h2>
<h3 id="宏定义"><a class="header" href="#宏定义">宏定义</a></h3>
<p>使用宏指令，必须先用<code>MACRO/ENDM</code>进行宏定义，存在两种形式</p>
<pre><code class="language-asm">;1. 无参数的宏定义
宏名 MACRO
    ...
    宏体
    ...
    ENDM

;2. 带参数的宏定义
宏名 MACRO 形参1，形参2，...
    ...
    宏体
    ...
    ENDM
</code></pre>
<p>宏定义不出现在程序的目标代码中，因此宏定义可以在源程序的任何位置上。</p>
<h3 id="宏调用"><a class="header" href="#宏调用">宏调用</a></h3>
<pre><code class="language-asm">; 1.无参数宏调用
宏名

; 2. 带参数宏调用
宏名 实参1，实参2，...
</code></pre>
<ul>
<li>如实参个数比形参个数多，那么多余的实参自动被略去</li>
<li>如实参个数比形参个数少，那么在宏展开时，没有实参替代的形参自动用空白串替代。</li>
</ul>
<h3 id="宏展开"><a class="header" href="#宏展开">宏展开</a></h3>
<p>当宏汇编程序扫描到宏指令语句（宏调用）时，就把宏定义中宏体的目标代码插入在宏调用的位置上，这就是宏展开。</p>
<h2 id="宏操作符"><a class="header" href="#宏操作符">宏操作符</a></h2>
<p>在宏定义和宏调用中，有几个常用的宏操作符。</p>
<h3 id="连接操作符"><a class="header" href="#连接操作符">连接操作符&amp;</a></h3>
<p>在宏定义中使用连接操作符&amp;时，它可以在形参的前面，也可以在形参的后面。</p>
<p>在宏展开时，对应形参的实参与它后面或前面的符号连接在一起构成一个新的符号。</p>
<h3 id="表达式操作符"><a class="header" href="#表达式操作符">表达式操作符%</a></h3>
<pre><code class="language-asm">%表达式
</code></pre>
<p>表达式操作符%告诉宏汇编程序获取表达式的值，而不是获取表达式文本本身。</p>
<h3 id="文本操作符"><a class="header" href="#文本操作符">文本操作符&lt;&gt;</a></h3>
<p>有时一个实参是由一串字符、逗号或空格构成，可以用文本操作符＜＞把一个完整的实参括起来，作为一个单一的实参。</p>
<h3 id="字符操作符"><a class="header" href="#字符操作符">字符操作符！</a></h3>
<pre><code class="language-asm">!字符
</code></pre>
<p>惊叹号“!”后面的字符不作为特别的操作符使用，而是字符本身。</p>
<blockquote>
<p>转义符</p>
</blockquote>
<h2 id="local伪指令"><a class="header" href="#local伪指令">LOCAL伪指令</a></h2>
<pre><code class="language-asm">LOCAL &lt;符号表&gt;
</code></pre>
<p>宏定义中如含有变量名或标号，且在同一源程序中又多次被宏调用，那么宏汇编程序在宏展开时，要产生多个相同的变量名或标号，这就不能满足变量名或标号在同一程序中必须唯一的要求，从而产生汇编出错。为避免这个错误，又要在宏定义中能使用变量名或标号，应使用局部符号伪指令LOCAL。</p>
<p>宏汇编程序在宏展开时，对LOCAL伪指令指定的变量名和标号自动生成格式为<code>？？× × × ×</code>的符号，其中后4位顺序使用0000～FFFF的十六进制数字。</p>
<h1 id="6-汇编语言程序设计基本技术"><a class="header" href="#6-汇编语言程序设计基本技术">6. 汇编语言程序设计基本技术</a></h1>
<!-- NOTE: P480 -->
<hr />
<h1 id="debugexe用法"><a class="header" href="#debugexe用法">debug.exe用法</a></h1>
<h2 id="注意"><a class="header" href="#注意">注意：</a></h2>
<ul>
<li><code>-</code>是debug提示符prompt</li>
<li>debug.exe只能对扩展名为<code>.com</code>和<code>.exe</code>的文件进行调试</li>
<li>命令参数不区分大小写</li>
<li>所有的输入和显示的数，均为十六进制数，H隐含</li>
<li><code>&lt;Ctrl&gt;+&lt;Break&gt;</code>停止命令的执行</li>
<li>如果命令产生大量输出，可按下<code>&lt;Ctrl&gt;+_&lt;Num Lock&gt;</code>使显示停止卷动，按下其他任意键可恢复</li>
</ul>
<h2 id="-r"><a class="header" href="#-r">-r</a></h2>
<p>查看，修改寄存器的内容和标志</p>
<pre><code class="language-asm">-r 
# 查看所有寄存器内容

-r register_name
# 修改指定寄存器的值

-rf
# 显示标志寄存器内容
</code></pre>
<p>所有的标志位为</p>
<div class="table-wrapper"><table><thead><tr><th>标志名</th><th>标志为1</th><th>标志为0</th></tr></thead><tbody>
<tr><td>OF 溢出（是/否）</td><td>OV</td><td>NV</td></tr>
<tr><td>DF 方向（增量/减量）</td><td>DN</td><td>UP</td></tr>
<tr><td>IF 中断（允许/关闭）</td><td>EI</td><td>DI</td></tr>
<tr><td>SF 符号（正/负）</td><td>NG</td><td>PL</td></tr>
<tr><td>ZF 零（是/否）</td><td>ZR</td><td>NZ</td></tr>
<tr><td>AF 辅助进位（是/否）</td><td>AC</td><td>NA</td></tr>
<tr><td>PF 奇偶（偶/奇）</td><td>PE</td><td>PO</td></tr>
<tr><td>CF 进位（是/否）</td><td>CY</td><td>NC</td></tr>
</tbody></table>
</div>
<h2 id="-d"><a class="header" href="#-d">-d</a></h2>
<p>查看内存中的内容</p>
<pre><code class="language-asm">-d [起始地址] [结束地址]
</code></pre>
<p>显示两部分内容</p>
<ul>
<li>字节的十六进制数形式</li>
<li>ASCII码形式</li>
</ul>
<blockquote>
<p>ascii码中不可见字符用<code>.</code>表示</p>
</blockquote>
<h2 id="-e"><a class="header" href="#-e">-e</a></h2>
<p>修改内存单元中的内容</p>
<pre><code class="language-asm">-e 地址 [内容表]
</code></pre>
<ul>
<li>如果提供内容表：用内容表的内容替换指定开始地址的一个或多个字节的内容</li>
<li>否则进入交互替换模式
<ul>
<li>输入值后
<ul>
<li>输入enter退出替换模式</li>
<li>输入空格对下一个单元继续编辑</li>
</ul>
</li>
<li>输入空格
<ul>
<li>不修改当前内存单元的值，对下一个单元继续编辑</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如只输入一个地址偏移量，则缺省的段为DS</p>
</blockquote>
<h2 id="-a"><a class="header" href="#-a">-a</a></h2>
<p>让用户可以直接输入汇编语言指令，将其转换为机器码并存入内存中</p>
<pre><code class="language-asm">-a [地址]
</code></pre>
<ul>
<li>键入的汇编语句被汇编到地址指定的相应内存单元中</li>
<li>如没有指定地址，则被汇编到CS:0100内存区内。</li>
<li>键入所有语句后，当再次出现提示符时，按下↙键，返回到DEBUG提示符</li>
</ul>
<h2 id="-t"><a class="header" href="#-t">-t</a></h2>
<p>执行一条或多条指令</p>
<pre><code class="language-asm">-t [=地址] [值]
</code></pre>
<ul>
<li>执行自指定地址开始的一条或给定值条指令</li>
<li>每条指令执行完都会显示出所有寄存器和标志位的内容</li>
<li>未给定地址则以CS:IP开始执行</li>
</ul>
<h2 id="-u"><a class="header" href="#-u">-u</a></h2>
<p>反汇编命令：将指定内存地址中的机器码转换为可读的汇编指令</p>
<pre><code class="language-asm">-u [起始地址] [结束地址]
</code></pre>
<ul>
<li>从指定的地址反汇编32字节的汇编语句，显示出他们的
<ul>
<li>地址</li>
<li>十六进制值</li>
<li>对应的汇编语句。</li>
</ul>
</li>
<li>起始地址，结束地址均缺省时
<ul>
<li>则以上一条条u命令反汇编的最后一条命令后的单元作为起始地址</li>
<li>若以前未用过的U命令则以CS：100作为起始地址。</li>
</ul>
</li>
</ul>
<h2 id="-g"><a class="header" href="#-g">-g</a></h2>
<p>执行程序命令功能：执行正在调试的程序，当执行到指定断点时，停止执行，并显示寄存器、标志和下一条要执行的指令。</p>
<pre><code>-g [=地址] [地址 [地址 …]]
</code></pre>
<ul>
<li>[=地址]规定了执行的起始地址，缺省时则以CS：IP当前内容为开始地址，输入时要特别注意加 “=” 号</li>
<li>第二、第三参数的地址为断点地址，最多可设10个断点，每当程序执行遇到断点时都会停下来，键入G继续执行</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
