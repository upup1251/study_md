光标移动

这些命令用于移动光标。如果新的位置离开了当前显示范围，屏幕将滚动到合适的位置，使得光标可见


# 动作和操作符

```lua
c       -- 修改 (change)
d       -- 删除 (delete)
y       -- 抽出 (yank) 到寄存器 (不改变文本)

~       -- 变换大小写 (只有当 'tildeop' 置位时有效)
g~      -- 变换大小写
gu      -- 变为小写
gU      -- 变为大写

!       -- 通过外部程序过滤
=       -- 通过 'equalprg' (若为空，C-indenting) 过滤

gq      -- 文本排版
gw      -- 文本排版，不移动光标
g?      -- ROT13 编码

>       -- 右移
<       -- 左移

zf      -- 定义折叠

g@      -- 调用 'operatorfunc' 选项定义的函数
```
- 动作包括一个次数而操作符之前也有一个次数的话(2d2w)，两者相乘
- 重叠(dd)操作符使之成为行操作。如果使用计数，不管是在首字符之前还是之后，操作对象是对应的行数
- 除了先给出操作符再给出动作的方式以外，你还可以用可视模式: 先用 "v" 标记文本的开始处，移动光标到文本的末尾，然后再输入操作符
- 可以在操作符后用 "v"、"V" 或者 CTRL-V 来强制该动作面向行，字符或可视列块


# 左右动作

```lua
h/<BS>      -- 向左 [count] 个字符
l/<space>   -- 向右 [count] 个字符

0           -- 到行的首个字符
^           -- 到行的首个非空白字符。
g0          -- 到屏幕行的首个字符
g^          -- 到屏幕行的首个非空白字符

$           -- 往下 [count-1] 行并到该行的行尾
g_          -- 往下 [count-1] 行并到该行的末个非空白字符
g$          -- 往下 [count-1] 屏幕行并到该屏幕行的行尾

|           -- 到当前行的 [count] 屏幕列
gm          -- (尽可能) 向右移到屏幕显示宽度的中间位置。
gM          -- 到行文本的中间位置。


f{char}     -- 到右侧第 [count] 次出现的字符 {char}。光标放在 {char}上。
F{char}     -- 到左侧第 [count] 次出现的字符 {char}。光标放在 {char}上。

t{char}     -- 到右侧第 [count] 次出现的字符 {char} 之前。光标放在{char} 左边的位置。
T{char}     -- 到左侧第 [count] 次出现的字符 {char} 之后。光标放在{char} 右边的位置。

;           --  重复上次的 f、t、F 或者 T 命令 [count] 次
,           -- 反方向重复上次的 f、t、F 或者 T 命令 [c行尾
```


# 上下动作

```lua
k/<CTRL-P>  -- 向上[count]行
j/<CTRL-N>/<CTRL-J>     --向下[count]行
gk          -- 向上[count]显示行
gj          -- 向下[count]显示行

-           -- 向上[count]行，停在首个非空字符上
+/<CTRL-M>/<CR>         -- 向下[count]行，停在首个非空字符上
_           -- 向下 [count] - 1 行，停在首个非空白字符上

G           -- 到第 [count] 行，缺省是末行
gg          -- 到第 [count] 行，缺省是首行

:[range]    -- 把光标移到 [range] 的末行
{count}%    -- 到文件的 {count} 百分比处并停在行的首个非空白字符上
[count]go  -- 到缓冲区的第 [count] 个字节。缺省的 [count] 是 1
```


# 单词动作

```lua
<S-Right>/w -- 正向 [count] 个单词
<C-Right>/W -- 正向 [count] 个字串
<S-Left>/e  -- 反向 [count] 个单词
<C-Left>/E  -- 反向 [count] 个字串


e           -- 正向到第 [count] 个单词的尾部
E           -- 正向到第 [count] 个字串的尾部
ge          -- 反向到第 [count] 个单词的尾部
gE          -- 反向到第 [count] 个字串的尾部
```

word单词的定义：
- 一个单词由字符、数字和下划线序列或者其他的非空白字符的序列组成
- 已折叠的行序列被认作由单个字符组成的单词
- 单词间可以空白字符 (空格、制表、换行) 分隔
- 空行也被认作单词。
- 这一规则可以用 'iskeyword' 选项改变

WORD字串的定义
- 一个字串由非空白字符序列组成
- 字串以空白分隔
- 空行也被认作字串。


# 文本对象动作

```lua
)/}         -- 正向[count]个sentence/paragraph
]]          -- 正向[count]个section或到后一个出现在首列的'{'
][          -- 正向[count]个section或到后一个出现在首列的'}'


(/{         -- 反向[count]个sentence/paragraph
[[          -- 反向[count]个section或到后一个出现在首列的'{'
[]          -- 反向[count]个section或到后一个出现在首列的'}'
```

sentenc句子定义:
- 一个句子以 '.'、'!' 或者 '?' 结尾并紧随着一个换行符、空格或者制表
- 结束标点和空白字符之间可以出现任何数量的闭括号和引号: ')'、']'、'"' 和 '''
- 段落和小节的边界也视为句子的边界

paragraph段落定义:
- 一个段落以每个空行或段落宏命令，段落宏由 'paragraphs' 选项里成对出现的字符所定义
- 小节边界也被视为段落边界
- 空白行不是段落边界

section小节定义:
- 一个小节以每个首列出现的换页符 (\<C-L>) 或小节宏命令开始，小节宏由 'sections'选项里成对出现的字符所定义。




# 文本选择对象

只能在可视模式或操作符后使用的命令。
- 这些命令或以 "a" 打头，代表选择一个 ("a"n) 包含空白的对象；
- 或以 "i" 带头，代表选择内含 ("i"nner) 对象: 它们不包含空白。  
另外，空白本身也是内含对象。

```lua
w/W         -- 单词/字串，选择 [count] 个句子
s/p         -- 句子/段落，选择 [count] 个段落
[/]         -- []块，选择 [count] 层'[''']'块
(/)/b       -- ()block块，选择 [count] 层块
            -- 如果不再'(''')'块内，则会向后找到第一个'('')'block块
{/}/B       --  {}大块，选择[count]层
'/"/`       -- 引号字符串
>/<         -- <>块，选择[count]层
t           -- <tag></tag>标签块，选择[count]层
```

# 位置标记




## 设置标记

```lua
m{标记名}                   

-- 把位置标记 {a-zA-Z'} 设在 [range] 的末行第 0 列。缺省的 [range] 是当前行
:[range]ma[rk] {a-zA-Z'}
```


## 跳转到位置标记

```lua
`{marker}        -- 光标放在指定的位置
'{marker}        -- 光标放在指定位置所在行的首个非空字符上

g'{marker}/g`{marker}   -- 跳转到标记，在当前缓冲区跳转时，不改变跳转列表
```


## 标记s

```lua
'a - 'z     -- 文件内位置
'A - 'Z     -- 文件位置
'0 - '9     -- 前次及更早次Vim离开位置(跨文件)

'^          -- 前次插入位置，gi命令用到这个标记
'.          -- 前次修改位置，要跳转到较旧的改变，用  g;
''          -- 到前次跳转之前或者上次 "m'" 或者 "m`" 命令给出的位置
'"          -- 到前次离开本缓冲区时的光标位置，到前次离开本缓冲区时的光标位置

'\          -- 前次离开缓冲区位置
'[/']       -- 前次修改区域位置

'</'>       -- 最近可视选择区域
'(/')       -- 当前句子
'{/'}       -- 当前段落
```
> 这里的`'`可用`\``替换

## 查看标记

```lua
:marks {arg}        -- 列出所有 {arg} 包含的位置标记
:delm[arks] {marks} -- 删除指定的位置标记
:delm[arks]!        -- 删除当前缓冲区所有的位置标记
```


# 跳转

## jumplist跳转

"跳转" 是通常能移动光标数行之外的命令

```lua
<CTRL-O>        -- 转到跳转表里第 [count] 个较旧的光标位置
<Tab>/<CTRL-I>  -- 转到跳转表里第 [count] 个较新的光标位置
```

```lua
:ju[mps]        -- 打出跳转表
:cle[arjumps]   -- 清除当前窗口的跳转表
```
- 跳转表用来记住跳转的位置
- 每个窗口有独立的跳转表，每个表最多能存储 100 项
- 用跳转命令，当前的行号被插到跳转表的最后。如果相同的行已经在跳转表里，那会被删除
- 删除和插入行以后，行号会得到调整
- 分割一个窗口，跳转表会复制到新的窗口里


## 改变表跳转

改变文本后，光标的位置被记住

```lua
:changes    -- 打出改变表。">" 字符指示当前的位置
```


```lua
g;      -- 转到改变表里第 [count] 个较旧的位置
g,      -- 转到改变表里第 [count] 个较新的位置
```


# 其他动作

```lua
%       -- 找到本行的光标所在或其后的下一个项目，并跳转到它的匹配
```
- 项目可以是
    - `([{}])`
    - `/* */`: C-风格的注释的开始或结尾
    - `#if、#ifdef、#else、#elif、#endif`: C 预处理条件宏


```lua
[(/{      -- 反向第 [count] 个的相对于当前位置未匹配的 '(','{'
])/}      -- 正向第 [count] 个的相对于当前位置未匹配的 ')','}'
```

```lua
]m/]M     -- 正向第 [count] 个方法 (method) 的开始处/结束处
[m/[M     -- 反向第 [count] 个方法的开始处/结束处
```
- 如果找不到方法的开始或结束处，则跳转到类的开始或结束处






