第十一、并发控制

[toc]

# 1. 并发控制概述

## 1.1 并发控制机制的任务
- 对并发操作进行正确调度
    > 使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性
- 保证事务的隔离性
- 保证数据库的一致性

## 1.2 并发操作可能带来数据不一致性
- 丢失数据
    > 两个事务t1和t2读入同一数据并修改，t2的提交结果破坏了t1提交的结果，导致t1的修改丢失
- 不可重复读
    > t1读取数据后，t2执行更新操作，使t1无法再现前一次读取结果
- 读“脏”数据
    > t1修改某一数据，写入磁盘，t2读取数据后，t1由于某种原因UNDO



# 2. 封锁

## 2.1 什么是封锁

封锁就是事务t在对某个数据对象操作之前，先向系统发送请求，对其加锁  
加锁后事务t对该数据有了一定的控制，在事务t释放它的锁前，其他事务不能更新此数据对象

## 2.2 基本封锁类型

- 排他锁(Exclusive Locks,简记X锁)
    > 排他锁又称写锁，若事务t对数据对象A加上X锁，则只允许t读取和修改A,其他事务不能再对A嘉任何类型的锁，直到t释放该锁
- 共享锁(Share Locks,简记S锁)
    > 共享锁又称读锁，若事务t对数据对象A加上S锁，则只允许t读A但不能修改A,其他事务只能再对A加S锁，不能加X锁，直到t释放

## 2.3 封锁协议

- 一级封锁协议  
    事务t在修改数据R前必须先对其加X锁，直到事务结束才释放
    > 可保证不丢失数据
- 二级封锁协议  
    一级封锁协议的基础上增加t在读取数据R之前必须先对其加S锁，读完后释放
    > 可保证不丢失数据 + 不读“脏”数据
- 三级封锁协议  
    一级封锁协议的基础上增加t在读取数据R之前必须先对其加S锁，直到事务结束  
    > 可保证不丢失数据 + 不读“脏”数据 + 可重复读


## 2.4 活锁和死锁

封锁技术带来的新问题

- 活锁  

描述：当前正在等待的事务被忽略

解决措施：采用先来先服务的策略

- 死锁  

描述：两个事务相互锁住对方需要的数据对象


解决措施:
1. 一次封锁法：要求每个事务必须一次将所有要使用的数据全部枷锁，否则不能执行
2. 顺序封锁法：预先对数据对象规定一个封锁顺序，所有的事务都按照这个顺序进行封锁


死锁的诊断(更常用):
1. 超时法
2. 事务等待图法：用事务等待图动态反映所有事务的等待情况  
    > 事务等待图是一个有向图G=(T,U)  
    > 其中T是结点的集合，每个结点表示正在运行的事务  
    > U是边的集合，每条边表示事务等待的情况  
    > 若t1等待t2,则t1,t2之间有一条t1指向t2的有向边
    > 存在回路则证明发生死锁 

死锁的解除：

1. 选择一个处理死锁代价最小的事务，撤销其和他所持有的所有的锁



## 2.5 两段锁协议

两端锁协议内容：所有的事务必须分两个阶段对数据项加锁和解锁
- 扩展阶段：获得封锁
    事务可以申请获得任何数据项上的任何类型的锁，但不能释放任何锁
- 收缩阶段：释放封锁
    事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁

> 使用两段锁封锁协议产生的是可串行化调度




# 3. 并发调度的可串行性

## 3.1 可串行调度
多个事务的并发执行是正确的，当且仅当其结果与某一次序**串行**地执行这些事务的结果相同。  


## 3.2 冲突可串行化调度  
一个调度Sc在保证**冲突操作**的次序不变的情况下，通过交换两个事务**不冲突操作**的次序，得到另一个调度Sc'，如果Sc'是串行的，称调度Sc为冲突可串行化调度  
> 冲突操作：指不同事务对同一个数据的读写操作和写写操作
> - Ri(x)和Rj(x) //事务Ti读x,事务Tj写x
> - Wi(x)和Wj(x) //事务Ti写x,事务Tj写x

> 不同事务的冲突操作和同一事务的两个操作不能交换  


# 4. 封锁的粒度

封锁对象的大小称为封锁粒度

- 逻辑单位：属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库
- 物理单元：页（数据页或索引页）、物理记录等

<!-- TODO:懒得写了 -->


