[toc]


数据库的完整性

- 数据的正确性
    > 防止数据库中存在不符合语义的数据  
    > 防止对象：不合语义、不正确的数据 
- 数据的相容性
    > 保护数据防止恶意的破坏和非法的存取  
    > 防范对象：非法用户和非法操作

# 1. 实体完整性

- 定义实体完整性
```sql
在列级定义主码
...
dataName dataClass PRIMARY KEY,
...

在表级定义主码
...
PRIMARY KEY(dataName)
```

- 实体完整性检查和违约处理
```sql
插入或对主码列 进行更新操作时，RDBMS按照实体完整性规则自动进行检查。包括：
1. 检查主码值是否唯一，如果不唯一则 拒接 插入或修改；
2. 检查主码的各个属性是否为空，只要有一个为空就 拒绝 插入或修改。
```


# 2. 参照完整性

- 定义参照完整性
```sql
FOREIGN KEY (dataname) REFERENCES tableName(dataname)
```

- 参照完整性检查和违约处理

| 被参照表 | 参照表 | 违约处理 |
| --------------- | --------------- | --------------- |
| 可能破坏参照完整性 | 插入元组 | 拒绝 |
| 可能破坏参照完整性 | 修改外码值 | 拒绝 |
| 删除元组 | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |
| 修改主码值 | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |

> 参照完整性违约处理：  
> 拒绝(NO ACTION)处理：默认策略  
> 级联(CASCADE)操作  
> 设置为空值(SET-NULL)：对于参照完整性，除了应该定义外码，还应定义 外码列是否允许为空
> ```sql
> FOREIGN KEY(Sno) REFERENCES Student(Sno)
> ON DELETE CASCADE //级联删除
> ON UPDATE NO ACTION //拒绝操作
> ON DELETE SET-NULL //设置为空
> ```



# 3. 用户定义的完整性

属性上的约束条件检查和违约处理：**插入**或**修改**属性的值时，RDBMS检查属性上的约束条件是否被满足，不满足则**拒绝**执行

## 3.1 属性上的约束条件

1. 属性上的约束条件的定义

CREATE TABLE时定义
- 列值非空(NOT NULL)
- 列值唯一(UNIQUE)
- 检查列值是否满足一个布尔表达式(CHECK)

## 3.2 元组上的约定条件

在CREATE TABLE时可用**CHECK**短语定义元祖上的约束条件，即元组级的限制  

> 同属性值限制相比，元组级的限制可用设置 **不同属性** 之间的取值的相互约束条件

# 4. 完整性约束命名子句

1. 完整性约束命名子句格式

$$CONSTRAINT <完整性约束名> <完整性约束>$$
> <完整性约束>包括NOT NULL,UNIQUE,PRIMARY KEY,FOREIGN KEY,CHECK短语等。

2. 修改表中完整性限制

$$ALTER TABLE <表名> DROP CONSTRAINT <完整性约束名字>$$
$$ALTER TABLE <表名> ADD CONSTRAINT <完整性约束名字> <完整性约束>$$
> 可用先删除原来的约束，在增加新的约束以进行修改

# 5. 断言

$$CREATE ASSERTION <断言名> <CHECK语句>$$
$$DROP ASSERTION <断言名>$$


# 6. 触发器

触发器(Trigger)有时也称为事件-条件-动作(ECA)规则，是用户定义在关系表上的一类由**事件驱动**的特殊过程


## 6.1 定义触发器

```sql
CREATE TRIGGER <触发器名>               //每当触发事件发生时，该触发器被激活
{BEFORE | AFTER} <触发事件> ON <表名>   //指明触发器激活的时间是在执行触发事件前或后
REFERENCES NEW|OLD AS <变量>            //REFERENCES指出引用的变量
FOR EACH {ROW | STATEMENT}              //定义触发器的类型，指明动作体执行的频率
[ WHEN <触发条件>] <触发动作体>         //仅当触发条件为真时才执行触发动作体
```
- 创建触发器。只有表的拥有者才能创建，并且一个表只能创建一定数量的触发器  
- 触发器名。触发器名可以包含模式名，也可以不包含。同一模式下的触发名必须是唯一的
- 表名。触发器只能定义在基本表上，不能定义在视图上
- 触发事件。可以是INSERT,DELETE或DELETE
    > 还可以是UPDATE OF <触发列....>,指明修改哪些列时激活触发器
- 触发类型。触发器按照所触发动作的间隔尺寸可分为行级触发器(FOR EACH ROW)和语句级触发器(FOR EACH STATEMENT)
    > 如果是语句级触发器，那么触发动作体只会执行一次  
    > 如果是行级触发器，那么触发语句影响了多少行，就会触发多少次
- 触发条件。当触发条件为真时，触发动作体才执行
- 触发动作体。既可以是一个PL/SQL过程块，也可以是对已创建存储过程的调用
    > 如果是行级触发器，用户可以在过程体积中使用NEW或OLD引用UPDATE/INSERT时间之后（前）的新（旧）值；语句级触发器不存在NEW和OLD


## 6.2 执行触发器

同一个表的多个触发器激活时遵循如下顺序
1. 执行该表上的BEFORE触发器
2. 激活触发器的SQL语句
3. 执行该表上的AFTER触发器
> 对于对于同一个表上的多个BEFORE和AFTER触发器，遵循“谁先创建谁先执行”的原则


## 6.3 删除触发器

$$DROP TRIGGER <触发器名> ON <表名>$$

