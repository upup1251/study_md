[toc]
# 4. 排序算法

## 4.1 各种排序算法比较

| 排序方法 | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度 | 稳定性 | 
| --------------- | --------------- | --------------- | --------------- | --------------- | --- |
| 插入排序 | $O(n^2)$ | $O(n^2)$ | $O(n)$ | O(1) | 稳定 |
| 希尔排序 | $O(n^{1.3})$ | $O(n^2)$ | $O(n)$ | $O(1)$ | 不稳定 |
| 选择排序 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳定
| 堆排序 | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(1)$ | 不稳定
| 冒泡排序 | $O(n^2)$ | $O(n^2)$ | $O(n)$ | $(1)$ | 稳定
| 快速排序 | $O(nlog_2n)$ | $O(n^2)$ | $O(n)$ | $O(log_2n)$ | 不稳定
| 归并排序 | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(n)$ | 稳定
| 计数排序 | $O(n+k)$ | $O(n+k)$ | $O(n+k)$ | $O(n+k)$ | 稳定
| 桶排序 | $O(n+k)$ | $O(n^2)$ | $O(n)$ | $O(n+k)$ | 稳定
| 基数排序 | $O(n*k)$ | $O(n*k)$ | $O(n*k)$ | $O(n+k)$ | 稳定



## 4.2 堆排序

> 利用最大堆的特性，每次将位于根节点的最大值选出至已排序队列（交换至当前堆的尾节点）

1. 什么是堆？  
堆是一种特殊的数据结构，通常由数组来实现，把堆看作一颗完全二叉树，堆中节点的值总是不大于或不小于其父节点的值。
> 根节点最大的堆叫做最大堆，最小堆相反。

2. 最大堆维护算法(O(logn))
```c
MAX_HEAPIFY(A,i){ //对堆(数组)A中根节点为(下标)i的子堆进行维护
    l = left(i);r=right(i); //取节点i的左孩子节点和右孩子节点下标
    //寻找根节点、左孩子和右孩子三者中的最大值，检查是否符合大顶堆
    if(l<=A.heap_size and A[l]>a[i]){ //如果存在左孩子，看是否大于根节点
        largest = l;
    }
    else{
        largest = i;
    }
    if(r<=A.heap_size and A[r]>A.[largest]){ //存在右孩子，同样进行判断
        largest = r;
    }
    if(largest!=i){ //如果比较后根节点不是最大的，则进行处理
        Swap(A,i,largest); //交换孩子节点和根节点的位置
        MAX_HEAPIFY(A<largest); //对交换后的子子堆进行维护，防止交换后的子子堆不是一个最大堆
    }
}
```

3. 建最大堆算法(O(O(logn)))  
给定一个数组A,调用堆维护算法MAX_HEAPIFY，我们自底向上将数组A变成一个堆
```c
BUILD_MAX_HEAP(A){ //对输入的数组A进行大堆化
    A.heap_size = A.length; //将堆的大小设置为数组大小
    for i=A.length/2 downto 1{ //从最后一个节点的父节点(即最后一个父节点)开始，自底向上直至根节点，使用堆维护算法
        MAX_HEAPIFY(A,i);
    }
}
```

4. 堆排序算法(O(nlogn))
```c
kHEAPSORT(A){ //A是最大推，我们通过最大堆进行堆排序
    for i=A.length downto 2{  //当只剩最后一个节点时，必然是最小的，不必进行排序
        Swap(A[1],A[i]); //交换根节点(最大值)和最后一个节点，将最大值放在最后面
        A.heap_size(A) = A.heap_size(A) -1; //将堆的大小减少1,上一步的最大值不再参加排序，寻找下一个最大值
        MAX_HEAPIFY(A,1); //对根节点进行维护，方便进行下一次交换
    }
}
```

## 4.3 快速排序(平均O(nlogn),最差O($n^2$))  
> 快速排序如何应用分治策略：  
> 1. 将数组A[p..r]划分为量子子数组A[p...q]与A[q+1...r]
> > 不变式：子数组A[p...q]中的元素都比A[q+1...r]小
> 2. 递归调用快速排序算法对子数组进行排序

```c
QUICkSORT(A,p,r){ //数组A,待排序下限p和上限r
    if(p<r){ //如果只有一个元素，则无需进行排序
        q = PARTITION(A,p,r); //一次排好一个位置，并返回这个下标
        QUICkSORT(A,p,q-1); //以排好位置为分割点，对左侧递归排序
        QUICkSORT(A,q+1,r);
    }
}
```

```c
//重新虽数组元素进行调整，使第一个数组中所有数小于第二个数组，返回分割点的下标
PARTITION(A,p,r){ //对A[p...r]进行排序
    x = A[r]; //取最后一个作为枢纽
    i = p-1; //记录大于枢纽的低一个值
    for j=p to r-1{ //从第一个遍利到最后
        if(A[j]<=x){ //如果小于枢纽
            i++; 
            swap(A[i],A[j]); //将i处大于枢纽的值与当前小于枢纽的值进行交换
        }
    }
    swap(A[i+1],a[r]); //将i处最后一个大于枢纽的值与枢纽进行交换
    return i+1; //返回枢纽的位置，枢纽对应左侧值都小于枢纽，右侧都大于，枢纽找到正确的位置
}
```

> 对已经排好序的序列来说，运行时间为O($n^2$)，为改进可：
> 1. 对数组中的元素进行打乱
> 2. 随即选取主元


## 4.4 桶排序  
对数组A中元素的区间范围划分为n个大小相同的子区间，每个区间成为桶，然后把n个数据分别放入各个桶中。对每个桶中的数进行排序，然后遍历各个桶将其元素列出即可。

## 4.5 计数排序
1. 扫描数组A确定各个计数器(即各个元素的个数)的值
2. 统计A中不超过i的元素的个数并置于$数组C_i$
3. 倒序扫描数组A中的元素，每扫描到一个元素就把它放到数组B的C[A[j]]号位置上(B[C[A[j]]]=A[j])，然后C[A[j]]--;

## 4.6 基数排序算法  
存在n个数，每个数是一个d位整数，每个位的取值在0和k之间，从低位向高位轮播排序


## 4.7 线性时间排序的比较排序下界  
比较排序：通过比较元素大小来确定元素的相对位置，最后将所有的数组有序排序。
> 利用决策树，可将所有的排序可能都列在叶子节点上，可知道得到最终结果所需的步骤就是树的高度

$$n!<=L<=2^h -> h>=log(n!)=Ω(nlogn)$$
> n是待比较数个数，n!表示所有的可能，L为可达叶子节点的个数，h为树的高度，$2^h$表示第h层的节点数

