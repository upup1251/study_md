[toc]


# 6 贪心算法

自顶向下，根据确定的**选择标准**每次做出当前最优的选择，希望通过若干次选择得到问题的一个解。

> 贪心算法是一种较快的求解方法，但是不保证求得问题的最优解。

应用

## 6.1 活动选择问题(O(nlogn))

n个活动互斥的共用某个资源，找出一个规模最大的活动子集，使得子集中任两个活动是相容的（即时间区间不重叠）。

```c
(O(nlogn))
Greedy-Activity-Select(s,f){ //start,finish数组，记录了各个活动的开始和结束时间
    Sort(a1,a2...an); //对a1,a2...an按结束时间从早到晚排序
    A.add(a1); //把最早的a1加入结果A中
    n = length(s); 
    i = 1;
    for m=2 to n { //对后面的活动进行遍历
        if(s[m] >= f[i]) { //如果m的开始时间晚于i,则加入结果集A
            A.add(am); 
            i = m; //并更新i
        }
    }
    return A;
}
```

## 6.2 贪心算法求解分数背包问题
选择标准：效率（v/w）（价值/重量）

```c
FRACTIONALkNAPSACk(n,W,v,w){
    sort(n,v,w); //n个物品按照效率从高到低排序，先选择效率高的
    for i=1 to n {
        x[i] = 0; //i号物品放置多少到背包里
    }
    c = W; //剩余背包容量,初始化
    for i=1 to n {
        if(w[i] <= c){ //当前物品全放得进
            x[i] =1;
            c = c-w[i];
        }
        else { //只能放一部分
            x[i] = c/w[i];
            break;
        }
    }
    return x;
}
```

## 6.3 哈夫曼编码(O(nlgn))

从|C|个叶子节点开始，执行|C|-1次合并，操作建立最终的最优编码二叉树。  
算法使用一个频率最小优先队列Q,每次合并两个频率最小的结点而产生一个新结点，新结点频率为原来两个结点频率之和。

