[toc]
#  2. 递归算法
递归算法是一种直接或间接地调用**自身**的算法。

## 2.1 应用

### 2.1.1 阶乘函数
```c
Factorial(n){
    if(n<0) return 0; //输入的数据小于0
    if(n==0) return 1; //递归结束
    return n*Factorial(n-1); //调用自身
    //将递归中用的数据进行返回
}
```
### 2.1.2 Hanoi塔问题
```c
Hanoi(n,a,b,c){ //利用c柱将1..n从a移动到b
    if(n>0){
        Hanoi(n-1,a,c,b); //利用b柱将1..n-1移动到c柱
        mov(n,a,b); //将n从a柱移动到b柱
        Hanoi(n-1,c,b,a); //将1..n-1利用a柱移动到b柱
        //不需要返回值，直接对程序中的数据进行操作，不用return
    }
}
```
### 2.1.3 Fibonacci数列  
```c
Fibonacci(n){
    if(n<1) return 0; //输入小于1
    if( n==1 | n==2 ) return 1; //n=1和2时候数列值为1,同时为递归终止条件
    return Fibonacci(n-1)+Fibonacci(n-1); //抵用自身
    //同Factorial阶乘问题，需要返回值
}
```

## 2.2 求解递归式

对于递归算法，其时间复杂度一般由同时间复杂度低输入实例的时间复杂度组成,如T(n)=2*T(n/2)+n

### 2.2.1 代入法（替换法、猜测法）  
先猜答案，再利用归纳法进行证明。

### 2.2.2 迭代法 
    1. 展开递归式
    2. 进行若干步代数运算
    3. 求和
    4. 发现规律，进行归纳

### 2.2.3 递归树法  
递归树中的节点表示求解子问题的待解或者合并代价。每颗递归属对应这问题的一次分解。对树中每层的代价求和，得到层代价，然后将所有层的代价求和得到总代价。  
通过花递归树得到递归式的解的猜测，然后用归纳法证明。

### 2.2.4 主方法  
对于T(n)=aT(n/b)+f(n);  
T(n)=Θ($n^{log_b^a}$)  <-->  f(n)=O($n^{log_b^a-c}$)  
T(n)=Θ($n^{log_b^a}*logn$)  <-->  f(n)=Θ($n^{log_b^a}$)  
T(n)=Θ(f(n))  <-->  f(n)=Ω($n^{log_b^a+c}$)
> 其中c为常数


