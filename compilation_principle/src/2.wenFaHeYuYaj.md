第二章、文法和语言

[toc]

---

一种程序设计语言(编程语言)是一个记号系统，和自然语言一样，他的完整定义应当包括：
1.  语法
- 定义什么样的符号序列是合法的
- 不考虑符号序列的含义

2.  语义
- 静态语义：一系列限定规则，确定哪些合乎语法的程序是合适的
- 动态语义：标明程序要做些什么，要计算什么



# 1. 概念

## 字母表和字符串

1. 字母表$\sum$

字母表是符号的非空有穷集合，字母表中的元素称为符号

2. 符号串

由字母表$\sum$中的符号组成的有穷序列
- 例如001110是字母表∑{0,1}上的符号串
- 如果某符号串x中有m个符号，则称其长度为m，表示为|x|=m
- 空串$\epsilon$: 不包含任何符号的符号串，|$\epsilon$|=0


3. 符号串的头尾、固有头和固有尾

对于符号串$z=xy$
- $x$是$z$的头，$y$是$z$的尾
- 如果$x$非空，那么$y$是固有尾
- 如果$y$非空，那么$x$是固有头


4. 字符串集合

若集合$A$中的所有元素都是某字母表$\sum$上的**字符串**，则称$A$是该字母表上的字符串集合

## 符号串上的运算

1. 符号串的连接

$x,y$是符号串，它们的连接$xy$是把$y$的符号写在$x$符号后得到的符号串


2. 符号串的方幂

$x^n$是把$x$自身连接$n$次

3. 符号串集合之间的连接

两符号串集合之间的乘积就是将两符号串集合中的各个元素进行笛卡尔积连接
$$A \cdot B = \{w_1w_2 | w_1 \in A \quad and \quad w_2 \in B\}$$


4. 符号串集合之间的方幂

$$A^n = A_1\cdot A_2\cdot...\cdot A_n$$

- 闭包：$A^* = A^0 \cup A^1 \cup ...$
- 正闭包：$A^+ = A^1 \cup A^2 \cup ...$
> 字母表上的闭包类似


# 2. 文法和语言

## 字母表上的语言

1. 定义

任何符号串集合$L \subseteq \sum^*$是字母表$\sum$上的一个语言

2. 语言的代数运算

由于语言就是符号串集合，因此语言的代数运算就是符号串集合的代数运算
- 连接: $L \cup M = \{ w | w \in L \quad or \quad w \in M \}$
- 并: $L \cdot M = \{w_1w_2 | w_1 \in L \quad and \quad w_2 \in M$
- 方幂: $L^n = L \cdot L \cdot ...$
- 闭包: $L^* = L^0 \cup L^1 \cup ...$


## 文法


文法描述了造句的规则
- 句子是无穷的
- 但用于造句的规则是有穷的
- 用有穷集合描述无穷集合

1. 规则(产生式)

形如$a \rightarrow b(a::=b)$的$(a,b)$有序对，其中
- $a$ 称为规则的左部
- $b$ 称规则的右边
- $\rightarrow (::=)$ 读作“定义为”


2. 文法

文法$G$定义为四元组($V_N,B_T,P,S$)
- $V_N$(Vocabulary of Non_terminals)：非终结符（变量）集合
- $V_T$(Vocabulary of Terminals)：终结符集合（常量）集合
    > $V=V_N∩V_T$称为文法G的字母表  
- $P$(Production rules)：规则(产生式)$(a\rightarrow b)$的集合
- $S$(Start Symbol)：开始符
    > 是一个非终结符，至少在一条规则中作为左部出现

> 非终结符类似于中文中的句型中的主谓宾，终结符相当于主谓宾这几部分的取值

3. 文法G的表示

很多时候，不将文法$G$的四元组显示的表示出来，而只将产生式写出。一般约定
- 第一条产生式的左部为开始符；
- 用尖括号括起来（或用大写字母）的是非终结符
- 不用尖括号括起来（或小写字母）的是终结符
- 将$G$写成$G[S]$ ，其中$S$是开始符



## 文法上的语言

1. 推导

推导表示的是两个符号串$v,w$之间的关系($v,w \in V$)，存在以下三种推导

- $\Rightarrow$：直接推导
- $\overset{+}{\Rightarrow}$：长度为$n(n>=1)$的推导
- $\overset{*}{\Rightarrow}$：长度为$n(n>=0)$的推导
> 规约是推导的逆过程

2. 文法的句型和句子

设$G[S]$是文法

- 若$S \overset{*}{\Rightarrow} x$，则称$x$是文法$G[S]$的句型
- 若$S \overset{*}{\Rightarrow} x,x \in V_T^*$，则称$x$是文法$G[S]$的句子

3. 文法产生的语言

文法$G[S]$所有句子的集合称为文法$G[S]$的语言$L(G)$
$$L(G) = \{x | S \overset{*}{\Rightarrow}x,x \in V_T^*\}$$


> 若$L(G1)=L(G2)$ ，那么称文法$G1$和$G2$是等价的


# 3. 文法的类型

按照文法的复杂程度可分为四类，不同在于对产生式所加的限制条件不同

$$3型 \subseteq 2型 \subseteq 1型 \subseteq 0型$$

1. 0型(短语文法)
$$a\rightarrow b$$
- $a,b\in V^*$
- $a$至少含有一个非终结符

2. 1型(上下文有关的)
$$a\rightarrow b$$
- $|a|\le |b|(S \rightarrow \epsilon除外)$
- 只有$S$不出现在产生式右部，才允许$S \rightarrow \epsilon$出现

3. 2型(上下文无关的)
$$A\rightarrow b$$
- $A\in V_N^*$
- $b\in V^*$

4. 3型(正规文法)
$$A \rightarrow aB|a$$
- $A,B \in V_N$
- $a \in V_T^*$


# 4. 上下文无关文法及其语法树


上下文无关语法足够描述现今程序设计语言的语法结构，语法分析以它为理论基础

## 语法树(推导树)

语法树是一种描述上下文无关文法的句型推导的直观工具

1. 特点

给的文法$G=(V_N,V_T,P,S)$，对于G的任何句型都能构造与之关联的语法树，该树
- 每个节点都有一个标记($V$的一个符号)
- 根的标记是S 
- 若一个结点n至少有一个它自己除外的子孙，并且有标记A，则标记A肯定在$V_N$中
- 若结点n(标记为A)的直接子孙从左到右的次序依次位标记$A_1,A_2...A_k$，那么$A\rightarrow A_1A_2...A_k$一定是$P$中的一个产生式


语法树的结果: 从左至右读出推导树的叶子节点，得到的句型就是语法树的结果

2. 不足

语法树
- 表示了在推导过程中使用了哪个产生式和用在了哪个的非终结符上
- 但是并没有表明使用产生式的顺序，可能有多个推导过程




### 最左和最右推导

定义最左推导，最右推导，解决替换哪个非终结符的选择的不确定性

1. 最左推导

在推导时，都使用规则替换当前句型中最左边的非终结符

2. 最右推导


在推导时，都使用规则替换当前句型中最右边的非终结符
> 最右推导常常被称为规范推导，由规范推导得到的句型称为右句型或规范句型



### 二义性

如果⼀个⽂法存在某个句⼦对应两棵不同的语法树，则说这个⽂法是⼆义的
- 一个是否为二义的问题是递归不可解的，即不存在解决该问题的算法
- 没有通用的办法可以消除文法的二义性，但对于特定的文法，可找到特定的消除二义性的办法



# 5. 句型的分析

句型的分析就是识别一个字符串是否为某文法的句型(句子)
- 如果根据文法能构造一棵语法树其结果等于该符号串
- 这个符号串即为此文法的句型

## 自上而下方法

1. 步骤

- 从⽂法符号开始，将它作为语法树的根
- 反复使用文法中的产生式进行 ***推导***，向下逐步建⽴语法树
- 试图使语法树的叶子结点符号串匹配输⼊符号串 

2. 问题

- 选择当前句型中的哪个非终结符进行推导
- 对于给定的非终结符，选择哪个产生式进行推导的问题



## 自下而上方法

1. 步骤

- 从输⼊符号串开始，作为某个（可能存在的）语法树的结果
- ⾃下⽽上地构造语法树（反向推理，逐步“向上 ***规约*** ”）
    - 从当前输入串中选择⼀个⼦串，其与某⼀产⽣式的右端相匹配
    - 将它归约到某个⾮终结符(该子串称为可归约子串)
- 试图规约到开始符号
> 问题是如何选择这个“可归约子串”


2. 问题

选择哪个子串进行归约
- 对这个概念的不同定义形成了不同的自底向上分析方法
- 在一种称作“规范归约”的分析中，这种“可归约串”称作“句柄”


3. 术语

令$G[S]$是⼀个上下文无关文法，若有
$$S \overset{*}{\Rightarrow} aBc \overset{+}{\Rightarrow} adc$$

- 当$B \overset{+}{\Rightarrow} d$，称$d$为句型$adc$相对于$B$的 ***短语***
- 当$B \Rightarrow d$，称$d$为句型$adc$相对于$B$的 ***直接短语***
- 一个**右句型**（最右推导所产生的句型）的**直接短语**称为该句型的 ***句柄***

$$S \overset{*}{\Rightarrow}_{right\_most} aBc \overset{B \rightarrow d}{\Rightarrow}_{right\_most} adc,c \in V_T^*$$

> 对于无二义文法，一个右句型的唯一句柄是其所有直接短语中最左边的那一个，这是由于在最右推导中，最左边的最后推导；而归约时是从左向右读，因此在归约过程中，是先归约最左边的部分




# 6. 有关文法实际应用的一些说明



1. 限制文法中不得含有**有害规则**和**多余规则**

- 有害规则：形如`U->U`的产生式，会引起二义性

- 无用规则：文法中无法推导出句子的规则
    - 不可到达的：文法中某些非终结符不在任何规则的右部出现
    - 不可终止的：不能从它推导出终结符号来

2. $\epsilon$规则会使得有关文法的一些讨论和证明变得复杂

- $\epsilon$规则是形如`A->ε`的产生式
