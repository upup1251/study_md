第三章、词法分析

[toc]


词法分析是编译的第一个阶段，主要任务是从左至右逐个字符地对源程序进行扫描，产生一个个单词序列，用于语法分析。

本周介绍词法分析程序的设计原则、单词的描述技术、识别机制及词法分析程序的自动构造原理


# 词法分析程序的设计

## 词法分析程序和语法分析程序的接口方式

1. 利用中间文件：词法分析⼯作可以是独⽴的⼀遍，把字符流的源程序变为单词序列，输出到⼀个中间⽂件，这个⽂件作为语法分析程序的输⼈⽽继续编译过程。

2. 子程序： 将词法分析程序设计成⼀个⼦程序，每当语法分析程序需要⼀个单词时，则调⽤该⼦程序。词法分析程序每得到⼀次调⽤，便从源程序⽂件中读⼊⼀些字符，直到识别出⼀个单词，或说直到下⼀个单词的第⼀个字符为⽌



![](assets/3inter.png)

## 词法程序的输出

词法分析程序在识别出下⼀个单词
- 验证其词法正确性之后，词法分析程序将结果以***单词符号***的形式发送⾄语法分析程序以回应其请求。
- 若在单词识别过程中发现词法错误，则返回出错信息。

单词符号一般可以分为以下5类
- 关键字，也称保留字
- 标识符，⽤来表⽰各种名字，如常量名、变量名和过程名等。
- 常数，各种类型的常数
- 运算符
- 界符，如逗号、分号、括号等。

词法分析程序所输出的单词符号可以采⽤以下⼆元式表⽰：
$$（单词种别，单词⾃⾝的值）$$
> 单词种类可以用int型数据代替，单词自身的值可以用指针指向

- 单词的种别是语法分析需要的信息
- 单词⾃⾝的值则是编译其他阶段需要的信息。


## 词法分析程序如何识别单词

词法分析中识别下⼀个单词的过程：简单来看就是逐个读取字符，然后将它们拼在⼀起的过程。

词法分析程序的作⽤：在这个拼单词的过程中如何获得下⼀个有意义的单词符号，即识别出单词种别以及单词⾃⾝的值。

要识别出有意义的单词符号，主要是依据程序设计语⾔的词法规则描述

描述⼀个语⾔的词法规则，通常需要借助形式化或半形式化的描述⼯具，以保证没有歧义性
> 常见的可⽤于词法规则描述的⼯具有状态转换图、扩展巴克斯范式（EBNF）、有限状态⾃动机、正规表达式以及正规⽂法等

在识别出有⼀个意义的单词后，词法分析程序将单词种别连同单词⾃⾝的值⼀起构成⼀个单词符号，返回给调⽤它的语法分析程序。


# PL/0编译程序中的词法分析程序

本节以PL/0编译程序为背景，介绍⼀个词法分析程序的设计实例


可将PL/0语⾔的单词分为保留字、运算符、标识符、⽆符号整数和界符5个⼤类，以下是针对这5类单词的⼀种EBNF描述：
```text
<无符号整数> ::= <数字>{<数字>}
<标识符> ::= <字母>{<字母>|<数字>}
<字母> ::= a|b|...|X|Y|Z
<数字> ::= 0|1|...|8|9
<保留字> ::= const|var|procedure|begin|end|odd|if|then|call|while|do|read|write
<运算符> ::= +|-|*|/|=|#|<|<=|>|>=|:=
<界符> ::= (|)|,|;|.
```
> 保留字、运算符和界符这⼏类各⾃仅包含有限个单词符号，在实践中更⽅便将每个单词符号设计为独⽴的词法单元，即每个单词符号拥有独⽴的类
> like: enum symbol{number,plus,minus,ifsym thensym...}

PL/0语法分析程序在需要读取下⼀个单词时，就调⽤getsym（），返回下⼀个单词符号。
- 除标识符和⽆符号整数外，其他单词符号只包含单词种别的信息。
- 标识符和⽆符号整数的单词符号包含单词种别和单词⾃⾝的值两个部分。
> 由于标识符是在语法分析阶段登录在符号表⾥的，所以对于标识符来说，PL/0词法分析程序所返回的单词⾃⾝的值不是符号表位置的指针，⽽是标识符的名字串。


PL/0编译程序定义3个全程变量来传递单词种别和单词⾃⾝的值。
1. 通过全局变量`sym`传递单词种类：
`enum symbol sym`
2. 通过全局变量`id`传递标识符单词自身的值，即标识符的名字：
`char id[max_length+1]`
> `max_length`是预设的标识符最大值
3. 通过全局变量`num`传递无符号整数单词自身的值，即它的整数值：
`int num`

> 举例：⽐如，在识别出标识符position之后，全局变量sym的值被置为ident，id的值被置为“position”；在识别出⽆符号整数60之后，全局变量sym的值被置为number,num的值被置为整数值60。


getsym（）逐个读取下⾯的字符，然后将它们拼成下⼀个有意义的单词，返回相应的单词符号。图3.2描述了PL/0语⾔的词法规则，可⽤于指导单词识别的过程。

![](assets/pl0status.png)
- 在识别字母数字串的单词后如何区分是标识符还是保留字。常采取的方法是预设⼀个保留字表，通过查表来确定是否保留字
- 在识别双符号运算符之类的单词时，要注意到可能需要进⾏字符退还



# 单词的形式化描述工具

## 正规文法

正规⽂法也称为$3$型⽂法$G=(V_N,V_T,S,P)$，其$P$中的每⼀条规则都有下述形式：$A \to aB$或$A \to a$，其中$A,B \in V_N，a \in V_T^*。正规⽂法所描述的是$V_T$上的正规集。

> ![](assets/33wenfa.png)

## 正规式（正规表达式）

设字母表为$A$，辅助字母表$B=\{\emptyset , \epsilon , | , * , ( , ) \}$。
1. $\epsilon$和$\emptyset$必都是$A$上的正规式，它们所表⽰的正规集分别为$\{\epsilon \}$和$\emptyset$。
2. 任何$a \in A$，$a$是$A$上的⼀个正规式，它所表⽰的正规集为$\{a\}$。
3. 假定$\{e_1 \}$，和$\{e_2 \}$都是$A$上的正规式，它们所表⽰的正规集分别为$L(e_1)$和$L(e_2)$，那么$(e_1),e_1|e_2,e_1 \cdot e_2,e_1^*$也都是正规式，它们所表⽰的正规集分别为$L(e_1),L(e_1) \cup L(e_2),L(e_1)L(e_2),(L(e_1))^*$
4. 仅由有限次使⽤上述3个步骤⽽定义的表达式才是$A$上的正规式，仅由这些正规式所表⽰的符号串的集合才是$A$上的正规集。

其中
- `|`: 读为“或”（也有用“+”代替“｜”的）
- $\cdot$ : 读为“连接”，
- `*`: 读为“闭包”（即任意次有限次的自重复连接）
> 不致混淆时，括号可省去，规定优先级为$* > \cdot > |$  
> 连接符$\cdot$一般可省略  
> $*,\cdot ,|$都是左结合的  


若两个正规式$e_1,e_2$所表示的正规集相同，则说$e_1,e_2$等价，写作$e_1 = e_2$

正规式服从的代数规律：
1. $r|s = s|r$
2. $r|(s|t) = (r|s)|t$
3. $(rs)t = r(st)$
4. $r(s|t) = rs|rt$
5. $\epsilon r=r, r \epsilon = r$
6. $r|r=r$


## 正规文法和正规式的等价性

正规文法和正规式的等价性： 对任意⼀个正规⽂法，存在⼀个定义同⼀个语⾔的正规式；反之，对每个正规式，存在⼀个⽣成同⼀个语⾔的正规⽂

- 正规式to正规文法

![](assets/3uitowenfa.png)

- 正规文法to正规式
![](assets/3wenfatoui.png)


# 有穷自动机

有穷⾃动机（也称有限⾃动机）作为⼀种识别装置，能准确地识别正规集，即识别正规⽂法所定义的语⾔和正规式所表⽰的集合。

引⼈有穷⾃动机理论，正是为词法分析程序的⾃动构造寻找特殊的⽅法和⼯具。

## 确定的有穷自动机(DFA)

一个有穷自动机$M$是一个五元组
$$M=(M,\Sigma ,f,S,Z)$$
- $K$: 有穷集合，每个元素表示一个状态
- $\Sigma$: 有穷字母表，每个元素称为一个输入符号
- $f$: 转换函数，$f(k_i,a)=k_j(k_i \in K,k_j \in K)$，输入当前状态和输入字符，将输出下一个状态
- $S \in K$: 唯一的初态
- $Z \subseteq K$: 终态集，终态也称为可接受状态或结束状态

⼀个DFA可以表⽰成⼀个状态图（或称状态转换图）。
- 假定DFAM含有m个状态，n个输⼈符号，那么这个状态图含有m个结点，每个结点最多有n个弧射出
- 整个图含有唯⼀⼀个初态结点和若⼲个终态结点
    - 初态结点冠以“=”或标以“⼀”
    - 终态结点⽤双圈表⽰或标以“⼗”
- 若$f(k_i,a)=k_j$，则从状态结点$k_i$到状态结点$k_j$画标记为$a$的弧。

⼀个DFA还可以⽤⼀个矩阵表⽰
- 该矩阵的⾏表⽰状态，列表⽰输⼈符号，矩阵元素表⽰相应状态和输⼊符号将转换成的新状态，即k⾏a列为f（k，a）的值
- 可以⽤“=”标明初态；否则第⼀⾏即是初态，相应终态⾏在表的右端标以1，⾮终态标以0


> 三者之间转换的例子：
> ![](assets/33.5li)

> ![](assets/33.6li)


若$t \in \Sigma ^*,f(S,t)=P$，其中$S$为$DFA M$的开始状态，$P \in Z$，$Z$为终态集。则称$t$可为$DFA M$所接受（识别）。
> 即对于$\Sigma ^*$中的任何符号串$t$，若存在⼀条从初态结点到某⼀终态结点的道路，且这条路上所有弧的标记符连接成的符号串等于$t$，则称$t$可为$DFA M$所接受，若$M$的初态结点同时又是终态结点，则空字可为$M$所识别（接受）。


为了描述一个符号串$t$可被$DFA M$所接受，需要扩充转换函数
- 设$Q \in K$，函数$f(Q,\epsilon )=Q$
> 即如果输入符号是空串，则仍停留在原来的位置上
- 若一个输入符号串$t$（可表示为$t_1t_x$，其中$t_1 \in \Sigma,t_x \in \Sigma ^*$），则有$f(Q,t_1t_x)=f(f(Q,t_1),t_x)$

$DFA M$所能接受的符号串的全体记作$L(M)$

结论：$\Sigma$上的一个符号串集合$V \subseteq \Sigma ^*$是正规的，当且仅当存在一个$\Sigma$上的确定有穷自动机$M$，使得$V = L(M)$

## 不确定的有穷自动机(NFA)

一个不确定的有穷自动机$M$是一个五元组：
- $K$: 有穷集合，每个元素表示一个状态
- $\Sigma$: 有穷字母表，每个元素称为一个输入符号
- $f$: 一个从$K times \Sigma ^*$到$K$的全体子集的映像，即$K \times \Sigma ^* \to 2_K$，其中$2^K$表示$K$的幂集
> 即对于同一当前状态和字符输入，存在多个输出与之对应，存在不确定状态
- $S \in K$: 非空初态集
- $Z \subseteq K$: 终态集

⼀个含有m个状态和n个输⼈符号的NFA可表⽰成⼀张状态转换图
- 这张图含有m个状态结点，每个结点可射出若⼲条箭弧与别的结点相连接，每条弧⽤$\Sigma ^*$中的⼀个串作标记
- 整个图⾄少含有⼀个初态结点以及若⼲个终态结点。


对于$\Sigma ^*$中的任何⼀个串$t$，若存在⼀条从某⼀初态结点到某⼀终态结点的道路，且这条道路上所有弧的标记字依序连接成的串（不理睬那些标记为$\epsilon$的弧）等于$t$，则称$t$可为NFAM所识别（读出或接受）。

若M的某些结点既是初态结点又是终态结点，或者存在⼀条从某个初态结点到某个终态结点的$\epsilon$道路，那么空字可为M所接受

显然DFA是NFA的特例。对于每个$NFA M$，存在⼀个$DFA M'$，使得$L(M) = L(M')$。

对于任何两个有穷⾃动机$M$和$M'$，如果$L(M)=L(M')$，则称$M$与$M'$是等价的


## $NFA$转换为等价的$DFA$


定理1 ： 设L为⼀个由不确定的有穷⾃动机接受的集合，则存在⼀个接受L的确定的有穷⾃动机

为⼀个NFA构造相应的DFA的基本想法是让DFA的每⼀个状态对应NFA的⼀组状态。


### 两种运算

介绍⼦集法之前先定义状态集合$I$的两个运算：
- 状态集合$I$的$\epsilon-闭包(\epsilon -closure(I))$，定义为一个状态集，是状态集$I$中任何状态$S$经任意条$\epsilon$弧能到达的状态的集合
> 输入为$\epsilon$时，自动机将停留在原来的状态，显然状态集合$I$的任何状态$S$都属于$\epsilon -closure(I)$
- 状态集合$I$的$a$弧转换$(move(I,a))$，定义为状态集合$J$，其中$J$是所有那些可从$I$中的某一状态经过一条$a$弧而到达的状态的集合 


对于一个$NFA N = (K,\Sigma ,f,K_0,K_t)$来说，若$I$时$K$的一个子集，不妨设$I = {S_1,S_2...S_j}$，$a$是$\Sigma$中的一个元素，则
$$move(I,a) = f(S_1,a) \cup f(S_2,a_ \cap ... \cap f(S_j,a)$$


### 子集法

对$NFA N = (K,\Sigma , f,K_0,K_t)$，其对应的$DFA M = (S,\Sigma , D,S_0,S_t)$中各值如下:

1. $M$的状态集$S$由$K$的一些子集组成

![](assets/subsetconstruct.png)

2. $M$和$N$的输入字母表是相同的，即是$\Sigma$
3. 转换函数$D$的定义:$D([S_1,S_2,...,S_j],a) = [R_1,R_2,...,R_i]$
其中$\epsilon -closure(move[S_1,S_2,...,S_j],a)) = [R_1,R_2,...R_i]$

4. $S_0 = \epsilon -closure(K_0)$作为$M$的开始状态
5. $S_t = {[S_j,S_k,...,S_e]，其中[S_j,S_k,...,S_e] \in S 且 {S_j,S_k,...,S_e} \cap K_t \ne \emptyset}$



<!-- TODO: 子集法 -->





## 确定有穷自动机的化简

⼀个有穷⾃动机可以通过***消除⽆⽤状态***和***合并等价状态***⽽转换成⼀个与之等价的最⼩状态的有穷⾃动机

###  消除无用状态 

⽆⽤状态：从该⾃动机的开始状态出发，任何输⼊串也不能到达的那个状态，或者从这个状态没有通路到达终态

对策：对于给定的有穷⾃动机，如果它含有⽆⽤状态，可以⾮常简单地将⽆⽤状态消除，⽽得到与它等价的有穷⾃动机

### 合并等价状态

两个状态s和t等价的条件是一下两个
- 一致性条件：状态s和t必须同时为可接受状态或不可接受状态。
- 蔓延性条件：—对于所有输⼈符号，状态s和状态t必须转换到等价的状态⾥
> 如果有穷⾃动机的状态s和：不等价，则称这两个状态是可区别的。

对策：分割法

把⼀个DFA（不含多余状态）的状态分成⼀些不相交的⼦集，使得任何不同的两个⼦集的状态都是可区别的，⽽同⼀⼦集中的任何两个状态都是等价的


1. 首先将M的状态分为两个子集
- ⼀个由终态（可接受态）组成
- 另⼀个由⾮终态组成

2. 寻找⼀个⼦集和⼀个输⼈符号使得这个⼦集中的状态可区别
- 即，对于同一个子集中的状态，一些状态得到的输出如果属于当前被划分子集中的同一个子集内，那么这些元素仍是不可区分的；否则是可区分的，将可区分的元素分裂至多个子集中。



# 正规式和有穷自动机的等价性

由以下两点说明正规式与有穷自动机的等价性：
- 对于$\sum$上的$NFA \quad M$，可以构造一个$\sum$上的正规式$r$，使得$L(r) = L(M)$
- 对于$\sum$上的每个正规式，可以构造一个$\sum$上的$NFA \quad M$，使得$L(M) = L(r)$

## 从有穷自动机构造正规式

1. 在M的状态转换图上加进两个结点，⼀个为x结点，⼀个为x结点
- 从x节点⽤$\epsilon$弧连接到M的所有初态结点
- 从M的所有终态结点⽤$\epsilon$弧连接⼀个为y结点  
从x结点到y结点。形成⼀个与M等价的M'，M'只有⼀个初态x和⼀个终态y。

2. 逐步消去M’中的所有结点，直⾄只剩下x和y结点。在消去过程中，逐步⽤正规式来标记弧。消去规则如下
![从有穷自动机到正规式的消去规则](assets/2024-11-13-17-47-49.png)


## 从正规式到有穷自动机

语法制导方法：按照正规式的语法结构指引构造过程，⾸先将正规式分解成⼀系列⼦表达式，然后使⽤如下规则r构造NFA，对r的各种语法结构的构造规则具体描述如下：

![(1)](assets/2024-11-13-17-51-45.png)

![(2)](assets/2024-11-13-17-53-00.png)




# 正规文法和有穷自动机的等价性

采用下面的规则可将正规文法G直接构成一个有穷自动机NFA，使得$L(M)=L(G)$
- M的字母表与G的终结符集相同
- 为G中的每个⾮终结符⽣成M的⼀个状态（不妨取成相同的名字），G的开始符S是M的开始状态S
- 增加⼀个新状态Z，作为M的终态
- 对G中的形如$A \to tB$的规则（其中$t$为终结符或$\epsilon$，A和B为⾮终结符的产⽣式），造M的⼀个转换函数$f(A,t) = B$
- 对G中形如$A \to t$的产⽣式，构造M的⼀个转换函数$f(A,t)=Z$。

# 词法分析程序的自动构造工具

在本章所介绍的形式模型--有限⾃动机、正规表达式以及正规⽂法基础上容易实现词法分析程序的⾃动构造。

通常是⽤正规表达式或正规⽂法作为词法规则的形式描述，然后通过转化为等价的有限⾃动机来设计相应的单词识别过程

正规表达式为例，典型的过程可能是：
1. 每⼀种别的单词均对应⼀个正规表达式，所有正规表达式以⽂本⽅式作为⾃动构造⼯具的输⼊。
2. ⾃动构造⼯具将每⼀个正规表达式转换成有限⾃动机的形式，⽐如使⽤3.5节中的⽅法将正规表达式转换成NFA。
    1. 必要时，⾃动构造⼯具会将有限⾃动机确定化，⽐如使⽤3.4.3节中的⽅法得到等价的DFA。
    2. 必要时，⾃动构造⼯具会将有限⾃动机最⼩化，⽐如使⽤3.4.4节中的⽅法得到等价的拥有状态数⽬最少的DFA。
3. ⾃动构造⼯具按照⼀定的控制策略⽣成词法分析程序中扫描程序的代码
    1. 该扫描程序可以选择对每⼀单词种别所对应的有限⾃动机进⾏模拟运⾏
    2. 并从当前输⼈符号序列中识别下⼀个单词
4. 然后返回相应的单词符号。



通常，单词符号所采⽤的数据结构也需要由使⽤者来给定，连同每⼀单词种别对应的正规表达式⼀同作为⾃动构造⼯具的输⼊；单词符号中的单词种别⼀般会由使⽤者预先设定。另外，⼀些⼯具会按照描述的先后次序以及可识别单词的最⼤长度等来确定内部控制策略，这些约定通常也要明确告知使⽤者


基于这种⽅法来构造词法分析程序的⼯具很多，本节主要介绍⾃动构造⼯具lex。

lex⼯具的功能是读⼈⽤户编写的⼀个lex描述⽂件，⽣成⼀个名为lex.yy.c的C源程序⽂件。lex.yy.c中包含⼀个核⼼h函数yylex（），它是⼀个扫描⼦程序，读⼊源程序的字符流，识别并返回下⼀个单词符号，如图3.15所⽰

![3.15](assets/3.15)

- lex描述⽂件中包含针对每⼀类词法单元的规则。规则由正规表达式和C语⾔代码两部分组成。


## lex描述文件中使用的正则表达式

## lex描述文件的格式


lex描述⽂件由3个部分组成，各部分之间被只含%%的⾏分隔开：
```lex
辅助定义部分
%%
规则部分
%%
⽤户⼦程序部分
```

1. 辅助定义部分

包含正规表达式宏名字的声明以及开始条件的声明。它们可能出现在规则部分的正规表达式中，⽤法见3.7.1节

声明正规表达式宏名字的格式为`宏名字 正规表达式` 

- 开始条件


开始条件声明开始于%Start(缩写为%s,%S)，后跟一个名字列表，每个名字代表一个开始条件。

开始条件可以在规则的活动部分使用BEGIN激活。直到下一个BEGIN执行时，拥有给定开始条件的规则被激活，而不拥有开始条件的规则不被激活

每个开始条件表示不同的上下文

2. 规则部分

正规表达式必须从第⼀列写起，⽽结束于第⼀个⾮转义的空⽩字符。这⼀⾏的剩余部分即为动作。动作必须从正规式所在⾏写起。当某条规则的动作超过⼀条语句时，必须⽤花括号括起来

一条规则由两部分组成：`正规表达式 动作` 

- 如果动作部分为空，则匹配该正则表达式的输入字符流会被直接丢弃；否则会执行所匹配正规表达式后的动作
- 输入字符流中不与任何规则中的正规是匹配的串会被默认为将被照抄到输出⽂件；

动作中可以⽤到yytext、yyleng等变量。其中，yytext指向当前正被某规则匹配的字符串；yyleng存储yytext中字符串的长度

此外，动作中还允许包含特定的指导语句或函数，如ECHO、BEGIN、REJECT、yymore（）、yyless（n）、unput（c）、input（）等。技术细节可参考有关lex的技术⽂档。



在辅助定义部分和规则部分，任何未从第⼀列开始的⽂本内容，以及被％（和％｝括起来的部分，将被复制到lex.yy.c⽂件中（不包括%｛｝）

规则部分，出现在第⼀条规则之前的从第⼀列开始的或被%｛和%｝括起来的部分⾥可以声明扫描⼦程序yylex（）的局部变量，以及每次进⼈yylex（）时执⾏的代码

在辅助定义部分中，第⼀列开始的注释（即始于/*的⾏）也将被复制，直到遇到下⼀个1。但规则部分中不可以这样。

最后，⽤户⼦程序部分中的调⽤扫描⼦程序或被扫描⼦程序调⽤的所有C语⾔函数将被原样照抄到lex.yy.c⽂件中。

，当遇到⽂件结尾时，词法分析程序将⾃动调⽤yywrap（）来确定下⼀步做什么。如果yywrap（）返回0，那么就继续扫描；如果yywrap（）返回1，那么就认为对输⼈串的处理已结束。lex库中的yywrap（）标准版本总是返回1。⽤户可以根据需要在⽤户⼦程序部分写⼀个⾃⼰的yywrap（），它将取代lex库中的版本。



## lex的使用

```bash
lex <file.l>
# 会产生文件lex.yy.c

cc -o outputfilename lex.yy.c -ll
# 使用编译器cc对lex.yy.c进行编译，-o 指明可执行文件的名字，-ll是lex库文件的选项

./outputfilename < <file.l>
# 执行outputfilename，输入参数为文件<file>中的文本
```

## 与yacc的接口约定

yacc产⽣的分析⼦程序在申请读⼊下⼀个单词时会
- 调⽤yylex（）
- yylex（）返回⼀个单词符号，并将相关的属性值存⼈全局量yylval。

为了联⽤lex和yacc，需要在运⾏yacc程序时加选项-d，以产⽣⽂件y.tab.h，其中会包含在yace描述⽂件中（由%tokens定义）的所有单词种别。⽂件y.tab.h将被包含在lex描述⽂件中。
